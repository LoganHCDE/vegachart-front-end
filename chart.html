<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vega Chart</title>
    <link rel="icon" type="image/svg+xml" href="logo.svg" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Optional monospace fonts to better match editor themes -->
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Source+Code+Pro:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- VS Code-like editor theme is provided by Monaco (vs-dark) -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0a0a0a;
            color: #e5e7eb;
        }
        /* Custom scrollbar for a more modern look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937;
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }

        /* Styles for the collapsible component content area */
        .component-content {
            max-height: 1000px; /* A large enough value to not clip content */
            overflow: hidden;
            transition: max-height 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), padding 0.5s ease-in-out;
            padding: 1rem;
        }

        /* Styles for when the component is collapsed */
        .component.collapsed .component-content {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-bottom: 0 !important;
        }

        /* Chevron rotation animation */
        .chevron-icon {
            transition: transform 0.3s ease-in-out;
        }

        .component.collapsed .chevron-icon {
            transform: rotate(-90deg);
        }
        
        /* Custom neon glow effect for focus states */
        .neon-focus-green:focus-within {
            box-shadow: 0 0 5px #34d399, 0 0 10px #34d399, 0 0 15px #34d399;
        }
        .neon-focus-blue:focus-within {
            box-shadow: 0 0 5px #60a5fa, 0 0 10px #60a5fa, 0 0 15px #60a5fa;
        }
        
        /* Active state for library buttons */
        .library-btn.active {
            background-color: #34d399;
            color: #ffffff;
        }
        
        .vc-editor-readonly,
        .vc-editor-readonly * {
            cursor: not-allowed !important;
        }
        
        /* Style for the action buttons in output components */
        .action-btn {
            background-color: #374151; /* Corresponds to bg-gray-700 */
            color: #d1d5db; /* Corresponds to text-gray-300 */
            border-radius: 0.375rem; /* Corresponds to rounded-md */
            display: flex;
            align-items: center;
            gap: 0.5rem; /* Corresponds to space-x-2 */
            transition: background-color 150ms ease-in-out; /* Corresponds to transition-colors */
        }

        .action-btn:hover {
            background-color: #4b5563; /* Corresponds to hover:bg-gray-600 */
        }
        
        /* Ensure highlight.js code block has the right background */
        #code-output-container pre {
            background-color: transparent;
            padding: 0;
            margin: 0;
            height: 100%;
        }
        /* Hide Monaco's built-in find widget; use custom search instead */
        .monaco-editor .find-widget { display: none !important; }
        /* Custom code search highlight (Monaco inlineClassName) */
        .vc-search-match {
            background-color: rgba(180, 83, 9, 0.35); /* amber-700 w/ alpha */
            border-radius: 2px;
        }
        /* Custom code search UI styles */
        #code-search-bar input[type="text"] {
            background: #111827;
            color: #e5e7eb;
            border: 1px solid #374151;
        }
        
        /* RStudio-inspired styling for R code blocks */
        .r-code-container {
            background-color: #2b2b2b !important;
            border: 1px solid #3c3c3c !important;
            border-radius: 6px !important;
        }
        
        .r-code-container .monaco-editor {
            background-color: #2b2b2b !important;
        }
        
        .r-code-container .monaco-editor .monaco-editor-background {
            background-color: #2b2b2b !important;
        }
        
        /* R-specific line highlighting */
        .r-code-container .monaco-editor .view-line {
            color: #d4d4d4 !important;
        }
        
        /* Line numbers for R code - RStudio dark style */
        .r-code-container .monaco-editor .line-numbers {
            color: #858585 !important;
            background-color: #2b2b2b !important;
        }
        
        /* Current line highlighting for R */
        .r-code-container .monaco-editor .current-line {
            background-color: #323232 !important;
        }
        
        /* Selection background for R code */
        .r-code-container .monaco-editor .selected-text {
            background-color: #264f78 !important;
        }
        
        /* Cursor color for R code */
        .r-code-container .monaco-editor .cursor {
            background-color: #d4d4d4 !important;
        }
        
        /* R syntax highlighting to match RStudio dark theme */
        .r-code-container .monaco-editor .mtk1 { color: #d4d4d4 !important; } /* default text */
        .r-code-container .monaco-editor .mtk2 { color: #6a9955 !important; font-style: italic; } /* comments */
        .r-code-container .monaco-editor .mtk3 { color: #569cd6 !important; font-weight: bold; } /* keywords */
        .r-code-container .monaco-editor .mtk4 { color: #ce9178 !important; } /* strings */
        .r-code-container .monaco-editor .mtk5 { color: #b5cea8 !important; } /* numbers */
        .r-code-container .monaco-editor .mtk6 { color: #c586c0 !important; } /* operators */
        .r-code-container .monaco-editor .mtk22 { color: #dcdcaa !important; } /* function names */

    /* PyCharm (Darcula)-inspired styling for Python code blocks */
    .pycharm-code-container {
      background-color: #2b2b2b !important; /* Darcula background */
      border: 1px solid #3c3f41 !important;
      border-radius: 6px !important;
    }
    .pycharm-code-container .monaco-editor,
    .pycharm-code-container .monaco-editor .monaco-editor-background {
      background-color: #2b2b2b !important;
    }
    .pycharm-code-container .monaco-editor .view-line {
      color: #a9b7c6 !important; /* default text */
    }
    .pycharm-code-container .monaco-editor .line-numbers {
      color: #606366 !important;
      background-color: #2b2b2b !important;
    }
    .pycharm-code-container .monaco-editor .current-line {
      background-color: #323232 !important;
    }
    .pycharm-code-container .monaco-editor .selected-text {
      background-color: #214283 !important; /* Darcula selection */
    }
    .pycharm-code-container .monaco-editor .cursor {
      background-color: #a9b7c6 !important;
    }
        
        .output-container {
            aspect-ratio: 1.6 / 1;
            width: 100%;
            height: auto;
        }
        
        /* Make selects with placeholder value appear more grayed out */
        .select-placeholder { color: #9CA3AF !important; }
        
        /* Hide Plotly's built-in notifier so we use our unified toast */
        .plotly-notifier { display: none !important; }
        
        
    /* Custom number input (hide native spinners) */
    input[type=number].custom-number::-webkit-outer-spin-button,
    input[type=number].custom-number::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type=number].custom-number {
      appearance: textfield;
      -moz-appearance: textfield; /* Firefox: hide default spinner */
    }
    
    /* Responsive layout override: switch to single column when viewport is 6:5 or narrower */
    @media (min-width: 768px) and (max-aspect-ratio: 6/5) {
      /* Force main grid to 1 column even at wider widths */
      main.grid { grid-template-columns: 1fr !important; }
      /* Ensure both columns span full width */
      #left-col, #right-col { grid-column: 1 / -1 !important; }
	  /* Also collapse any sm: two-column subgrids to one column */
	  .sm\:grid-cols-2 { grid-template-columns: 1fr !important; }
    }

  /* JS fallback class: apply same overrides when html has .ar-narrow */
  @media (min-width: 768px) {
    html.ar-narrow main.grid { grid-template-columns: 1fr !important; }
    html.ar-narrow #left-col,
    html.ar-narrow #right-col { grid-column: 1 / -1 !important; }
    html.ar-narrow .sm\:grid-cols-2 { grid-template-columns: 1fr !important; }

    /* Force single column on very narrow viewports, overriding sm: styles */
    @media (max-width: 480px) {
      .sm\:grid-cols-2 {
        grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
      }
    }
  }
  </style>
</head>
<body>
    <!-- Top Navigation -->
<!-- Top Navigation -->
<nav class="w-full bg-gray-950 border-b border-gray-800 mb-4 nav-space">
  <div
    class="max-w-7xl mx-auto h-14 flex items-center justify-between px-4"
  >
    <a href="chart.html" class="flex items-center space-x-3">
      <div
        class="w-8 h-8 bg-gray-900 rounded-lg flex items-center justify-center"
      >
        <img src="logo.svg" alt="Logo" class="w-6 h-6" />
      </div>
      <span class="text-xl font-bold text-gray-100"
        >Vega <span class="text-emerald-400">Chart</span></span>
    </a>
    <div class="flex items-center space-x-6">
      <!-- Active page: Build -->
      <a
  href="chart.html"
        class="text-emerald-400 font-semibold border-b-2 border-emerald-400"
      >
        Build
      </a>
      <a
        href="guide.html"
        class="text-gray-300 hover:text-emerald-400 font-medium transition"
        >Guide</a
      >
      
      <a
        href="feedback.html"
        class="text-gray-300 hover:text-emerald-400 font-medium transition"
        >Feedback</a
      >
      <a
        href="about.html"
        class="text-gray-300 hover:text-emerald-400 font-medium transition"
        >About</a
      >
    </div>
  </div>
</nav>

  <div class="px-4 sm:px-6 md:px-8 pt-4 sm:pt-6 md:pt-8">
  <div class="max-w-7xl mx-auto">
        <!-- Main Content Grid -->
  <main class="grid grid-cols-1 md:grid-cols-5 gap-6 items-start">

            <!-- Left Column -->
            <div id="left-col" class="md:col-span-2 flex flex-col gap-6">
                
                <!-- Component: Upload Data -->
                <div class="component bg-gray-900 border border-gray-700 rounded-xl">
                    <div class="component-header flex justify-between items-center p-4 cursor-pointer bg-gray-800/50 rounded-t-xl">
                        <h2 class="text-lg font-semibold text-emerald-400">1. Upload Data</h2>
                        <svg class="chevron-icon w-6 h-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </div>
                    <div class="component-content">
                        <p class="text-sm text-gray-400 mb-4">Upload a file to begin.</p>
                        <div id="upload-dropzone" class="bg-gray-800 border-2 border-dashed border-gray-600 rounded-lg p-6 text-center cursor-pointer hover:border-emerald-400 transition-colors">
                            <svg class="mx-auto h-12 w-12 text-gray-500" stroke="currentColor" fill="none" viewBox="0 0 48 48" aria-hidden="true"><path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                            <p class="mt-2 text-sm text-gray-400"><span class="font-medium text-emerald-400">Click to upload</span> or drag and drop</p>
                            <p class="text-xs text-gray-500">Supports CSV, TSV, JSON and XLS </p>
                            <input id="data-file" type="file" accept=".csv,.tsv,.json,.txt,.xls" class="hidden" />
                            <p id="upload-filename" class="text-xs text-gray-400 mt-2"></p>
                        </div>
                    </div>
                </div>

                <!-- Component: Chart Settings -->
                <div class="component bg-gray-900 border border-gray-700 rounded-xl">
                    <div class="component-header flex justify-between items-center p-4 cursor-pointer bg-gray-800/50 rounded-t-xl">
                        <h2 class="text-lg font-semibold text-emerald-400">2. Chart Settings</h2>
                        <svg class="chevron-icon w-6 h-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </div>
                    <div class="component-content flex flex-col gap-6">
                        <div>
                            <label class="block text-sm font-medium text-gray-300 mb-2">Select Library</label>
                            <div id="library-selector" class="flex space-x-1 bg-gray-800 p-1 rounded-md">
                                <button class="library-btn flex-1 px-3 py-1 text-sm rounded-md active" data-lang="JavaScript">JavaScript (Plotly)</button>
                                <button class="library-btn flex-1 px-3 py-1 text-sm rounded-md text-gray-400 hover:bg-gray-700" data-lang="Python">Python (Seaborn)</button>
                                <button class="library-btn flex-1 px-3 py-1 text-sm rounded-md text-gray-400 hover:bg-gray-700" data-lang="R">R (ggplot2)</button>
                            </div>
                        </div>
            <div class="flex flex-wrap gap-4">
              <div class="sm:col-span-2 flex items-center gap-3 text-gray-400 text-sm w-full"><div class="flex-1 h-px bg-gray-700"></div><div class="whitespace-nowrap">Data</div><div class="flex-1 h-px bg-gray-700"></div></div>
                            <!-- Row 1: X and Y axis selectors -->
                            <div class="flex-grow w-full sm:w-auto">
                                <label for="x-axis" class="block text-sm font-medium text-gray-300 mb-1">X-Axis Data</label>
                                <select id="x-axis" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                                    <option value="" selected>Select Column</option>
                                </select>
                                <!-- New: Data type for X axis (hidden until column selected) -->
                                <div id="x-axis-type-wrap" class="hidden">
                                    <label for="x-axis-type" class="block text-sm font-medium text-gray-300 mt-3 mb-1">Data Type of X</label>
                                    <select id="x-axis-type" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                                        <option value="" disabled selected>Select Data Type</option>
                                        <option value="continuous">Continuous</option>
                                        <option value="discrete">Discrete</option>
                                    </select>
                                </div>
                            </div>
                            <div class="flex-grow w-full sm:w-auto">
                                <label for="y-axis" class="block text-sm font-medium text-gray-300 mb-1">Y-Axis Data</label>
                                <select id="y-axis" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                                    <option value="" selected>Select Column</option>
                                </select>
                                <!-- New: Data type for Y axis (hidden until column selected) -->
                                <div id="y-axis-type-wrap" class="hidden">
                                    <label for="y-axis-type" class="block text-sm font-medium text-gray-300 mt-3 mb-1">Data Type of Y</label>
                                    <select id="y-axis-type" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                                        <option value="" disabled selected>Select Data Type</option>
                                        <option value="continuous">Continuous</option>
                                        <option value="discrete">Discrete</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Row 2: Chart type and color palette -->
                            <div class="sm:col-span-2 flex items-center gap-3 text-gray-400 text-sm w-full"><div class="flex-1 h-px bg-gray-700"></div><div class="whitespace-nowrap">Display</div><div class="flex-1 h-px bg-gray-700"></div></div>
                            <div class="flex-grow w-full sm:w-auto">
                                <label for="chart-type" class="block text-sm font-medium text-gray-300 mb-1">Chart Type</label>
                                <select id="chart-type" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                                  <option value="" selected>Select Chart Type</option>
                                  <option value="scatter">Scatter Plot</option>
                                  <option value="smooth">Scatter Plot (With Trend Line)</option>
                                  <option value="line">Line Plot</option>
                                  <option value="bar">Bar chart</option>
                                  <option value="box">Box Plot</option>
                                  <option value="violin">Violin Plot</option>
                                  <option value="strip">Dot Plot</option>
                                  <option value="jitter">Jitter Plot</option>
                                </select>
                                <!-- Gradient options moved to the left column below Chart Type -->
                                <div id="gradient-options" class="mt-3 hidden">
                                  <label for="gradient-select" class="block text-sm font-medium text-gray-300 mb-1">Select Gradient</label>
                                  <div>
                                    <select id="gradient-select" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                                      <option value="" selected>Select Gradient</option>
                                      <option value="grayscale">Grayscale</option>
                                      <option value="red">Red</option>
                                      <option value="green">Green</option>
                                      <option value="blue">Blue</option>
                                      <option value="orange">Orange</option>
                                      <option value="green-blue">Green -> Blue</option>
                                      <option value="yellow-green">Yellow -> Green</option>
                                      <option value="orange-red">Orange -> Red</option>
                                      <option value="red-purple">Red -> Purple</option>
                                    </select>
                                  </div>
                                </div>
                            </div>
                            <div class="flex-grow w-full sm:w-auto">
                                <label for="color-palette" class="block text-sm font-medium text-gray-300 mb-1">Color Palette</label>
                                <select id="color-palette" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                                  <option value="" selected>Select Color Palette</option>
                                  <option value="Vega Chart">Vega Chart</option>
                                  <option value="Default">Rainbow</option>
                                  <option value="Pastel">Pastel</option>
                                  <option value="ColorBlind">ColorBlind</option>
                                  <option value="Gradient">Gradient</option>
                                </select>
                                <!-- Invert Gradient moved to right column; appears when a gradient is selected -->
                                <div id="gradient-invert-wrap" class="mt-[36px] hidden flex items-center gap-2">
                                  <span class="text-sm font-medium text-gray-300 whitespace-nowrap">Invert Gradient</span>
                                  <label for="gradient-invert" class="inline-flex relative items-center cursor-pointer">
                                    <input type="checkbox" id="gradient-invert" class="sr-only peer" />
                                    <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-focus:ring-4 peer-focus:ring-emerald-800 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-emerald-600"></div>
                                  </label>
                                </div>
                            </div>
                            <!-- Row 3: Grouping variable (series) -->
                            <div class="sm:col-span-2 flex items-center gap-3 text-gray-400 text-sm w-full"><div class="flex-1 h-px bg-gray-700"></div><div class="whitespace-nowrap">Grouping</div><div class="flex-1 h-px bg-gray-700"></div></div>
                            <div class="col-span-2 sm:col-span-2 w-full">
                              <div id="group-by-row" class="grid grid-cols-1 sm:grid-cols-2 gap-4 items-start">
                                <div id="group-by-cell" class="sm:col-span-2">
                                  <div id="group-by-select-wrap">
                                    <label for="group-by" class="block text-sm font-medium text-gray-300 mb-1">Group By</label>
                                    <select id="group-by" class="w-full max-w-none bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                                      <option value="" selected>None</option>
                                    </select>
                                    <p class="mt-1 text-xs text-gray-400">Split data into series by this column. Works even if the legend is hidden.</p>
                                  </div>
                                  <div id="histogram-bin-wrap" class="hidden">
                                    <label for="histogram-bin-count" class="block text-sm font-medium text-gray-300 mb-1">Bin Count</label>
                                    <div class="relative">
                                      <input id="histogram-bin-count" type="number" min="1" step="1" value="30" class="custom-number w-full max-w-none bg-gray-800 border border-gray-600 rounded-md p-2 pr-12 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500" />
                                      <div class="absolute inset-y-0 right-0 w-10 flex flex-col">
                                        <button id="histogram-bin-up" type="button" class="flex-1 bg-gray-700 hover:bg-gray-600 border-l border-b border-gray-600 rounded-tr-md text-gray-300 flex items-center justify-center" tabindex="-1" aria-label="Increase bin count">
                                          <svg class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M6.3 11.7a1 1 0 0 1 0-1.4l3-3a1 1 0 0 1 1.4 0l3 3a1 1 0 1 1-1.4 1.4L10 9.41l-2.3 2.3a1 1 0 0 1-1.4 0z"/></svg>
                                        </button>
                                        <button id="histogram-bin-down" type="button" class="flex-1 bg-gray-700 hover:bg-gray-600 border-l border-gray-600 rounded-br-md text-gray-300 flex items-center justify-center" tabindex="-1" aria-label="Decrease bin count">
                                          <svg class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M13.7 8.3a1 1 0 0 1 0 1.4l-3 3a1 1 0 0 1-1.4 0l-3-3A1 1 0 1 1 6.7 8.3L10 11.59l2.3-2.3a1 1 0 0 1 1.4 0z"/></svg>
                                        </button>
                                      </div>
                                    </div>
                                  </div>
                                </div>
                                <div id="group-by-bins-wrap" class="hidden">
                                  <label for="group-by-bins" class="block text-sm font-medium text-gray-300 mb-1">Number of bins</label>
                                  <div class="relative">
                                    <input id="group-by-bins" type="number" min="1" value="5" class="custom-number w-full max-w-none bg-gray-800 border border-gray-600 rounded-md p-2 pr-12 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500" />
                                    <div class="absolute inset-y-0 right-0 w-10 flex flex-col">
                                      <button id="bins-step-up" type="button" class="flex-1 bg-gray-700 hover:bg-gray-600 border-l border-b border-gray-600 rounded-tr-md text-gray-300 flex items-center justify-center" tabindex="-1" aria-label="Increase bins">
                                        <svg class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M6.3 11.7a1 1 0 0 1 0-1.4l3-3a1 1 0 0 1 1.4 0l3 3a1 1 0 1 1-1.4 1.4L10 9.41l-2.3 2.3a1 1 0 0 1-1.4 0z"/></svg>
                                      </button>
                                      <button id="bins-step-down" type="button" class="flex-1 bg-gray-700 hover:bg-gray-600 border-l border-gray-600 rounded-br-md text-gray-300 flex items-center justify-center" tabindex="-1" aria-label="Decrease bins">
                                        <svg class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M13.7 8.3a1 1 0 0 1 0 1.4l-3 3a1 1 0 0 1-1.4 0l-3-3A1 1 0 1 1 6.7 8.3L10 11.59l2.3-2.3a1 1 0 0 1 1.4 0z"/></svg>
                                      </button>
                                    </div>
                                  </div>
                                  <p id="bin-size-info" class="mt-1 text-xs text-gray-400">Bin size: —</p>
                                </div>
                                <div id="group-by-groups-wrap" class="hidden">
                                  <label class="block text-sm font-medium text-gray-300 mb-1">Number of groups</label>
                                  <input id="group-by-groups" type="text" disabled aria-readonly="true" tabindex="-1" class="w-full bg-gray-800/60 border border-gray-700 rounded-md p-2 text-gray-300 cursor-not-allowed select-none" value="0" />
                                  <p class="mt-1 text-xs text-gray-400">Calculated from unique values in the selected column.</p>
                                </div>
                              </div>
                            </div>
                        </div>
                    </div>
                </div>

                 <!-- Component: Chart Labels -->
          <div class="component bg-gray-900 border border-gray-700 rounded-xl">
            <div
              class="component-header flex justify-between items-center p-4 cursor-pointer bg-gray-800/50 rounded-t-xl"
            >
              <h2 class="text-lg font-semibold text-emerald-400">
                3. Chart Labels
              </h2>
              <svg
                class="chevron-icon w-6 h-6 text-gray-400"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M19 9l-7 7-7-7"
                ></path>
              </svg>
            </div>
            <div class="component-content flex flex-col gap-6">
              <div>
                <label for="chart-title" class="block text-sm font-medium text-gray-300 mb-1">Chart Title</label>
                <input
                  id="chart-title"
                  type="text"
                  class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500"
                  placeholder="Lunar Capture Report"
                />
              </div>
              <div>
                <label for="chart-subtitle" class="block text-sm font-medium text-gray-300 mb-1">Chart Subtitle</label>
                <input
                  id="chart-subtitle"
                  type="text"
                  class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500"
                  placeholder="Documented Alien Encounters"
                />
              </div>
              <div>
                <label for="x-axis-label" class="block text-sm font-medium text-gray-300 mb-1">X-Axis Label</label>
                <input
                  id="x-axis-label"
                  type="text"
                  class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500"
                  placeholder="Moon Base ID"
                />
              </div>
              <div>
                <label for="y-axis-label" class="block text-sm font-medium text-gray-300 mb-1">Y-Axis Label</label>
                <input
                  id="y-axis-label"
                  type="text"
                  class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500"
                  placeholder="Alien Count"
                />
              </div>
              <div>
                <label for="source-text" class="block text-sm font-medium text-gray-300 mb-1">Source Text (e.g., Source: U.S. Census Bureau)</label>
                <input
                  id="source-text"
                  type="text"
                  class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500"
                  placeholder="Vega Chart Data"
                />
              </div>
            </div>
          </div>

          <!-- Component: Chart Legend -->
          <div id="legend-component" class="component bg-gray-900 border border-gray-700 rounded-xl">
            <div
              class="component-header flex justify-between items-center p-4 cursor-pointer bg-gray-800/50 rounded-t-xl"
            >
              <h2 class="text-lg font-semibold text-emerald-400">
                4. Chart Legend
              </h2>
              <svg
                class="chevron-icon w-6 h-6 text-gray-400"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M19 9l-7 7-7-7"
                ></path>
              </svg>
            </div>
            <div class="component-content flex flex-col gap-4">
              <div class="flex items-center justify-between">
                <label
                  for="show-legend"
                  class="text-sm font-medium text-gray-300"
                  >Show Legend</label
                >
                <label
                  for="show-legend"
                  class="inline-flex relative items-center cursor-pointer"
                >
                  <input
                    type="checkbox"
                    value=""
                    id="show-legend"
                    class="sr-only peer"
                    checked
                  />
                  <div
                    class="w-11 h-6 bg-gray-600 rounded-full peer peer-focus:ring-4 peer-focus:ring-emerald-800 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-emerald-600"
                  ></div>
                </label>
              </div>
              <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <div>
                  <label for="legend-title" class="block text-sm font-medium text-gray-300 mb-1">Legend Title</label>
                  <input id="legend-title" type="text" placeholder="Legend Title" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500" />
                </div>
                <div class="flex items-center mt-5">
                  <div class="flex items-center justify-between w-full">
                    <label for="legend-border" class="text-sm font-medium text-gray-300">Legend Border</label>
                    <label for="legend-border" class="inline-flex relative items-center cursor-pointer">
                      <input type="checkbox" id="legend-border" class="sr-only peer" />
                      <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-focus:ring-4 peer-focus:ring-emerald-800 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-emerald-600"></div>
                    </label>
                  </div>
                </div>
              </div>
              <div class="flex flex-col sm:flex-row gap-4">
                <div class="sm:w-1/2">
                  <label for="legend-position" class="block text-sm font-medium text-gray-300 mb-1">Position</label>
                  <select id="legend-position" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                    <option>Top Right</option>
                    <option>Top Left</option>
                    <option>Right</option>
                    <option>Left</option>
                    <option>Outside Chart</option>
                  </select>
                </div>
                <div class="sm:flex-1">
                  <label for="legend-order" class="block text-sm font-medium text-gray-300 mb-1">Legend Order</label>
                  <select id="legend-order" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                    <option>Normal</option>
                    <option>Reversed</option>
                    <option>Alphabetical</option>
                  </select>
                </div>
              </div>
            </div>
          </div>

          
        </div>

  <!-- Right Column -->
  <div id="right-col" class="md:col-span-3 flex flex-col gap-6">
          <!-- Component: Chart Output -->
          <div class="component bg-gray-900 border border-gray-700 rounded-xl">
            <div
              class="component-header flex justify-between items-center p-4 cursor-pointer bg-gray-800/50 rounded-t-xl"
            >
              <h2 class="text-lg font-semibold text-blue-400">Chart Output</h2>
              <div class="flex items-center space-x-2">
                <button id="chart-copy-btn" class="action-btn !py-1 !px-2 opacity-50 cursor-not-allowed" title="Copy chart image" disabled>
                  <svg
                    class="w-4 h-4"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
                    ></path>
                  </svg>
                  <span class="text-xs">Copy</span>
                </button>
                <button id="chart-download-btn" class="action-btn !py-1 !px-2 opacity-50 cursor-not-allowed" title="Download chart image" disabled>
                  <svg
                    class="w-4 h-4"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"
                    ></path>
                  </svg>
                  <span class="text-xs">Download</span>
                </button>
                <svg
                  class="chevron-icon w-6 h-6 text-gray-400 ml-2"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M19 9l-7 7-7-7"
                  ></path>
                </svg>
              </div>
            </div>
            <div class="component-content">
              <div class="output-container bg-gray-800 rounded-lg flex items-center justify-center p-4 relative">
                <!-- Default placeholder -->
                <div id="chart-placeholder" class="absolute inset-0 pointer-events-none">
                  <!-- Centered icon by default -->
                  <div id="chart-placeholder-center" class="absolute inset-0 flex items-center justify-center">
                    <!-- Chart-style placeholder icon with rounded frame -->
                    <svg class="w-36 h-36 text-gray-500" viewBox="0 0 80 64" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                      <!-- Outer rounded rectangle -->
                      <rect x="2" y="2" width="76" height="60" rx="8" ry="8" stroke-width="3"></rect>
                      <!-- Bars (5 total, centered) -->
                      <rect x="8"  y="36" width="8" height="16" rx="2" stroke-width="2.4"></rect>
                      <rect x="22" y="28" width="8" height="24" rx="2" stroke-width="2.4"></rect>
                      <rect x="36" y="32" width="8" height="20" rx="2" stroke-width="2.4"></rect>
                      <rect x="50" y="20" width="8" height="32" rx="2" stroke-width="2.4"></rect>
                      <rect x="64" y="24" width="8" height="28" rx="2" stroke-width="2.4"></rect>
                      <!-- Line with points (raised slightly) -->
                      <path d="M12 28 L26 20 L40 24 L54 12 L68 16" stroke-width="2.4"></path>
                      <circle cx="12" cy="28" r="3" stroke-width="2.64" fill="currentColor"></circle>
                      <circle cx="26" cy="20" r="3" stroke-width="2.64" fill="currentColor"></circle>
                      <circle cx="40" cy="24" r="3" stroke-width="2.64" fill="currentColor"></circle>
                      <circle cx="54" cy="12" r="3" stroke-width="2.64" fill="currentColor"></circle>
                      <circle cx="68" cy="16" r="3" stroke-width="2.64" fill="currentColor"></circle>
                    </svg>
                  </div>
                  <!-- Bottom notice -->
                  <p class="absolute bottom-3 left-1/2 -translate-x-1/2 text-gray-400 text-sm">Your chart will appear here</p>
                </div>
                <div id="chartCanvas" class="w-full h-full"></div>
              </div>
            </div>
          </div>

          <!-- Generate Button between outputs -->
          <div class="mt-2">
            <button id="generate-chart-btn" class="w-full bg-emerald-600 hover:bg-emerald-500 text-white font-semibold py-3 px-4 rounded-lg shadow focus:outline-none focus:ring-2 focus:ring-emerald-500">
              Generate Chart
            </button>
          </div>

          <!-- Component: Code Output -->
          <div
            id="code-output-component"
            class="component bg-gray-900 border border-gray-700 rounded-xl"
          >
            <div
              class="component-header flex justify-between items-center p-4 cursor-pointer bg-gray-800/50 rounded-t-xl"
            >
              <h2 id="code-output-title" class="text-lg font-semibold text-blue-400 flex items-center gap-2">
                <span id="code-output-title-text" class="align-middle">Python Code</span>
                <button id="code-reset-btn" class="action-btn !py-0.5 !px-2 hidden" title="Reset code to builder">
                  <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <polyline points="1 4 1 10 7 10" />
                    <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10" />
                  </svg>
                  <span class="sr-only">Reset</span>
                </button>
              </h2>
              <div class="flex items-center space-x-2">
                <button id="code-copy-btn" class="action-btn !p-2" title="Copy code">
                  <svg
                    class="w-4 h-4"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
                    ></path>
                  </svg>
                </button>
                <button id="code-download-btn" class="action-btn !p-2" title="Download code">
                  <svg
                    class="w-4 h-4"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"
                    ></path>
                  </svg>
                </button>
                <!-- Run button removed; Generate button triggers chart rendering -->
                <svg
                  class="chevron-icon w-6 h-6 text-gray-400 ml-2"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M19 9l-7 7-7-7"
                  ></path>
                </svg>
              </div>
            </div>
            <div class="component-content">
              <p class="text-sm text-gray-400 mb-2">View the code behind your graph</p>
              <!-- Custom Code Search Bar (hidden by default, toggled with Ctrl/Cmd+F) -->
              <div id="code-search-bar" class="mb-2 flex items-center gap-2 hidden">
                <input id="code-search-input" type="text" placeholder="Search code..." class="flex-1 rounded-md px-3 py-1.5 text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500" />
                <button id="code-search-prev" class="action-btn !py-1 !px-2" title="Previous match">
                  <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M15 18l-6-6 6-6"/></svg>
                </button>
                <button id="code-search-next" class="action-btn !py-1 !px-2" title="Next match">
                  <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M9 18l6-6-6-6"/></svg>
                </button>
                <span id="code-search-count" class="text-xs text-gray-400 w-20 text-right">0 / 0</span>
                <button id="code-search-close" class="action-btn !py-1 !px-2" title="Close search">
                  <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M18 6L6 18M6 6l12 12"/></svg>
                </button>
              </div>
              <!-- Removed large black background and fixed aspect ratio -->
              <div id="code-output-container" class="rounded-lg font-mono text-sm overflow-auto"></div>
            </div>
          </div>
          
          <!-- Component: Advanced (Optional) -->
          <div id="advanced-component" class="component bg-gray-900 border border-gray-700 rounded-xl">
            <div class="component-header flex justify-between items-center p-4 cursor-pointer bg-gray-800/50 rounded-t-xl">
              <h2 class="text-lg font-semibold text-blue-400">Additional Settings</h2>
              <svg class="chevron-icon w-6 h-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </div>
            <div id="advanced-content" class="component-content flex flex-col gap-6">
              <div class="flex items-center justify-between">
                <label for="adv-trend-toggle" id="adv-trend-label" class="text-sm font-medium text-gray-300">Include error bars</label>
                <label for="adv-trend-toggle" class="inline-flex relative items-center cursor-pointer">
                  <input type="checkbox" id="adv-trend-toggle" class="sr-only peer" />
                  <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-focus:ring-4 peer-focus:ring-emerald-800 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-emerald-600"></div>
                </label>
              </div>
              <!-- Grid Lines Toggle -->
              <div class="flex items-center justify-between">
                <label for="adv-grid-toggle" id="adv-grid-label" class="text-sm font-medium text-gray-300">Show grid lines</label>
                <label for="adv-grid-toggle" class="inline-flex relative items-center cursor-pointer">
                  <input type="checkbox" id="adv-grid-toggle" class="sr-only peer" checked />
                  <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-focus:ring-4 peer-focus:ring-emerald-800 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-emerald-600"></div>
                </label>
              </div>

              <div class="flex items-center justify-between">
                <span id="adv-orientation-label" class="text-sm font-medium text-gray-300">Orientation</span>
                <div class="inline-flex rounded-md overflow-hidden border border-gray-600">
                  <input type="radio" id="adv-orient-vertical" name="adv-orientation" value="vertical" class="sr-only" checked>
                  <label for="adv-orient-vertical" class="px-3 py-1 cursor-pointer bg-emerald-600 text-white">Vertical</label>
                  <input type="radio" id="adv-orient-horizontal" name="adv-orientation" value="horizontal" class="sr-only">
                  <label for="adv-orient-horizontal" class="px-3 py-1 cursor-pointer bg-gray-700 text-gray-300 hover:bg-gray-600">Horizontal</label>
                </div>
              </div>

              <!-- Image Background Color (figure/PNG background) -->
              <div>
                <label for="adv-image-bg" class="block text-sm font-medium text-gray-300 mb-1">Image Background Color</label>
                <select id="adv-image-bg" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                  <option value="default" selected>Dark</option>
                  <option value="transparent">Transparent</option>
                  <option value="blue">Blue</option>
                  <option value="white">White</option>
                </select>
              </div>

              <!-- Chart Background Color (plot area) -->
              <div>
                <label for="adv-chart-bg" class="block text-sm font-medium text-gray-300 mb-1">Chart Background Color</label>
                <select id="adv-chart-bg" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                  <option value="default" selected>Dark</option>
                  <option value="transparent">Transparent</option>
                  <option value="white">White</option>
                  <option value="blue">Blue</option>
                  <option value="green">Green</option>
                  <option value="yellow">Yellow</option>
                  <option value="orange">Orange</option>
                  <option value="purple">Purple</option>
                  <option value="teal">Teal</option>
                </select>
              </div>

              <!-- Typography Options -->
              <div>
                <label for="adv-text-style" class="block text-sm font-medium text-gray-300 mb-1">Text Options</label>
                <select id="adv-text-style" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                  <option value="normal" selected>Normal</option>
                  <option value="bold">Bold</option>
                  <option value="italic">Italic</option>
                  <option value="bold-italic">Bold Italic</option>
                </select>
              </div>
            </div>
          </div>

        </div>
      </main>
    </div>
    </div>

    <!-- Load Plotly BEFORE AMD loader so it attaches to window.Plotly -->
    <script src="https://cdn.plot.ly/plotly-2.26.1.min.js"></script>
    <!-- Monaco Editor loader (VS Code-like editor) -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs/loader.js"></script>
    
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // --- Aspect ratio fallback for environments that don't support aspect-ratio media queries ---
        function updateAspectClass() {
          try {
            const narrow = (window.innerWidth / Math.max(1, window.innerHeight)) <= (6/5);
            const docEl = document.documentElement;
            const wasNarrow = docEl.classList.contains('ar-narrow');
            if (narrow !== wasNarrow) {
              docEl.classList.toggle('ar-narrow', narrow);
              // If the responsive mode changed, re-run layout sizing in the next frame
              try {
                if (typeof adjustCodeOutputHeight === 'function') {
                  requestAnimationFrame(adjustCodeOutputHeight);
                }
              } catch (_) {}
            }
          } catch(_) {}
        }
        updateAspectClass();
        // React to viewport resize
        window.addEventListener('resize', updateAspectClass);
        // React to aspect-ratio media query crossing
        try {
          const mqlNarrow = window.matchMedia('(max-aspect-ratio: 6/5)');
          if (mqlNarrow) {
            const handler = () => updateAspectClass();
            if (typeof mqlNarrow.addEventListener === 'function') {
              mqlNarrow.addEventListener('change', handler);
            } else if (typeof mqlNarrow.addListener === 'function') {
              // Legacy Safari/old browsers
              mqlNarrow.addListener(handler);
            }
          }
        } catch(_) {}


        // --- Collapsible Component Logic ---
        const componentHeaders = document.querySelectorAll(".component-header");
        componentHeaders.forEach((header) => {
          header.addEventListener("click", (e) => {
            if (e.target.closest(".action-btn")) {
              return;
            }
            const component = header.closest(".component");
            if (component) {
              component.classList.toggle("collapsed");
            }
          });
        });

        document
          .querySelectorAll(".component-header .action-btn")
          .forEach((button) => {
            button.addEventListener("click", (e) => {
              e.stopPropagation();
              console.log("Action button clicked, collapse prevented.");
            });
          });

        // --- Grayed-out style for default/placeholder selections ---
        const maybePlaceholders = [
          document.getElementById('x-axis'),
          document.getElementById('y-axis'),
          document.getElementById('chart-type'),
          document.getElementById('color-palette'),
          document.getElementById('gradient-select'),
          document.getElementById('group-by'),
          document.getElementById('adv-image-bg'),
          document.getElementById('adv-chart-bg')
        ].filter(Boolean);

        function setPlaceholderStyle(sel) {
          if (!sel) return;
          if (sel.value === "") {
            sel.classList.add('select-placeholder');
          } else {
            sel.classList.remove('select-placeholder');
          }
        }

        maybePlaceholders.forEach((sel) => {
          setPlaceholderStyle(sel);
          sel.addEventListener('change', () => setPlaceholderStyle(sel));
        });

        // Track manual edits to axis labels so auto 'Count' prefills won't lock editing or overwrite
        const axisLabelInputs = [document.getElementById('x-axis-label'), document.getElementById('y-axis-label')].filter(Boolean);
        axisLabelInputs.forEach(inp => {
          inp.addEventListener('input', () => { inp.dataset.userEdited = 'true'; });
        });

        // --- Palette/Gradient UI behavior ---
        const colorPaletteSel = document.getElementById('color-palette');
        const gradientOptions = document.getElementById('gradient-options');
        const gradientSelect = document.getElementById('gradient-select');
        const gradientInvertWrap = document.getElementById('gradient-invert-wrap');
        const gradientInvert = document.getElementById('gradient-invert');

        function updateGradientVisibility() {
          if (!colorPaletteSel) return;
          if (colorPaletteSel.value === 'Gradient') {
            gradientOptions?.classList.remove('hidden');
          } else {
            gradientOptions?.classList.add('hidden');
            if (gradientSelect) { gradientSelect.value = ''; setPlaceholderStyle(gradientSelect); }
            gradientInvertWrap?.classList.add('hidden');
            if (gradientInvert) gradientInvert.checked = false;
          }
        }

        function updateInvertVisibility() {
          if (!gradientSelect) return;
          if (gradientSelect.value) {
            gradientInvertWrap?.classList.remove('hidden');
          } else {
            gradientInvertWrap?.classList.add('hidden');
            if (gradientInvert) gradientInvert.checked = false;
          }
        }

        colorPaletteSel?.addEventListener('change', () => { updateGradientVisibility(); });
        gradientSelect?.addEventListener('change', () => { setPlaceholderStyle(gradientSelect); updateInvertVisibility(); });
        // initialize
        updateGradientVisibility();
        updateInvertVisibility();

        // --- Narrow chart types based on axis data types ---
        const xTypeSel = document.getElementById('x-axis-type');
        const yTypeSel = document.getElementById('y-axis-type');
        const chartTypeSel = document.getElementById('chart-type');

        const CHART_LABELS = {
          scatter: 'Scatter Plot',
          smooth: 'Scatter Plot (With Trend Line)',
          line: 'Line Plot',
          bar: 'Bar chart',
          box: 'Box Plot',
          violin: 'Violin Plot',
          strip: 'Dot Plot',
          jitter: 'Jitter Plot',
          pie: 'Pie Chart',
          histogram: 'Histogram',
        };

        const SINGLE_VAR_OPTION_VALUE = '__single__';
        const SINGLE_VAR_OPTION_TEXT = 'Single Variable Only';
  const TYPE_NONE_VALUE = '__none__';
  // Unified vertical anchor for source + watermark annotations.
  // Previously -0.18; moved farther below plot area to avoid overlap with tick labels
  // and legend/title text. Tests that depended on the old value searched the literal;
  // no test references were found, so a constant is used for future flexibility.
  const VC_FOOTER_ANNOT_Y = -0.28; // push further down; ensureAnnotationPadding will expand bottom margin

        // --- Title Clipping Protection -----------------------------------------
        // If the legend is hidden and a (multi-line) title is present, Plotly can
        // occasionally compute too small a top margin causing the title to clip.
        // We patch Plotly.newPlot once to enforce a minimum top margin & gently
        // nudge the title downward only in that scenario. Idempotent + defensive.
        (function preventTitleClipping(){
          try {
            if (!window.Plotly || window.Plotly.__vegachartPatchedTitleMarginV2) return;
            const ORIGINAL = window.Plotly.newPlot;
            window.Plotly.newPlot = function(target, data, layout = {}, config, ...rest) {
              try {
                const legendCheckbox = document.getElementById('show-legend');
                const legendEnabledUI = legendCheckbox ? legendCheckbox.checked : true;
                const legendEnabledLayout = (layout.showlegend !== undefined) ? layout.showlegend : legendEnabledUI;

                const titleObj = layout.title;
                const hasTitle = !!(titleObj && typeof titleObj.text === 'string' && titleObj.text.trim());
                const lineBreakRegex = /(<br>|\n)/i;
                const hasSubtitle = hasTitle && lineBreakRegex.test(titleObj.text);

                if (hasTitle && !legendEnabledLayout) {
                  layout.margin = layout.margin || {};
                  // Dynamic required top margin based on number of lines & font size
                  const lines = titleObj.text.split(lineBreakRegex).filter(s => s && !lineBreakRegex.test(s)).length || 1;
                  const fontSize = (titleObj.font && Number.isFinite(titleObj.font.size)) ? titleObj.font.size : 16;
                  const dynamicNeeded = Math.round(lines * fontSize * 1.25 + 16); // padding
                  const existing = Number.isFinite(layout.margin.t) ? layout.margin.t : 0;

                  // If previous logic left an oversized margin, shrink it; else ensure minimum
                  if (!existing || existing < dynamicNeeded) {
                    layout.margin.t = dynamicNeeded; // ensure enough for text (prevents clipping)
                  } else if (existing > dynamicNeeded * 1.6) {
                    layout.margin.t = Math.round(dynamicNeeded * 1.1); // reduce excessive blank gap
                  }

                  // Move title lower toward plot area to consume otherwise blank top space.
                  // Choose y based on presence of subtitle (two+ lines sit a bit lower).
                  if (titleObj) {
                    const targetY = hasSubtitle ? 0.94 : 0.955; // slightly inside chart area
                    if (titleObj.y === undefined || Math.abs(titleObj.y - targetY) > 0.002) {
                      titleObj.y = targetY;
                    }
                  }
                }
              } catch(_){ /* silent */ }
              return ORIGINAL.apply(this, [target, data, layout, config, ...rest]);
            };
            window.Plotly.__vegachartPatchedTitleMarginV2 = true;
          } catch(_) { /* ignore */ }
        })();
        // ------------------------------------------------------------------------

        function ensureSingleVarOption(sel) {
          if (!sel) return;
          const opts = Array.from(sel.options);
          let opt = opts.find(o => o.value === SINGLE_VAR_OPTION_VALUE);
          if (!opt) {
            opt = document.createElement('option');
            opt.value = SINGLE_VAR_OPTION_VALUE;
            opt.textContent = SINGLE_VAR_OPTION_TEXT;
          }
          // Unhide/enable if previously hidden
          opt.hidden = false;
          opt.disabled = false;
          // Find placeholder index (first empty value) and insert Single Var after it
          const placeholderIdx = opts.findIndex(o => o.value === '');
          const insertIdx = placeholderIdx >= 0 ? placeholderIdx + 1 : 0;
          // If option already exists but not at correct index, move it
          const currentIdx = Array.from(sel.options).findIndex(o => o.value === SINGLE_VAR_OPTION_VALUE);
          if (currentIdx === -1) {
            sel.add(opt, sel.options[insertIdx] || null);
          } else if (currentIdx !== insertIdx) {
            sel.remove(currentIdx);
            sel.add(opt, sel.options[insertIdx] || null);
          }
        }

        function removeSingleVarOption(sel) {
          if (!sel) return;
          const opt = Array.from(sel.options).find(o => o.value === SINGLE_VAR_OPTION_VALUE);
          if (opt) {
            // Hide/disable but do not remove or clear current selection
            opt.hidden = true;
            opt.disabled = true;
          }
        }

        // Control when the Single Variable Only option is visible in the axis dropdowns
        function updateSingleVarOptionVisibility() {
          const xSel = document.getElementById('x-axis');
          const ySel = document.getElementById('y-axis');
          if (!xSel || !ySel) return;
          const xVal = xSel.value || '';
          const yVal = ySel.value || '';
          const xReal = !!xVal && xVal !== SINGLE_VAR_OPTION_VALUE;
          const yReal = !!yVal && yVal !== SINGLE_VAR_OPTION_VALUE;
          const xIsSingle = xVal === SINGLE_VAR_OPTION_VALUE;
          const yIsSingle = yVal === SINGLE_VAR_OPTION_VALUE;

          // Case A: If axis 1 (x) has a column selected, axis 2 (y) should show SVO
          // Case B: If axis 2 (y) has a column selected, axis 1 (x) should show SVO
          // Case C: If both axes have a column selected and SVO is not selected on either, both should show SVO
          // Otherwise: hide SVO from both dropdowns (keep selection intact if already selected)

          // Start by hiding on both (safe default)
          removeSingleVarOption(xSel);
          removeSingleVarOption(ySel);

          if (xReal && !yReal) {
            // Show on Y only
            ensureSingleVarOption(ySel);
          } else if (yReal && !xReal) {
            // Show on X only
            ensureSingleVarOption(xSel);
          } else if (xReal && yReal && !xIsSingle && !yIsSingle) {
            // Show on both when both real columns are selected
            ensureSingleVarOption(xSel);
            ensureSingleVarOption(ySel);
          }
        }

        function updateAxisTypeNoneState(axis) {
          const wrap = document.getElementById(`${axis}-axis-type-wrap`);
          const sel = document.getElementById(`${axis}-axis-type`);
          const axisSel = document.getElementById(`${axis}-axis`);
          if (!wrap || !sel || !axisSel) return;
          // If axis is in single-variable-only state, show 'None' type (unselectable)
          if (axisSel.value === SINGLE_VAR_OPTION_VALUE) {
            // Hide the 'Single Variable Only' option in this dropdown while active
            removeSingleVarOption(axisSel);
            // Keep the type UI hidden from users
            wrap.classList.add('hidden');
            // Ensure a 'None' option exists and select it
            let noneOpt = Array.from(sel.options).find(o => o.value === TYPE_NONE_VALUE);
            if (!noneOpt) {
              noneOpt = document.createElement('option');
              noneOpt.value = TYPE_NONE_VALUE;
              noneOpt.textContent = 'None';
              sel.insertBefore(noneOpt, sel.firstChild);
            }
            sel.value = TYPE_NONE_VALUE;
            sel.disabled = true;
          } else {
            // Remove the 'None' option if present and re-enable select
            const noneOpt = Array.from(sel.options).find(o => o.value === TYPE_NONE_VALUE);
            if (noneOpt) sel.remove(noneOpt.index);
            sel.disabled = false;
            // Keep the type UI hidden from users
            wrap.classList.add('hidden');
            // Visibility handled centrally
            updateSingleVarOptionVisibility();
          }
        }

        function setAxisSingleVarDefault(axis) {
          const sel = document.getElementById(`${axis}-axis`);
          if (!sel) return;
          ensureSingleVarOption(sel);
          if (!sel.value || sel.value === '') {
            sel.value = SINGLE_VAR_OPTION_VALUE;
            setPlaceholderStyle(sel);
          }
          updateAxisTypeNoneState(axis);
          updateSingleVarOptionVisibility();
        }

        function isSingleVariableMode() {
          const xSel = document.getElementById('x-axis');
          const ySel = document.getElementById('y-axis');
          const xv = xSel?.value || '';
          const yv = ySel?.value || '';
          const xChosen = !!xv && xv !== SINGLE_VAR_OPTION_VALUE;
          const yChosen = !!yv && yv !== SINGLE_VAR_OPTION_VALUE;
          const xSingle = (!!xv && yv === SINGLE_VAR_OPTION_VALUE);
          const ySingle = (!!yv && xv === SINGLE_VAR_OPTION_VALUE);
          return (xChosen && !yChosen) || (yChosen && !xChosen) || xSingle || ySingle;
        }

        function selectedSingleVarInfo() {
          const xSel = document.getElementById('x-axis');
          const ySel = document.getElementById('y-axis');
          const xv = xSel?.value || '';
          const yv = ySel?.value || '';
          const xReal = !!xv && xv !== SINGLE_VAR_OPTION_VALUE;
          const yReal = !!yv && yv !== SINGLE_VAR_OPTION_VALUE;
          if (xReal && !yReal) return { axis: 'x', col: xv };
          if (yReal && !xReal) return { axis: 'y', col: yv };
          return null;
        }

        function detectDataTypeOfColumn(col) {
          try {
            if (!col || !uploadedData) return '';
            for (let i = 0; i < uploadedData.length; i++) {
              const v = uploadedData[i][col];
              if (v !== null && v !== undefined && String(v).trim() !== '') {
                const n = toFiniteNumber(v);
                return Number.isFinite(n) ? 'continuous' : 'discrete';
              }
            }
          } catch(_) {}
          return '';
        }

        function configureChartTypesForSingleVar() {
          if (!chartTypeSel) return;
          chartTypeSel.innerHTML = '';
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.selected = true;
          placeholder.textContent = 'Select Chart Type';
          chartTypeSel.appendChild(placeholder);
          const info = selectedSingleVarInfo();
          const dtype = info ? detectDataTypeOfColumn(info.col) : '';
          if (dtype === 'discrete') {
            const pie = document.createElement('option'); pie.value = 'pie'; pie.textContent = 'Pie Chart'; chartTypeSel.appendChild(pie);
            const barc = document.createElement('option'); barc.value = 'bar'; barc.textContent = 'Bar chart'; chartTypeSel.appendChild(barc);
          } else if (dtype === 'continuous') {
            const hist = document.createElement('option'); hist.value = 'histogram'; hist.textContent = 'Histogram'; chartTypeSel.appendChild(hist);
          }
          setPlaceholderStyle(chartTypeSel);
        }

        // Helper: check if a column has duplicate non-empty values (used for box/violin eligibility)
        function hasDuplicateInColumn(colName) {
          try {
            if (!Array.isArray(uploadedData) || !colName) return false;
            const seen = new Set();
            for (let i = 0; i < uploadedData.length; i++) {
              const row = uploadedData[i] || {};
              let v = row[colName];
              if (v === null || v === undefined) continue;
              // Normalize to string and trim; skip empty
              const key = String(v).trim();
              if (!key) continue;
              if (seen.has(key)) return true;
              seen.add(key);
            }
          } catch(_) {}
          return false;
        }

        function toFiniteNumber(value) {
          try {
            if (value === null || value === undefined) return NaN;
            if (typeof value === 'number') return Number.isFinite(value) ? value : NaN;
            const str = String(value).trim();
            if (!str) return NaN;
            const num = Number(str);
            return Number.isFinite(num) ? num : NaN;
          } catch(_) { return NaN; }
        }

        // Helper: extract numeric values of a column (NaNs removed)
        function getNumericValues(colName) {
          try {
            if (!Array.isArray(uploadedData) || !uploadedData.length) return [];
            const vals = uploadedData
              .map(r => toFiniteNumber(r?.[colName]))
              .filter(v => Number.isFinite(v));
            return vals;
          } catch(_) { return []; }
        }

        // Heuristic: does a column represent a nonnegative quantity? True if:
        // - It has at least one numeric value AND
        // - All numeric values are >= 0 (ignoring NaN/empty)
        // Optionally also check name hints (mass, height, price, cost, count, etc.)
        function isNonNegativeColumn(colName) {
          try {
            if (!colName) return false;
            const vals = getNumericValues(colName);
            if (!vals.length) return false;
            const hasNeg = vals.some(v => v < 0);
            if (!hasNeg) return true;
            // If data contains negatives, still allow name-based override if the
            // column name strongly suggests nonnegative, but only when negatives are tiny noise
            const hint = String(colName).toLowerCase();
            const nameSuggestsNonNeg = /(mass|height|length|weight|price|cost|revenue|sales|amount|count|age|time|duration|distance|population|rate|score|area|volume|size)/.test(hint);
            if (!nameSuggestsNonNeg) return false;
            const minV = Math.min(...vals);
            // tolerate tiny negative epsilons (e.g., due to rounding)
            return minV > -1e-9;
          } catch(_) { return false; }
        }

        function setLegendEnabled(enabled) {
          const showLegendEl = document.getElementById('show-legend');
          const legendTitleInput = document.getElementById('legend-title');
          const legendPosSel = document.getElementById('legend-position');
          const legendOrderSel = document.getElementById('legend-order');
          const legendBorderInput = document.getElementById('legend-border');
          if (!showLegendEl) return;
          showLegendEl.checked = !!enabled;
          if (legendTitleInput) legendTitleInput.disabled = !enabled;
          if (legendPosSel) legendPosSel.disabled = !enabled;
          if (legendOrderSel) legendOrderSel.disabled = !enabled;
          if (legendBorderInput) legendBorderInput.disabled = !enabled;
        }

        function updateSingleVarUIState() {
          const info = selectedSingleVarInfo();
          const groupBySel = document.getElementById('group-by');
          const xLabelInput = document.getElementById('x-axis-label');
          const yLabelInput = document.getElementById('y-axis-label');
          const chartType = chartTypeSel?.value || '';
          const isSingle = !!info;
          const dtype = info ? detectDataTypeOfColumn(info.col) : '';
          const showLegendToggle = document.getElementById('show-legend');
          const showLegendLabels = Array.from(document.querySelectorAll('label[for="show-legend"]'));
          const legendToggleHandler = (typeof handleLegendToggle === 'function') ? handleLegendToggle : null;
          if (showLegendToggle) {
            if (isSingle) {
              if (showLegendToggle.dataset.singleLocked !== 'true') {
                showLegendToggle.dataset.prevLegendChecked = showLegendToggle.checked ? 'true' : 'false';
                showLegendToggle.checked = false;
                showLegendToggle.disabled = true;
                showLegendToggle.dataset.singleLocked = 'true';
                if (legendToggleHandler) legendToggleHandler();
              }
              showLegendLabels.forEach(label => label.classList.add('opacity-50','pointer-events-none'));
            } else {
              if (showLegendToggle.dataset.singleLocked === 'true' || showLegendToggle.disabled) {
                const prevState = showLegendToggle.dataset.prevLegendChecked;
                showLegendToggle.disabled = false;
                if (prevState !== undefined) {
                  showLegendToggle.checked = (prevState === 'true');
                }
                delete showLegendToggle.dataset.prevLegendChecked;
                delete showLegendToggle.dataset.singleLocked;
                if (legendToggleHandler) legendToggleHandler();
              }
              showLegendLabels.forEach(label => label.classList.remove('opacity-50','pointer-events-none'));
            }
          }
          updateHistogramBinUIState({ chartType, info, dtype });
          // Disable/enable Group By
          const xType = xTypeSel?.value || '';
          const yType = yTypeSel?.value || '';
          const bothContinuous = xType === 'continuous' && yType === 'continuous';
          if (groupBySel) {
            groupBySel.disabled = isSingle || bothContinuous;
            groupBySel.classList.toggle('opacity-50', isSingle || bothContinuous);
          }
          // Manage labels & legend per rules
          if (!isSingle) {
            if (xLabelInput) xLabelInput.disabled = false;
            if (yLabelInput) yLabelInput.disabled = false;
            return;
          }
          // If single-var just selected, but no chart yet, set sensible defaults once chart type chosen
          if (chartType === 'pie') {
            // Disable both axis labels
            if (xLabelInput) { xLabelInput.value = ''; xLabelInput.disabled = true; }
            if (yLabelInput) { yLabelInput.value = ''; yLabelInput.disabled = true; }
            setLegendEnabled(false);
          } else if (chartType === 'bar' && dtype === 'discrete') {
            // Count bars: label variable and Count
            if (info.axis === 'x') {
              if (xLabelInput) { xLabelInput.value = info.col; xLabelInput.disabled = false; }
              // Prefill with Count but leave editable so users can rename
              if (yLabelInput) {
                if (!yLabelInput.dataset.userEdited) yLabelInput.value = 'Count';
                yLabelInput.disabled = false;
              }
            } else {
              if (yLabelInput) { yLabelInput.value = info.col; yLabelInput.disabled = false; }
              if (xLabelInput) {
                if (!xLabelInput.dataset.userEdited) xLabelInput.value = 'Count';
                xLabelInput.disabled = false;
              }
            }
            setLegendEnabled(false);
          } else if (chartType === 'histogram' && dtype === 'continuous') {
            // Histogram: Y = Count
            if (info.axis === 'x') {
              if (xLabelInput) { xLabelInput.value = info.col; xLabelInput.disabled = false; }
              if (yLabelInput) {
                if (!yLabelInput.dataset.userEdited) yLabelInput.value = 'Count';
                yLabelInput.disabled = false;
              }
            } else {
              if (yLabelInput) { yLabelInput.value = info.col; yLabelInput.disabled = false; }
              if (xLabelInput) {
                if (!xLabelInput.dataset.userEdited) xLabelInput.value = 'Count';
                xLabelInput.disabled = false;
              }
            }
            setLegendEnabled(false);
          } else if (chartType === 'box' && dtype === 'continuous') {
            // Box plot: disable the unused label based on orientation
            const orient = document.querySelector('input[name="adv-orientation"]:checked')?.value || 'vertical';
            if (orient === 'vertical') {
              if (xLabelInput) { xLabelInput.value = ''; xLabelInput.disabled = true; }
              if (yLabelInput) { yLabelInput.value = info.col; yLabelInput.disabled = false; }
            } else {
              if (yLabelInput) { yLabelInput.value = ''; yLabelInput.disabled = true; }
              if (xLabelInput) { xLabelInput.value = info.col; xLabelInput.disabled = false; }
            }
            setLegendEnabled(false);
          }
        }

  function allowedCharts(xType, yType) {
          if (!xType || !yType) return [];
          const isDisc = (t) => t === 'discrete';
          const isCont = (t) => t === 'continuous';
          if (isDisc(xType) && isDisc(yType)) {
      return ['bar'];
          }
      if ((isDisc(xType) && isCont(yType)) || (isCont(xType) && isDisc(yType))) {
    // Allow box/violin/jitter only if the discrete variable has duplicate category values
      const xColSel = document.getElementById('x-axis');
      const yColSel = document.getElementById('y-axis');
      const discreteColName = isDisc(xType) ? (xColSel?.value || '') : (yColSel?.value || '');
      const hasDup = hasDuplicateInColumn(discreteColName);
    const base = ['bar', 'strip'];
    if (hasDup) {
      base.push('box');
      base.push('violin');
      base.push('jitter');
    }
      return base;
          }
          if (isCont(xType) && isCont(yType)) {
  // For two continuous variables, do not offer Histogram
  return ['scatter', 'smooth', 'line'];
          }
          // Fallbacks for any other combo
          return ['bar'];
        }

        function updateChartTypeOptions() {
          if (!chartTypeSel) return;
          const xT = xTypeSel?.value;
          const yT = yTypeSel?.value;
          const xSel = document.getElementById('x-axis');
          const ySel = document.getElementById('y-axis');
          const singleMode = isSingleVariableMode();
          // If neither axis is selected, show only the placeholder
          if (!singleMode && (!xSel?.value || xSel.value === '') && (!ySel?.value || ySel.value === '')) {
            chartTypeSel.innerHTML = '';
            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.selected = true;
            placeholder.textContent = 'Select Chart Type';
            chartTypeSel.appendChild(placeholder);
            setPlaceholderStyle(chartTypeSel);
            return;
          }
          if (singleMode) {
            configureChartTypesForSingleVar();
            return;
          }
          const allowed = allowedCharts(xT, yT);
          const current = chartTypeSel.value;

          // Preserve placeholder option
          chartTypeSel.innerHTML = '';
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.selected = true;
          placeholder.textContent = 'Select Chart Type';
          chartTypeSel.appendChild(placeholder);

          // Populate allowed options (only after both types selected)
          if (allowed.length) {
            allowed.forEach(val => {
              const opt = document.createElement('option');
              opt.value = val;
              opt.textContent = CHART_LABELS[val] || val;
              chartTypeSel.appendChild(opt);
            });
            // If current selection is still allowed, restore it
            if (allowed.includes(current)) {
              chartTypeSel.value = current;
            }
          }

          setPlaceholderStyle(chartTypeSel);
          updateSingleVarUIState();
        }

  xTypeSel?.addEventListener('change', () => { updateChartTypeOptions(); updateSingleVarUIState(); });
  yTypeSel?.addEventListener('change', () => { updateChartTypeOptions(); updateSingleVarUIState(); });
          // Initialize once in case defaults are pre-selected
          updateChartTypeOptions();
  // Ensure initial Single Variable Only visibility is correct
  updateSingleVarOptionVisibility();

          // --- Enable/disable Generate button based on readiness ---
          function canGenerateChartNow() {
            try {
              if (!uploadedData || !Array.isArray(uploadedData) || uploadedData.length === 0) return false;
              const chartTypeSelEl = document.getElementById('chart-type');
              const chartTypeVal = chartTypeSelEl?.value || '';
              // If in single-variable mode, require a chart type to be selected
              const info = (typeof selectedSingleVarInfo === 'function') ? selectedSingleVarInfo() : null;
              if (info) {
                // Disallow single-variable box plots
                if (chartTypeVal === 'box') return false;
                return !!chartTypeVal;
              }
              // Otherwise require both axes (not SVO) and a chart type
              const xSel = document.getElementById('x-axis');
              const ySel = document.getElementById('y-axis');
              const xVal = xSel?.value || '';
              const yVal = ySel?.value || '';
              if (!xVal || !yVal) return false;
              if (xVal === SINGLE_VAR_OPTION_VALUE || yVal === SINGLE_VAR_OPTION_VALUE) return false;
              // Additional rule: For mixed discrete/continuous, require duplicates for box/violin
              if (chartTypeVal === 'box' || chartTypeVal === 'violin') {
                const xT = xTypeSel?.value;
                const yT = yTypeSel?.value;
                const isDisc = (t) => t === 'discrete';
                const isCont = (t) => t === 'continuous';
                if ((isDisc(xT) && isCont(yT)) || (isCont(xT) && isDisc(yT))) {
                  const discreteColName = isDisc(xT) ? xVal : yVal;
                  const hasDup = hasDuplicateInColumn(discreteColName);
                  if (!hasDup) return false;
                }
              }
              return !!chartTypeVal;
            } catch(_) { return false; }
          }

          function updateGenerateButtonState() {
            const btn = document.getElementById('generate-chart-btn');
            if (!btn) return;
            const ok = canGenerateChartNow();
            // Clean up any legacy classes from older behavior
            btn.classList.remove('bg-gray-700','hover:bg-gray-700','text-gray-300','cursor-not-allowed','opacity-60');
            // Keep button clickable; only adjust visual emphasis
            btn.classList.toggle('bg-emerald-600', ok);
            btn.classList.toggle('hover:bg-emerald-500', ok);
            btn.classList.toggle('focus:ring-emerald-500', ok);

            // Muted, still-green style when not ready
            btn.classList.toggle('bg-emerald-800', !ok);
            btn.classList.toggle('hover:bg-emerald-700', !ok);
            btn.classList.toggle('opacity-70', !ok);
          }

          // Initial state
          updateGenerateButtonState();

        // --- "Group By" Interactivity ---
  const groupBySelectEl = document.getElementById('group-by');
  // Track if user manually changed Group By (so we won't auto-overwrite)
  try { if (groupBySelectEl && !groupBySelectEl.dataset.gbManual) { groupBySelectEl.dataset.gbManual = '0'; } } catch(_) {}
        const groupByCell = document.getElementById('group-by-cell');
        const groupByBinsWrap = document.getElementById('group-by-bins-wrap');
        const groupByGroupsWrap = document.getElementById('group-by-groups-wrap');
        const groupByBinsInput = document.getElementById('group-by-bins');
        const groupBySelectWrap = document.getElementById('group-by-select-wrap');
        const histogramBinWrap = document.getElementById('histogram-bin-wrap');
        const histogramBinInput = document.getElementById('histogram-bin-count');

        function updateBinSizeDisplay() {
            if (!uploadedData || !groupBySelectEl) return;
            const col = groupBySelectEl.value;
            if (!col) return;

            const values = uploadedData.map(r => parseFloat(r[col])).filter(v => !isNaN(v));
            if (values.length < 2) {
                document.getElementById('bin-size-info').textContent = 'Bin size: —';
                return;
            }

            const min = Math.min(...values);
            const max = Math.max(...values);
            const bins = parseInt(groupByBinsInput.value, 10) || 1;
            const size = (max - min) / bins;
            document.getElementById('bin-size-info').textContent = `Bin size: ≈ ${size.toPrecision(2)}`;
        }

        function updateGroupCountDisplay() {
            if (!uploadedData || !groupBySelectEl) return;
            const col = groupBySelectEl.value;
            if (!col) return;

            const uniqueValues = new Set(uploadedData.map(r => r[col]));
            document.getElementById('group-by-groups').value = uniqueValues.size;
        }

        function updateGroupByBinsVisibility() {
            if (!groupBySelectEl || !groupByCell || !groupByBinsWrap || !groupByGroupsWrap) return;
            const selectedOption = groupBySelectEl.options[groupBySelectEl.selectedIndex];
            const dataType = selectedOption ? selectedOption.dataset.type : null;

            if (dataType === 'continuous') {
                groupByBinsWrap.classList.remove('hidden');
                groupByGroupsWrap.classList.add('hidden');
                groupByCell.classList.remove('sm:col-span-2');
                groupByCell.classList.add('sm:col-span-1');
                updateBinSizeDisplay();
            } else if (dataType === 'discrete') {
                groupByBinsWrap.classList.add('hidden');
                groupByGroupsWrap.classList.remove('hidden');
                groupByCell.classList.remove('sm:col-span-2');
                groupByCell.classList.add('sm:col-span-1');
                updateGroupCountDisplay();
            } else {
                groupByBinsWrap.classList.add('hidden');
                groupByGroupsWrap.classList.add('hidden');
                groupByCell.classList.remove('sm:col-span-1');
                groupByCell.classList.add('sm:col-span-2');
            }
        }
        
        function bindBinsSteppers() {
            const upBtn = document.getElementById('bins-step-up');
            const downBtn = document.getElementById('bins-step-down');
            if (!upBtn || !downBtn || !groupByBinsInput) return;

            upBtn.addEventListener('click', () => {
                groupByBinsInput.stepUp();
                groupByBinsInput.dispatchEvent(new Event('change', { bubbles: true }));
            });
            downBtn.addEventListener('click', () => {
                groupByBinsInput.stepDown();
                groupByBinsInput.dispatchEvent(new Event('change', { bubbles: true }));
            });
            groupByBinsInput.addEventListener('change', updateBinSizeDisplay);
        }

        function computeAutoHistogramBins(values) {
            try {
                if (!Array.isArray(values) || values.length < 2) return 10;
                const sorted = values.filter(v => Number.isFinite(v)).sort((a, b) => a - b);
                if (sorted.length < 2) return 1;
                const n = sorted.length;
                const min = sorted[0];
                const max = sorted[sorted.length - 1];
                if (!Number.isFinite(min) || !Number.isFinite(max)) return 10;
                const range = max - min;
                if (!Number.isFinite(range) || range <= 0) return 1;
                const quartile = (p) => {
                    const pos = (n - 1) * p;
                    const lower = Math.floor(pos);
                    const upper = Math.min(sorted.length - 1, lower + 1);
                    const weight = pos - lower;
                    return sorted[lower] + (sorted[upper] - sorted[lower]) * weight;
                };
                const iqr = quartile(0.75) - quartile(0.25);
                if (Number.isFinite(iqr) && iqr > 0) {
                    const width = (2 * iqr) / Math.cbrt(n);
                    if (Number.isFinite(width) && width > 0) {
                        const binsFD = Math.round(range / width);
                        if (Number.isFinite(binsFD) && binsFD > 0) {
                            return Math.max(1, Math.min(100, binsFD));
                        }
                    }
                }
                const binsSqrt = Math.round(Math.sqrt(n));
                return Math.max(1, Math.min(100, binsSqrt || 1));
            } catch (_) {
                return 10;
            }
        }

        function autoSetHistogramBinCount(force = false) {
            if (!histogramBinInput) return;
            const info = (typeof selectedSingleVarInfo === 'function') ? selectedSingleVarInfo() : null;
            const colName = info ? info.col : '';
            const prevCol = histogramBinInput.dataset.histSource || '';
            const manualLocked = histogramBinInput.dataset.histManual === '1' && !force && prevCol === colName && !!colName;
            if (manualLocked) return;
            if (!info) {
                histogramBinInput.dataset.histSource = '';
                if (force) histogramBinInput.dataset.histManual = '0';
                return;
            }
            const values = getNumericValues(info.col);
            if (!values.length) {
                const fallback = '10';
                if (histogramBinInput.value !== fallback) {
                    histogramBinInput.dataset.histSkip = '1';
                    histogramBinInput.value = fallback;
                    histogramBinInput.dispatchEvent(new Event('change', { bubbles: true }));
                }
                histogramBinInput.dataset.histManual = '0';
                histogramBinInput.dataset.histSource = colName || '';
                return;
            }
            const bins = computeAutoHistogramBins(values);
            const current = parseInt(histogramBinInput.value, 10);
            if (!Number.isFinite(current) || current !== bins) {
                histogramBinInput.dataset.histSkip = '1';
                histogramBinInput.value = String(bins);
                histogramBinInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
            histogramBinInput.dataset.histManual = '0';
            histogramBinInput.dataset.histSource = colName || '';
        }

        function updateHistogramBinUIState(context = {}) {
            if (!groupBySelectWrap || !histogramBinWrap || !groupByCell) return;
            const chartType = context.chartType ?? (document.getElementById('chart-type')?.value || '');
            const info = context.info ?? ((typeof selectedSingleVarInfo === 'function') ? selectedSingleVarInfo() : null);
            const dtype = context.dtype ?? (info ? detectDataTypeOfColumn(info.col) : '');
            const forceAuto = !!context.forceAuto;
            const shouldShow = chartType === 'histogram' && info && dtype === 'continuous';
            if (shouldShow) {
                groupBySelectWrap.classList.add('hidden');
                histogramBinWrap.classList.remove('hidden');
                groupByCell.classList.remove('sm:col-span-1');
                groupByCell.classList.add('sm:col-span-2');
                if (histogramBinInput) {
                    histogramBinInput.disabled = false;
                    histogramBinInput.classList.remove('opacity-50');
                }
                autoSetHistogramBinCount(forceAuto);
            } else {
                histogramBinWrap.classList.add('hidden');
                groupBySelectWrap.classList.remove('hidden');
                if (histogramBinInput) {
                    histogramBinInput.disabled = true;
                    histogramBinInput.classList.add('opacity-50');
                }
            }
        }

        function bindHistogramBinSteppers() {
            if (!histogramBinInput) return;
            if (!histogramBinInput.dataset.histManual) histogramBinInput.dataset.histManual = '0';
            const upBtn = document.getElementById('histogram-bin-up');
            const downBtn = document.getElementById('histogram-bin-down');
            const noteManual = () => {
                histogramBinInput.dataset.histManual = '1';
                const info = (typeof selectedSingleVarInfo === 'function') ? selectedSingleVarInfo() : null;
                if (info && info.col) {
                    histogramBinInput.dataset.histSource = info.col;
                }
            };
            histogramBinInput.addEventListener('input', noteManual);
            histogramBinInput.addEventListener('change', () => {
                if (histogramBinInput.dataset.histSkip === '1') {
                    delete histogramBinInput.dataset.histSkip;
                    return;
                }
                noteManual();
            });
            if (upBtn) {
                upBtn.addEventListener('click', () => {
                    histogramBinInput.stepUp();
                    histogramBinInput.dispatchEvent(new Event('change', { bubbles: true }));
                });
            }
            if (downBtn) {
                downBtn.addEventListener('click', () => {
                    histogramBinInput.stepDown();
                    histogramBinInput.dispatchEvent(new Event('change', { bubbles: true }));
                });
            }
        }

        function readHistogramBinCount() {
            const raw = histogramBinInput ? parseInt(histogramBinInput.value, 10) : NaN;
            if (Number.isFinite(raw) && raw > 0) return raw;
            return 10;
        }


    groupBySelectEl?.addEventListener('change', updateGroupByBinsVisibility);
    // Mark manual overrides on Group By (unless change was programmatic)
    groupBySelectEl?.addEventListener('change', (e) => {
      try {
        const sel = e.currentTarget;
        if (!sel) return;
        if (sel.dataset.byAuto === '1') {
          // Clear the byAuto flag and don't mark manual for this programmatic change
          sel.dataset.byAuto = '0';
          return;
        }
        sel.dataset.gbManual = '1';
      } catch(_) {}
    });
        bindBinsSteppers();
        bindHistogramBinSteppers();
        
        // --- Advanced Section Interactivity ---
        function updateOrientationButtons() {
            const vertRadio = document.getElementById('adv-orient-vertical');
            const horizRadio = document.getElementById('adv-orient-horizontal');
            const vertLabel = document.querySelector('label[for="adv-orient-vertical"]');
            const horizLabel = document.querySelector('label[for="adv-orient-horizontal"]');

            if (!vertRadio || !horizRadio || !vertLabel || !horizLabel) return;

            function toggleClasses() {
                if (vertRadio.checked) {
                    vertLabel.classList.add('bg-emerald-600', 'text-white');
                    vertLabel.classList.remove('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600');
                    horizLabel.classList.add('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600');
                    horizLabel.classList.remove('bg-emerald-600', 'text-white');
                } else {
                    horizLabel.classList.add('bg-emerald-600', 'text-white');
                    horizLabel.classList.remove('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600');
                    vertLabel.classList.add('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600');
                    vertLabel.classList.remove('bg-emerald-600', 'text-white');
                }
            }

            vertRadio.addEventListener('change', toggleClasses);
            horizRadio.addEventListener('change', toggleClasses);
            toggleClasses(); // Initial state
        }

    function supportsErrorBars() {
      const chartTypeSel = document.getElementById('chart-type');
      const chartType = chartTypeSel?.value || '';
      const xTypeSel = document.getElementById('x-axis-type');
      const yTypeSel = document.getElementById('y-axis-type');
      const xColSel = document.getElementById('x-axis');
      const yColSel = document.getElementById('y-axis');
            const groupBySel = document.getElementById('group-by');
            // Group By no longer restricts error bar availability
            if (chartType !== 'bar') return false;
  if (!xColSel || !yColSel || !xColSel.value || !yColSel.value) return false;
  if (xColSel.value === SINGLE_VAR_OPTION_VALUE || yColSel.value === SINGLE_VAR_OPTION_VALUE) return false;
      if (!Array.isArray(uploadedData) || uploadedData.length === 0) return false;

      // Use selected types if provided; otherwise infer from data
      let xType = xTypeSel?.value || '';
      let yType = yTypeSel?.value || '';
      function detectType(col) {
        try {
          for (let i = 0; i < uploadedData.length; i++) {
            const v = uploadedData[i][col];
            if (v !== null && v !== undefined && String(v).trim() !== '') {
              const n = toFiniteNumber(v);
              return Number.isFinite(n) ? 'continuous' : 'discrete';
            }
          }
        } catch(_) {}
        return '';
      }
      if (!xType) xType = detectType(xColSel.value);
      if (!yType) yType = detectType(yColSel.value);

            const oneDiscOneCont = (xType === 'discrete' && yType === 'continuous') || (xType === 'continuous' && yType === 'discrete');
            if (oneDiscOneCont) {
        // New rule: only allow if the discrete variable has duplicate non-empty values
        const discreteColName = (xType === 'discrete') ? (xColSel?.value || '') : (yColSel?.value || '');
        if (!hasDuplicateInColumn(discreteColName)) return false;
        return true;
      }
      return false;
    }

    function updateAdvancedLabel() {
      const label = document.getElementById('adv-trend-label');
      const toggle = document.getElementById('adv-trend-toggle');
      const toggleWrap = toggle ? toggle.parentElement : null;
      if (label) label.textContent = 'Include error bars';
      const canUse = supportsErrorBars();
      if (toggle) {
        if (canUse) {
          toggle.disabled = false;
          toggleWrap && toggleWrap.classList.remove('opacity-50', 'cursor-not-allowed');
          label && label.classList.remove('opacity-50', 'text-gray-400');
        } else {
          toggle.checked = false;
          toggle.disabled = true;
          toggleWrap && toggleWrap.classList.add('opacity-50', 'cursor-not-allowed');
          label && label.classList.add('opacity-50', 'text-gray-400');
        }
      }

      // Disable grid lines for pie charts
      try {
        const gridToggle = document.getElementById('adv-grid-toggle');
        const gridLabel = document.getElementById('adv-grid-label');
        const gridWrap = gridToggle ? gridToggle.parentElement : null;
        const chartTypeSel = document.getElementById('chart-type');
        const ctype = chartTypeSel?.value || '';
        const isPie = ctype === 'pie';
        if (gridToggle) {
          if (isPie) {
            gridToggle.checked = false;
            gridToggle.disabled = true;
            gridWrap && gridWrap.classList.add('opacity-50', 'cursor-not-allowed');
            gridLabel && gridLabel.classList.add('opacity-50', 'text-gray-400');
          } else {
            gridToggle.disabled = false;
            gridWrap && gridWrap.classList.remove('opacity-50', 'cursor-not-allowed');
            gridLabel && gridLabel.classList.remove('opacity-50', 'text-gray-400');
          }
        }

        // Orientation availability: disabled only for scatter plots, line plots, and pie charts
        try {
          const disallowedOrientationTypes = ['scatter','smooth','line','pie'];
          const orientationAllowed = !disallowedOrientationTypes.includes(ctype);
          const vertRadio = document.getElementById('adv-orient-vertical');
          const horizRadio = document.getElementById('adv-orient-horizontal');
          const orientLabel = document.getElementById('adv-orientation-label');
          // Wrapper is the parent div containing the radios & labels
          const orientWrap = vertRadio ? vertRadio.parentElement : null;
          if (vertRadio && horizRadio) {
            if (orientationAllowed) {
              vertRadio.disabled = false;
              horizRadio.disabled = false;
              orientWrap && orientWrap.classList.remove('opacity-50','cursor-not-allowed','pointer-events-none');
              orientLabel && orientLabel.classList.remove('opacity-50','text-gray-400');
            } else {
              // Do not force-change the current selection; just disable interaction and dim
              vertRadio.disabled = true;
              horizRadio.disabled = true;
              orientWrap && orientWrap.classList.add('opacity-50','cursor-not-allowed','pointer-events-none');
              orientLabel && orientLabel.classList.add('opacity-50','text-gray-400');
            }
          }
        } catch(_) {}
      } catch(_) {}
    }
    
    // When chart type is box or violin, auto-set Group By to the chosen discrete axis.
    // Users can still change it; we won't auto-overwrite after a manual change unless forced.
    function autoSetGroupByForBoxViolin(force = false) {
      try {
        const chartTypeSel = document.getElementById('chart-type');
        const ctype = chartTypeSel?.value || '';
        if (ctype !== 'box' && ctype !== 'violin') return;
        const xSel = document.getElementById('x-axis');
        const ySel = document.getElementById('y-axis');
        const groupSel = document.getElementById('group-by');
        if (!xSel || !ySel || !groupSel) return;
        const xv = xSel.value;
        const yv = ySel.value;
        // Only apply when both axes are real columns (not SVO)
        if (!xv || !yv) return;
        if (xv === SINGLE_VAR_OPTION_VALUE || yv === SINGLE_VAR_OPTION_VALUE) return;
        // Respect manual override unless forced (e.g., on chart-type change)
        if (!force && groupSel.dataset.gbManual === '1') return;
        // Determine axis types (prefer explicit selection if present)
        let xType = document.getElementById('x-axis-type')?.value || '';
        let yType = document.getElementById('y-axis-type')?.value || '';
        if (!xType) xType = detectDataTypeOfColumn(xv);
        if (!yType) yType = detectDataTypeOfColumn(yv);
        let discreteCol = null;
        if (xType === 'discrete' && yType === 'continuous') discreteCol = xv;
        else if (yType === 'discrete' && xType === 'continuous') discreteCol = yv;
        else return;
        // Set only if that option exists in Group By
        const opt = Array.from(groupSel.options || []).find(o => o.value === discreteCol);
        if (!opt) return;
        if (groupSel.value !== discreteCol) {
          groupSel.dataset.byAuto = '1';
          groupSel.value = discreteCol;
          setPlaceholderStyle(groupSel);
          groupSel.dispatchEvent(new Event('change', { bubbles: true }));
          // After applying, clear manual flag so future axis changes can update unless user changes it again
          groupSel.dataset.gbManual = '0';
        }
      } catch(_) {}
    }
        
        updateOrientationButtons();
  // Axis type dropdowns are hidden; no interactive listeners needed
  document.getElementById('chart-type')?.addEventListener('change', () => { updateAdvancedLabel(); updateSingleVarUIState(); updateGenerateButtonState(); autoSetGroupByForBoxViolin(true); });
  document.getElementById('x-axis')?.addEventListener('change', () => { updateAdvancedLabel(); updateSingleVarUIState(); updateSingleVarOptionVisibility(); updateChartTypeOptions(); updateGenerateButtonState(); autoSetGroupByForBoxViolin(false); });
  document.getElementById('y-axis')?.addEventListener('change', () => { updateAdvancedLabel(); updateSingleVarUIState(); updateSingleVarOptionVisibility(); updateChartTypeOptions(); updateGenerateButtonState(); autoSetGroupByForBoxViolin(false); });
  document.getElementById('group-by')?.addEventListener('change', () => { updateAdvancedLabel(); updateSingleVarUIState(); updateGenerateButtonState(); });
  document.getElementById('adv-orient-vertical')?.addEventListener('change', updateSingleVarUIState);
  document.getElementById('adv-orient-horizontal')?.addEventListener('change', updateSingleVarUIState);
        
        // Removed auto-updating JS code preview on builder input changes

        // --- Dynamic Code Output Logic ---
        const librarySelector = document.getElementById("library-selector");
        const libraryButtons = librarySelector.querySelectorAll(".library-btn");
        const codeOutputTitle = document.getElementById("code-output-title");
        const codeOutputTitleText = document.getElementById("code-output-title-text");
        const codeOutputContainer = document.getElementById(
          "code-output-container"
        );

        // Hidden snippet: kept in code but not shown in the editor
        const HIDDEN_PLOTLY_HTML_SNIPPET = `<script src="https://cdn.plot.ly/plotly-latest.min.js"><\/script>\n\n<div id="chartCanvas" style="width: 100%; height: 480px;"></div>`;
  const HIDDEN_EXPORT_STYLE_SNIPPET = `<style>\n  body { background: #0a0a0a; color: #e5e7eb; }\n  #chartCanvas { width: 100%; height: 480px; }\n</style>`;

        const codeSnippets = {
          Python: `<pre><code class="language-python"># Python (Seaborn) code
import seaborn as sns
import matplotlib.pyplot as plt

# Apply theme
sns.set_theme(style="darkgrid")

# Sample data
data = {
    'category': ["A", "B", "C"],
    'value': [10, 20, 15]
}

# Create plot
sns.barplot(
    data=data,
    x="category", 
  y="value",
  palette="viridis",
  errorbar=None  # Disable error bars by default; enable via UI when supported
)
plt.show()
</code></pre>`,
          R: `<pre><code class="language-r"># R (ggplot2) example
# Upload a CSV or adapt this sample inline.
# Your data will be available as a data frame named df when you run it here.
# Replace the sample below with your own columns.

library(ggplot2)

data <- data.frame(
  category = c("A", "B", "C"),
  value = c(10, 20, 15)
)

ggplot(data, aes(category, value, fill = category)) +
  geom_col() +
  scale_fill_viridis_d() +
  theme_minimal()
</code></pre>`,
          JavaScript: `// JavaScript (Plotly.js)\n// Example: load a CSV file and plot\n// Update the file name/path as needed\nconst file = 'your_data.csv';\n\nasync function csvToJSON(url) {\n  const res = await fetch(url);\n  const text = await res.text();\n  const lines = text.split(/\\r?\\n/).filter(l => l.trim().length);\n  if (lines.length === 0) return [];\n  const delimiter = text.includes('\t') ? '\t' : ',';\n  const parseLine = (line) => {\n    const result = [];\n    let cur = '', inQuotes = false;\n    for (let i = 0; i < line.length; i++) {\n      const ch = line[i];\n      if (ch === '"') {\n        if (inQuotes && line[i+1] === '"') { cur += '"'; i++; }\n        else { inQuotes = !inQuotes; }\n      } else if (!inQuotes && ch === delimiter) {\n        result.push(cur); cur = '';\n      } else {\n        cur += ch;\n      }\n    }\n    result.push(cur);\n    return result;\n  };\n  const header = parseLine(lines[0]).map(h => h.trim());\n  return lines.slice(1).map(l => {\n    const cells = parseLine(l);\n    const obj = {};\n    header.forEach((h, i) => { obj[h] = cells[i]; });\n    return obj;\n  });\n}\n\n// Ensure adequate margin padding for watermark and annotations\nfunction ensureAnnotationPadding(layout, dims = {}) {\n  try {\n    if (!layout || typeof layout !== 'object') return layout;\n    const annotations = Array.isArray(layout.annotations) ? layout.annotations : [];\n    if (!annotations.length) return layout;\n    const margin = (layout.margin && typeof layout.margin === 'object') ? { ...layout.margin } : {};\n    let changed = false;\n    const usableHeight = Math.max(360, Number.isFinite(dims?.contextHeight) ? dims?.contextHeight : 0);\n    const usableWidth = Math.max(480, Number.isFinite(dims?.contextWidth) ? dims?.contextWidth : 0);\n    const fallbackMargin = { l: 64, r: 32, t: 64, b: 64 };\n    const ensureSide = (side, required) => {\n      const base = margin[side] !== undefined ? margin[side] : fallbackMargin[side];\n      const target = Math.max(base, required);\n      if (target !== base) { margin[side] = target; changed = true; }\n    };\n    for (const ann of annotations) {\n      if (!ann || ann.visible === false) continue;\n      const fontSize = typeof ann?.font?.size === 'number' ? ann.font.size : 12;\n      const pad = fontSize + 6;\n      const x = typeof ann?.x === 'number' ? ann.x : null;\n      const y = typeof ann?.y === 'number' ? ann.y : null;\n      const xref = String(ann?.xref || 'paper').toLowerCase();\n      const yref = String(ann?.yref || 'paper').toLowerCase();\n      if (yref === 'paper' && y !== null) {\n        if (y < 0) { const needed = pad + Math.round(-y * usableHeight); ensureSide('b', needed); }\n        else if (y > 1) { const needed = pad + Math.round((y - 1) * usableHeight); ensureSide('t', needed); }\n      }\n      if (xref === 'paper' && x !== null) {\n        if (x < 0) { const needed = pad + Math.round(-x * usableWidth); ensureSide('l', needed); }\n        else if (x > 1) { const needed = pad + Math.round((x - 1) * usableWidth); ensureSide('r', needed); }\n      }\n    }\n    if (changed) { layout.margin = { ...layout.margin, ...margin }; }\n    return layout;\n  } catch (_) { return layout; }\n}\n\n// Load rows from CSV (rows is an array of objects)\nconst rows = await csvToJSON(file);\n\n// Replace data/layout with your own and click Generate.\nconst data = [];\nlet layout = {\n  annotations: [{\n    text: "Vegachart.com",\n    showarrow: false,\n    x: 1,\n    y: -0.45,\n    xref: "paper",\n    yref: "paper",\n    xanchor: "right",\n    yanchor: "top",\n    font: { size: 10, color: "#9ca3af" },\n    bgcolor: "rgba(0,0,0,0)",\n    bordercolor: "rgba(0,0,0,0)"\n  }]\n};\n\n// Apply padding for annotations including watermark\nconst __target = (typeof containerId !== 'undefined') ? (typeof containerId === 'string' ? document.getElementById(containerId) : containerId) : document.getElementById('chartCanvas');\nif (!__target) { throw new Error('Chart container not found'); }\nlayout = ensureAnnotationPadding(layout, {\n  contextWidth: __target.clientWidth || 480,\n  contextHeight: __target.clientHeight || 360\n});\n\nconst config = { responsive: true, displayModeBar: false, displaylogo: false, showTips: false };\nPlotly.newPlot(__target, data, layout, config);`
        };

        let currentJSCode = codeSnippets.JavaScript;
        let autoJSCode = currentJSCode; // last builder-generated code (no edits)
        let isCodeEdited = false;       // tracks if user modified the JS editor contents
        let isPyEdited = false;         // tracks if user modified the Python editor contents
        let isREdited = false;          // tracks if user modified the R editor contents

        // Monaco Editor integration for VS Code-like highlighting
        let monacoEditor = null;
        function ensureMonaco() {
          if (window.monaco && window.monaco.editor) return Promise.resolve(window.monaco);
          if (window.__monacoLoading) return window.__monacoLoading;
          window.__monacoLoading = new Promise((resolve) => {
            // Configure AMD loader path for Monaco
            // eslint-disable-next-line no-undef
            require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs' } });
            // eslint-disable-next-line no-undef
            require(['vs/editor/editor.main'], function() { resolve(window.monaco); });
          });
          return window.__monacoLoading;
        }
        function disposeMonaco() {
          try { monacoEditor && monacoEditor.dispose(); } catch(_) {}
          monacoEditor = null;
        }

        function updateResetButtonVisibility() {
          const btn = document.getElementById('code-reset-btn');
          const selectedLang = document.querySelector('.library-btn.active')?.dataset.lang;
          if (!btn) return;
          if ((selectedLang === 'JavaScript' && isCodeEdited) ||
              (selectedLang === 'Python' && isPyEdited) ||
              (selectedLang === 'R' && isREdited)) {
            btn.classList.remove('hidden');
          } else {
            btn.classList.add('hidden');
          }
        }

  function setCodeEditorContent(text, lang = 'JavaScript') {
          const container = document.getElementById('code-output-container');
          if (!container) return;
          container.innerHTML = '';
          if (lang === 'JavaScript' || lang === 'Python' || lang === 'R') {
            // Hidden textarea for compatibility with existing logic
            const ta = document.createElement('textarea');
            ta.id = 'code-editor';
            ta.spellcheck = false;
            ta.style.display = 'none';
            ta.value = text || '';
            container.appendChild(ta);

            // Monaco host
            const host = document.createElement('div');
            host.id = 'monaco-editor';
            
            // Apply language-specific container styling
            if (lang === 'R') {
              host.className = 'w-full r-code-container overflow-hidden';
            } else if (lang === 'Python') {
              host.className = 'w-full pycharm-code-container overflow-hidden';
            } else {
              host.className = 'w-full border border-gray-700 rounded-md overflow-hidden';
            }
            
            host.style.height = '580px'; // Increased to show ~3 more lines
            host.dataset.baseHeight = '580';
            host.classList.add('code-host');
            host.classList.add('vc-editor-readonly');
            host.setAttribute('aria-readonly', 'true');
            container.appendChild(host);

            // Track edits vs auto-generated code
            if (lang === 'JavaScript') {
              isCodeEdited = !!text && text !== autoJSCode ? true : false;
            } else if (lang === 'Python') {
              isPyEdited = !!text && text !== autoPyCode ? true : false;
            } else if (lang === 'R') {
              isREdited = !!text && text !== autoRCode ? true : false;
            }
            updateResetButtonVisibility();

            ensureMonaco().then((monaco) => {
              disposeMonaco();
              const monacoLang = lang === 'JavaScript' ? 'javascript' : lang === 'Python' ? 'python' : 'r';
              
              // Define RStudio-like theme for R code
              if (lang === 'R') {
                monaco.editor.defineTheme('rstudio-dark', {
                  base: 'vs-dark',
                  inherit: true,
                  rules: [
                    { token: '', foreground: 'd4d4d4' },
                    { token: 'comment', foreground: '6a9955', fontStyle: 'italic' },
                    { token: 'keyword', foreground: '569cd6', fontStyle: 'bold' },
                    { token: 'string', foreground: 'ce9178' },
                    { token: 'number', foreground: 'b5cea8' },
                    { token: 'operator', foreground: 'c586c0' },
                    { token: 'identifier', foreground: 'd4d4d4' },
                    { token: 'type', foreground: '569cd6' },
                    { token: 'function', foreground: 'dcdcaa', fontStyle: 'bold' }
                  ],
                  colors: {
                    'editor.background': '#2b2b2b',
                    'editor.foreground': '#d4d4d4',
                    'editor.lineHighlightBackground': '#323232',
                    'editor.selectionBackground': '#264f78',
                    'editorLineNumber.foreground': '#858585',
                    'editorLineNumber.activeForeground': '#c6c6c6',
                    'editorCursor.foreground': '#d4d4d4',
                    'editor.selectionHighlightBackground': '#3a3d41'
                  }
                });
              }

              // Define PyCharm Darcula-like theme for Python code
              if (lang === 'Python') {
                monaco.editor.defineTheme('pycharm-darcula', {
                  base: 'vs-dark',
                  inherit: true,
                  rules: [
                    { token: '', foreground: 'a9b7c6' },
                    { token: 'comment', foreground: '808080', fontStyle: 'italic' },
                    { token: 'keyword', foreground: 'cc7832' },
                    { token: 'string', foreground: '6a8759' },
                    { token: 'number', foreground: '6897bb' },
                    { token: 'operator', foreground: 'a9b7c6' },
                    { token: 'type', foreground: 'bbb529' },
                    { token: 'constant', foreground: '9876aa' },
                    { token: 'delimiter', foreground: 'a9b7c6' },
                    { token: 'variable', foreground: 'a9b7c6' },
                    { token: 'function', foreground: 'ffc66d' }
                  ],
                  colors: {
                    'editor.background': '#2b2b2b',
                    'editor.foreground': '#a9b7c6',
                    'editor.lineHighlightBackground': '#323232',
                    'editorLineNumber.foreground': '#606366',
                    'editorLineNumber.activeForeground': '#a9b7c6',
                    'editor.selectionBackground': '#214283',
                    'editor.selectionHighlightBackground': '#323844',
                    'editorCursor.foreground': '#a9b7c6'
                  }
                });
              }
              
              const editorTheme = lang === 'R' ? 'rstudio-dark' : (lang === 'Python' ? 'pycharm-darcula' : 'vs-dark');
              const editorFontFamily = lang === 'R' 
                ? '"Source Code Pro", "Consolas", "Monaco", "Menlo", monospace' 
                : (lang === 'Python' 
                    ? '"JetBrains Mono", "Source Code Pro", Consolas, Monaco, Menlo, monospace'
                    : 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace');
              
              monacoEditor = monaco.editor.create(host, {
                value: text || '',
                language: monacoLang,
                theme: editorTheme,
                automaticLayout: true,
                fontFamily: editorFontFamily,
                fontSize: 13,
                minimap: { enabled: false },
                smoothScrolling: true,
                scrollBeyondLastLine: false,
                wordWrap: 'on',
                lineNumbers: 'on',
                renderLineHighlight: 'line',
                selectionHighlight: true,
                readOnly: true,
                domReadOnly: true
              });
              // expose for filler/resize logic
              try { window.monacoEditor = monacoEditor; } catch(_) {}
              // Re-adjust on content size changes
              try { monacoEditor.onDidContentSizeChange(() => { try { adjustCodeOutputHeight(); } catch(_) {} }); } catch(_) {}
              // Adjust code block height after creation
              try { adjustCodeOutputHeight(); } catch(_) {}
              // If the hidden textarea was updated (e.g., by initial preview)
              // before Monaco finished loading, sync its content now
              try {
                const initialVal = ta.value || '';
                if (((lang === 'JavaScript' && !isCodeEdited) || (lang === 'Python' && !isPyEdited) || (lang === 'R' && !isREdited)) && initialVal !== monacoEditor.getValue()) {
                  monacoEditor.setValue(initialVal);
                }
              } catch(_) {}
              // Ctrl/Cmd+Enter to run
              if (lang === 'JavaScript') {
                monacoEditor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => runUserJS());
              }
              // Update hidden textarea + edited state on changes
              monacoEditor.onDidChangeModelContent(() => {
                const val = monacoEditor.getValue();
                const norm = (s) => (s || '').replace(/\n+$/g, '');
                ta.value = val;
                if (lang === 'JavaScript') {
                  isCodeEdited = (norm(val) !== norm(autoJSCode));
                } else if (lang === 'Python') {
                  isPyEdited = (norm(val) !== norm(autoPyCode));
                } else if (lang === 'R') {
                  isREdited = (norm(val) !== norm(autoRCode));
                }
                updateResetButtonVisibility();
              });
            });
          } else {
            disposeMonaco();
            const ta = document.createElement('textarea');
            ta.id = 'code-editor';
            ta.spellcheck = false;
            
            // Apply language-specific styling for textarea fallback
            if (lang === 'R') {
              ta.className = 'w-full border border-gray-600 rounded-md p-3 font-mono text-sm outline-none focus:ring-2 focus:ring-blue-400';
              ta.style.backgroundColor = '#2b2b2b';
              ta.style.color = '#d4d4d4';
              ta.style.fontFamily = '"Source Code Pro", "Consolas", "Monaco", "Menlo", monospace';
              ta.style.lineHeight = '1.5';
            } else if (lang === 'Python') {
              ta.className = 'w-full border border-gray-600 rounded-md p-3 font-mono text-sm outline-none focus:ring-2 focus:ring-emerald-400';
              ta.style.backgroundColor = '#2b2b2b';
              ta.style.color = '#a9b7c6';
              ta.style.fontFamily = '"JetBrains Mono", "Source Code Pro", Consolas, Monaco, Menlo, monospace';
              ta.style.lineHeight = '1.5';
            } else {
              ta.className = 'w-full bg-transparent border border-gray-700 rounded-md p-3 font-mono text-sm text-gray-200 outline-none focus:ring-2 focus:ring-emerald-500';
            }
            
            ta.style.height = '580px'; // Increased to show ~3 more lines
            ta.dataset.baseHeight = '580';
            ta.classList.add('code-host');
            ta.classList.add('vc-editor-readonly');
            ta.classList.add('cursor-not-allowed');
            ta.readOnly = true;
            ta.setAttribute('aria-readonly', 'true');
            ta.style.cursor = 'not-allowed';
            ta.placeholder = (lang === 'Python')
              ? "# Python (Seaborn)\n# Write or paste your code here."
              : (lang === 'R')
                ? "# R (ggplot2)\n# Write or paste your code here."
                : '';
            ta.value = text || '';
            container.appendChild(ta);
            // Track edited state
            if (lang === 'Python') {
              isPyEdited = !!text && text !== autoPyCode ? true : false;
              ta.addEventListener('input', () => {
                isPyEdited = (ta.value !== autoPyCode);
                updateResetButtonVisibility();
              });
            } else if (lang === 'R') {
              isREdited = !!text && text !== autoRCode ? true : false;
              ta.addEventListener('input', () => {
                isREdited = (ta.value !== autoRCode);
                updateResetButtonVisibility();
              });
            } else {
              isCodeEdited = false;
            }
            updateResetButtonVisibility();
          }
          // Run button removed; no toggle needed
        }

        function setStaticCodeBlock(html) {
          const container = document.getElementById('code-output-container');
          if (!container) return;
          container.innerHTML = html;
          const codeBlock = container.querySelector('code');
          // If you want static highlighting for non-JS snippets later,
          // integrate a highlighter here (e.g., Prism). Left as no-op for now.
          // Run button removed
        }

        function updateCodeOutput(lang) {
          if (codeOutputTitleText) codeOutputTitleText.textContent = `${lang} Code`;
          if (lang === 'JavaScript') {
            setCodeEditorContent(currentJSCode, 'JavaScript');
          } else if (lang === 'Python') {
            // Default Python template with required imports
            const pyDefault = pyDefaultTemplate();
            setCodeEditorContent(pyDefault, 'Python');
            autoPyCode = pyDefault;
            isPyEdited = false;
            // Attempt immediate refresh from current builder state
            setTimeout(() => { tryUpdatePythonCodePreview(); }, 0);
          } else if (lang === 'R') {
            // Default R template with required imports
            const rDefault = rDefaultTemplate();
            setCodeEditorContent(rDefault, 'R');
            autoRCode = rDefault;
            isREdited = false;
            // Attempt immediate refresh from current builder state
            setTimeout(() => { tryUpdateRCodePreview(); }, 0);
          }
        }

        // Set initial state
        updateCodeOutput("JavaScript");

        libraryButtons.forEach((button) => {
          button.addEventListener("click", () => {
            libraryButtons.forEach((btn) => {
              btn.classList.remove("active");
              btn.classList.add("text-gray-400", "hover:bg-gray-700");
            });

          button.classList.add("active");
          button.classList.remove("text-gray-400", "hover:bg-gray-700");

          const selectedLang = button.dataset.lang;
          updateCodeOutput(selectedLang);
          updateResetButtonVisibility();
          // When switching libraries, manage placeholder visibility based on current chart state
          try {
            document.getElementById('chart-center-message')?.remove();
            // If a chart is showing or we're in loading/error, don't show placeholder on switch
            const activeState = (window.chartDisplayState || 'placeholder');
            const shouldKeep = activeState === 'plotly' || activeState === 'success' || activeState === 'loading' || activeState === 'error';
            if (shouldKeep) {
              chartPlaceholder?.classList.add('hidden');
            } else {
              // Only reveal placeholder when nothing has been rendered yet
              chartPlaceholder?.classList.remove('hidden');
              setChartActionsEnabled(false);
            }
            // Never auto-purge existing Plotly chart just because library switched;
            // leave existing visualization visible unless a new Generate action runs.
          } catch (_) { /* ignore */ }
          // Refresh code preview for the newly selected language
          if (selectedLang === 'Python') {
            tryUpdatePythonCodePreview();
          } else if (selectedLang === 'JavaScript') {
            tryUpdateJSCodePreview();
          } else if (selectedLang === 'R') {
            tryUpdateRCodePreview();
          }
        });
      });

        // --- Live code preview updates ---
  const previewWatchIds = ['chart-title','chart-subtitle','x-axis-label','y-axis-label','source-text','legend-title','legend-position','legend-border','show-legend','x-axis','y-axis','chart-type','color-palette','gradient-select','gradient-invert','group-by', 'group-by-bins','histogram-bin-count', 'adv-orient-vertical', 'adv-orient-horizontal', 'adv-trend-toggle', 'adv-grid-toggle', 'adv-image-bg', 'adv-chart-bg', 'adv-text-style'];
        previewWatchIds.forEach((id)=>{ const el = document.getElementById(id); if (!el) return; const evt = (el.tagName==='INPUT' && el.type==='text') ? 'input' : 'change'; el.addEventListener(evt, ()=> tryUpdateCodePreview()); });
        // Legend title clear/restore logic
        const showLegendEl = document.getElementById('show-legend');
        const legendTitleInput = document.getElementById('legend-title');
        const legendPosSel = document.getElementById('legend-position');
        const legendVarSel = document.getElementById('legend-variable');
        const legendOrderSel = document.getElementById('legend-order');
        const legendBorderInput = document.getElementById('legend-border');
        function handleLegendToggle() {
          if (!showLegendEl || !legendTitleInput) return;
          if (showLegendEl.checked) {
            if (legendTitleInput.dataset.prevLegendTitle !== undefined) {
              legendTitleInput.value = legendTitleInput.dataset.prevLegendTitle || '';
              delete legendTitleInput.dataset.prevLegendTitle;
            }
            legendTitleInput.disabled = false;
            legendTitleInput.classList.remove('opacity-50');
            // enable other legend controls
            if (legendPosSel) { legendPosSel.disabled = false; legendPosSel.classList.remove('opacity-50'); }
            if (legendVarSel) { legendVarSel.disabled = false; legendVarSel.classList.remove('opacity-50'); }
            if (legendOrderSel) { legendOrderSel.disabled = false; legendOrderSel.classList.remove('opacity-50'); }
            if (legendBorderInput) {
              legendBorderInput.disabled = false;
              const wrap = legendBorderInput.parentElement; if (wrap) wrap.classList.remove('opacity-50');
            }
          } else {
            legendTitleInput.dataset.prevLegendTitle = legendTitleInput.value || '';
            legendTitleInput.value = '';
            legendTitleInput.disabled = true;
            legendTitleInput.classList.add('opacity-50');
            // disable other legend controls
            if (legendPosSel) { legendPosSel.disabled = true; legendPosSel.classList.add('opacity-50'); }
            if (legendVarSel) { legendVarSel.disabled = true; legendVarSel.classList.add('opacity-50'); }
            if (legendOrderSel) { legendOrderSel.disabled = true; legendOrderSel.classList.add('opacity-50'); }
            if (legendBorderInput) {
              legendBorderInput.disabled = true;
              const wrap = legendBorderInput.parentElement; if (wrap) wrap.classList.add('opacity-50');
            }
          }
          tryUpdateCodePreview();
        }
        if (showLegendEl) {
          showLegendEl.addEventListener('change', handleLegendToggle);
          // Apply once at load to ensure correct state
          handleLegendToggle();
        }
        // Initial preview
        tryUpdateCodePreview();
        // --- Data upload + axis population ---
        const dropzone = document.getElementById("upload-dropzone");
        const fileInput = document.getElementById("data-file");
        const fileNameEl = document.getElementById("upload-filename");
        const xAxisSelect = document.getElementById("x-axis");
        const yAxisSelect = document.getElementById("y-axis");
        const groupBySelect = document.getElementById("group-by");

        let uploadedData = null; // stores parsed rows as array of objects
        let uploadedDataCSV = null; // stores original CSV string for backend transmission

        function setFilename(name) {
          if (fileNameEl) fileNameEl.textContent = name ? `Loaded: ${name}` : "";
        }

        function convertDataToCSV(data) {
          if (!Array.isArray(data) || data.length === 0) return '';
          
          // Get all column names from the first row
          const columns = Object.keys(data[0]);
          
          // Helper function to escape CSV values
          const escapeCSVValue = (value) => {
            if (value === null || value === undefined) return '';
            const str = String(value);
            // If the value contains comma, quote, or newline, wrap in quotes and escape internal quotes
            if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
              return `"${str.replace(/"/g, '""')}"`;
            }
            return str;
          };
          
          // Create CSV header
          const csvLines = [columns.map(escapeCSVValue).join(',')];
          
          // Add data rows
          for (const row of data) {
            const csvRow = columns.map(col => escapeCSVValue(row[col])).join(',');
            csvLines.push(csvRow);
          }
          
          return csvLines.join('\n');
        }

        function populateAxisOptions(columns, data) {
            const makeOptions = (sel) => {
                if (!sel) return;
                sel.innerHTML = "";
                const placeholder = document.createElement("option");
                placeholder.value = "";
                placeholder.selected = true;
                placeholder.textContent = "Select Column";
                sel.appendChild(placeholder);
                columns.forEach((col) => {
                    const opt = document.createElement("option");
                    opt.value = col;
                    opt.textContent = col;
                    sel.appendChild(opt);
                });
                setPlaceholderStyle(sel);
            };

            makeOptions(xAxisSelect);
            makeOptions(yAxisSelect);

            // Enhanced "Group By" population
            if (groupBySelect) {
                groupBySelect.innerHTML = "";
                const placeholder = document.createElement("option");
                placeholder.value = "";
                placeholder.selected = true;
                placeholder.textContent = "None";
                groupBySelect.appendChild(placeholder);

                columns.forEach(col => {
                    const values = data.map(r => r[col]).filter(v => v !== null && v !== undefined && v !== '');
                    if (values.length === 0) return;

                    const isContinuous = values.every(v => !isNaN(parseFloat(v)) && isFinite(v));
                    const uniqueValues = new Set(values);

                    let candidate = false;
                    let dataType = '';

                    if (isContinuous) {
                        candidate = true;
                        dataType = 'continuous';
                    } else if (uniqueValues.size < values.length) { // Discrete with duplicates
                        candidate = true;
                        dataType = 'discrete';
                    }

                    if (candidate) {
                        const opt = document.createElement("option");
                        opt.value = col;
                        opt.textContent = col;
                        opt.dataset.type = dataType;
                        groupBySelect.appendChild(opt);
                    }
                });
                setPlaceholderStyle(groupBySelect);
            }
        }

        function autoGuessAxisType(axis) {
            const selectEl = document.getElementById(`${axis}-axis`);
            const typeWrapEl = document.getElementById(`${axis}-axis-type-wrap`);
            const typeSelectEl = document.getElementById(`${axis}-axis-type`);
            if (!selectEl || !typeWrapEl || !typeSelectEl || !uploadedData) return;

            const col = selectEl.value;
            const isSingle = col === SINGLE_VAR_OPTION_VALUE;
            if (!col || isSingle) {
                if (isSingle) {
                  // Show 'None' type and disable type select when in single-variable mode for this axis
                  updateAxisTypeNoneState(axis);
                } else {
                  typeWrapEl.classList.add('hidden');
                }
                // If the opposite axis has a real column selected, default this axis to single-variable-only
                try {
                  const otherAxis = axis === 'x' ? 'y' : 'x';
                  const otherSel = document.getElementById(`${otherAxis}-axis`);
                  const otherVal = otherSel?.value || '';
                  const otherIsReal = !!otherVal && otherVal !== SINGLE_VAR_OPTION_VALUE;
                  if (otherIsReal) {
                    // Do not auto-select SVO; only make it available as an option
                    updateSingleVarOptionVisibility();
                  } else {
                    // If the other axis was single-variable and this axis is now cleared, reset the other axis to placeholder
                    if (!col && otherSel && otherSel.value === SINGLE_VAR_OPTION_VALUE) {
                      otherSel.value = '';
                      setPlaceholderStyle(otherSel);
                    }
                    // If this axis was set to single-variable and other axis is cleared, reset this axis to placeholder
                    if (isSingle) {
                      const thisSel = document.getElementById(`${axis}-axis`);
                      if (thisSel) { thisSel.value = ''; setPlaceholderStyle(thisSel); }
                    }
                    // Update visibility centrally
                    updateSingleVarOptionVisibility();
                    updateAxisTypeNoneState('x');
                    updateAxisTypeNoneState('y');
                  }
                } catch(_) {}
                updateChartTypeOptions();
                updateSingleVarUIState();
                return;
            }

            // Keep the type UI hidden from users
            typeWrapEl.classList.add('hidden');
            // Ensure 'None' is removed if previously set due to single-variable state
            updateAxisTypeNoneState(axis);
            const values = uploadedData.map(r => r[col]).filter(v => v !== null && v !== undefined && v !== '');
            if (values.length > 0) {
                const isContinuous = values.every(v => !isNaN(parseFloat(v)) && isFinite(v));
                typeSelectEl.value = isContinuous ? 'continuous' : 'discrete';
                typeSelectEl.dispatchEvent(new Event('change')); // Trigger dependent updates
            }
            // Add and select 'Single Variable Only' by default on the opposite axis if empty
            try {
              const otherAxis = axis === 'x' ? 'y' : 'x';
              const otherSel = document.getElementById(`${otherAxis}-axis`);
              if (otherSel && (!otherSel.value || otherSel.value === '')) {
                // Do not auto-select SVO; only make it available as an option
                updateSingleVarOptionVisibility();
              }
              // Update visibility centrally
              updateSingleVarOptionVisibility();
            } catch(_) {}
            updateChartTypeOptions();
            updateSingleVarUIState();
        }

        function parseCSV(text) {
          // basic CSV/TSV parser; handles quotes minimally
          const delimiter = text.indexOf("\t") !== -1 ? "\t" : ",";
          const lines = text.split(/\r?\n/).filter((l) => l.trim().length);
          if (lines.length === 0) return { columns: [], rows: [] };
          const parseLine = (line) => {
            const result = [];
            let cur = ""; let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
              const ch = line[i];
              if (ch === '"') {
                if (inQuotes && line[i+1] === '"') { cur += '"'; i++; }
                else { inQuotes = !inQuotes; }
              } else if (!inQuotes && ch === delimiter) {
                result.push(cur); cur = "";
              } else {
                cur += ch;
              }
            }
            result.push(cur);
            return result;
          };
          const header = parseLine(lines[0]).map(h => h.trim()).filter(Boolean);
          const rows = lines.slice(1).map(l => parseLine(l)).map(arr => {
            const obj = {};
            header.forEach((h, idx) => obj[h] = arr[idx]);
            return obj;
          });
          return { columns: header, rows };
        }

        async function handleFile(file) {
          if (!file) return;
          setFilename(file.name);
          try { window.VC_LAST_FILE = file; } catch (_) {}
          const text = await file.text();
          let parsed = { columns: [], rows: [] };
          const lower = file.name.toLowerCase();
          try {
            if (lower.endsWith(".json")) {
              const json = JSON.parse(text);
              // expect array of objects
              if (Array.isArray(json) && json.length > 0 && typeof json[0] === 'object') {
                const columns = Object.keys(json[0]);
                parsed = { columns, rows: json };
              }
            } else {
              parsed = parseCSV(text);
            }
          } catch (e) {
            console.warn("Failed to parse file", e);
          }
          uploadedData = parsed.rows;
          if (typeof histogramBinInput !== 'undefined' && histogramBinInput) {
            histogramBinInput.dataset.histManual = '0';
            delete histogramBinInput.dataset.histSkip;
          }
          // Store CSV data for backend transmission
          if (lower.endsWith(".json")) {
            // Convert JSON data to CSV format for backend compatibility
            uploadedDataCSV = convertDataToCSV(parsed.rows);
          } else {
            // Use original CSV text for CSV files
            uploadedDataCSV = text;
          }
          if (parsed.columns && parsed.columns.length) {
            populateAxisOptions(parsed.columns, parsed.rows);
            // Add event listeners for auto-guessing axis types and syncing single-variable state
            xAxisSelect.addEventListener('change', () => { autoGuessAxisType('x'); updateAxisTypeNoneState('x'); updateAxisTypeNoneState('y'); updateSingleVarOptionVisibility(); updateAdvancedLabel(); updateGenerateButtonState(); });
            yAxisSelect.addEventListener('change', () => { autoGuessAxisType('y'); updateAxisTypeNoneState('x'); updateAxisTypeNoneState('y'); updateSingleVarOptionVisibility(); updateAdvancedLabel(); updateGenerateButtonState(); });
            // Hide type selects initially
            document.getElementById('x-axis-type-wrap').classList.add('hidden');
            document.getElementById('y-axis-type-wrap').classList.add('hidden');
            
            // Reset dependent selects to their placeholders on first upload
            try {
              if (xTypeSel) { xTypeSel.value = ""; setPlaceholderStyle(xTypeSel); }
              if (yTypeSel) { yTypeSel.value = ""; setPlaceholderStyle(yTypeSel); }
              if (chartTypeSel) {
                // Rebuild as placeholder only; will repopulate when types chosen
                chartTypeSel.innerHTML = '';
                const ph = document.createElement('option');
                ph.value = '';
                ph.selected = true;
                ph.textContent = 'Select Chart Type';
                chartTypeSel.appendChild(ph);
                setPlaceholderStyle(chartTypeSel);
              }
              const paletteSel = document.getElementById('color-palette');
              if (paletteSel) { paletteSel.value = ''; setPlaceholderStyle(paletteSel); }
              // Reset gradient options visibility and values
              updateGradientVisibility();
              const gs = document.getElementById('gradient-select');
              if (gs) { gs.value = ''; setPlaceholderStyle(gs); }
              const gi = document.getElementById('gradient-invert');
              if (gi) gi.checked = false;
              if (groupBySelect) { groupBySelect.value = ''; setPlaceholderStyle(groupBySelect); }
              updateGroupByBinsVisibility(); // Hide bins/groups wraps
              // Refresh chart-type options based on (now empty) types
              updateChartTypeOptions();
              updateSingleVarUIState();
              updateSingleVarOptionVisibility();
              updateGenerateButtonState();
            } catch (_) {}
            // Reset chart view to placeholder
            try {
              // Remove any existing center error overlay
              document.getElementById('chart-center-message')?.remove();
              if (chartDisplayState !== 'success' && chartDisplayState !== 'error') {
                chartPlaceholder?.classList.remove('hidden');
                if (chartCanvas) { Plotly.purge(chartCanvas); currentChart = null; }
                const center = document.getElementById('chart-placeholder-center');
                if (center) {
                  center.innerHTML = '<svg class="w-36 h-36 text-gray-500" viewBox="0 0 80 64" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><rect x="2" y="2" width="76" height="60" rx="8" ry="8" stroke-width="3"></rect><rect x="8" y="36" width="8" height="16" rx="2" stroke-width="2.4"></rect><rect x="22" y="28" width="8" height="24" rx="2" stroke-width="2.4"></rect><rect x="36" y="32" width="8" height="20" rx="2" stroke-width="2.4"></rect><rect x="50" y="20" width="8" height="32" rx="2" stroke-width="2.4"></rect><rect x="64" y="24" width="8" height="28" rx="2" stroke-width="2.4"></rect><path d="M12 28 L26 20 L40 24 L54 12 L68 16" stroke-width="2.4"></path><circle cx="12" cy="28" r="3" stroke-width="2.64" fill="currentColor"></circle><circle cx="26" cy="20" r="3" stroke-width="2.64" fill="currentColor"></circle><circle cx="40" cy="24" r="3" stroke-width="2.64" fill="currentColor"></circle><circle cx="54" cy="12" r="3" stroke-width="2.64" fill="currentColor"></circle><circle cx="68" cy="16" r="3" stroke-width="2.64" fill="currentColor"></circle>';
                }
                setChartActionsEnabled(false);
              }
            } catch (_) {}
            // Refresh error bars availability
            updateAdvancedLabel();
          }

          // Do not inject any helper functions into the JS editor; instead, remove any previously injected helpers.
          try {
            const selectedLang = document.querySelector('.library-btn.active')?.dataset.lang;
            if (selectedLang === 'JavaScript') {
              const ed = document.getElementById('code-editor');
              let existing = currentJSCode || '';
              if (existing) {
                const cleaned = existing
                  .replace(/\/\* BEGIN:VC_LOADER_HELPERS \*[\s\S]*?\/\* END:VC_LOADER_HELPERS \*\/[\n\r]*/g, '')
                  .replace(/<script>[\s\S]*?function\s+excelToJSON[\s\S]*?<\/script>[\n\r]*/g, '')
                  .replace(/<script>[\s\S]*?function\s+csvToJSON[\s\S]*?<\/script>[\n\r]*/g, '')
                  .replace(/<script>[\s\S]*?function\s+tsvToJSON[\s\S]*?<\/script>[\n\r]*/g, '')
                  .replace(/<script>[\s\S]*?function\s+jsonToJSON[\s\S]*?<\/script>[\n\r]*/g, '')
                  .replace(/const __XLSX_URL[\s\S]*?async function excelToJSON\([\s\S]*?\}[\n\r]*/g, '')
                  .replace(/async function csvToJSON\([\s\S]*?\}[\n\r]*/g, '')
                  .replace(/async function tsvToJSON\([\s\S]*?\}[\n\r]*/g, '')
                  .replace(/async function jsonToJSON\([\s\S]*?\}[\n\r]*/g, '')
                  .replace(/const\s+data\s*=\s*await\s*(excelToJSON|csvToJSON|tsvToJSON|jsonToJSON)\s*\(\s*window\.VC_LAST_FILE\s*\)\s*;/g, 'const data = [];');
                if (cleaned !== existing) {
                  currentJSCode = cleaned;
                  if (ed) ed.value = cleaned;
                }
              }
            }
          } catch (e) {
            console.warn('Cleanup of upload helper snippets failed', e);
          }
          // Refresh code preview (updates Python code with suggested file name)
          tryUpdateCodePreview();
        }

        if (dropzone && fileInput) {
          dropzone.addEventListener('click', () => fileInput.click());
          dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('border-emerald-400'); });
          dropzone.addEventListener('dragleave', () => dropzone.classList.remove('border-emerald-400'));
          dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('border-emerald-400');
            const file = e.dataTransfer.files && e.dataTransfer.files[0];
            handleFile(file);
          });
          fileInput.addEventListener('change', (e) => {
            const file = e.target.files && e.target.files[0];
            handleFile(file);
          });
        }

        // --- Chart generation ---
  const chartCanvas = document.getElementById('chartCanvas');
  const chartPlaceholder = document.getElementById('chart-placeholder');
  let currentChart = null;
  // Track what the chart area is currently showing so UI reacts consistently
  // Possible values: 'placeholder' | 'loading' | 'success' | 'error' | 'plotly'
  // Initialized as placeholder; kept in window for debugging/other handlers.
  let chartDisplayState = 'placeholder';
  try { window.chartDisplayState = chartDisplayState; } catch(_) {}

        function setChartActionsEnabled(enabled) {
          const copyBtn = document.getElementById('chart-copy-btn');
          const dlBtn = document.getElementById('chart-download-btn');
          [copyBtn, dlBtn].forEach(btn => {
            if (!btn) return;
            btn.disabled = !enabled;
            btn.classList.toggle('opacity-50', !enabled);
            btn.classList.toggle('cursor-not-allowed', !enabled);
          });
        }

  // Initially show placeholder state and record it
  setChartDisplayState('placeholder');

        function palette(name, n) {
          // Helper: color interpolation utilities
          function hexToRgb(hex) {
            const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return m ? { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) } : {r:0,g:0,b:0};
          }
          function rgbToHex({r,g,b}) {
            const toHex = (v) => v.toString(16).padStart(2,'0');
            return `#${toHex(Math.max(0,Math.min(255,Math.round(r))))}${toHex(Math.max(0,Math.min(255,Math.round(g))))}${toHex(Math.max(0,Math.min(255,Math.round(b))))}`;
          }
          function lerp(a,b,t){ return a+(b-a)*t; }
          function interp(c1,c2,t){
            const A=hexToRgb(c1), B=hexToRgb(c2);
            return rgbToHex({ r: lerp(A.r,B.r,t), g: lerp(A.g,B.g,t), b: lerp(A.b,B.b,t) });
          }
          function gradientColors(stops, count, invert=false){
            const out=[]; if (invert) stops=[...stops].reverse();
            if (count<=1) { out.push(stops[stops.length-1]); return out; }
            for (let i=0;i<count;i++){
              const pos = count===1 ? 1 : i/(count-1);
              // find segment
              const seg = pos*(stops.length-1);
              const idx = Math.min(stops.length-2, Math.floor(seg));
              const t = seg - idx;
              out.push(interp(stops[idx], stops[idx+1], t));
            }
            return out;
          }

          // Non-gradient palettes
          const maps = {
            'Vega Chart': ['#34d399','#22c55e','#10b981','#06b6d4','#3b82f6','#8b5cf6'],
            'Pastel': ['#a5b4fc','#fbcfe8','#fde68a','#bbf7d0','#bae6fd','#f5d0fe'],
            'Default': ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf'],
            'ColorBlind': ['#0072B2','#E69F00','#56B4E9','#009E73','#F0E442','#D55E00','#CC79A7','#999999']
          };

          if (name === 'Gradient') {
            const gs = document.getElementById('gradient-select');
            const inv = document.getElementById('gradient-invert');
            const key = gs?.value || '';
            const invert = !!(inv && inv.checked);
            const gradients = {
              'grayscale': ['#111827','#d1d5db','#f9fafb'],
              'red': ['#7f1d1d','#ef4444','#fecaca'],
              'green': ['#064e3b','#10b981','#a7f3d0'],
              'blue': ['#1e3a8a','#3b82f6','#bfdbfe'],
              'orange': ['#7c2d12','#fb923c','#fed7aa'],
              'green-blue': ['#10b981','#3b82f6'],
              'yellow-green': ['#f59e0b','#10b981'],
              'orange-red': ['#fb923c','#ef4444'],
              'red-purple': ['#ef4444','#8b5cf6']
            };
            const stops = gradients[key] || ['#374151','#9ca3af','#e5e7eb'];
            return gradientColors(stops, n, invert);
          }

          const arr = maps[name] || maps['Vega Chart'];
          // If many categories, generate a gradient from the base palette
          if (n > 7) {
              return gradientColors(arr, n);
          }
          const out = [];
          for (let i=0;i<n;i++) out.push(arr[i % arr.length]);
          return out;
        }

        function inferType(value) {
          if (value === null || value === undefined) return 'string';
          const num = toFiniteNumber(value);
          return Number.isFinite(num) ? 'number' : 'string';
        }

        // --- Helpers for binning and legend completeness ---
        function formatNumberPretty(num) {
          try {
            if (!Number.isFinite(num)) return String(num);
            // Use up to 3 significant digits, avoid scientific notation
            return new Intl.NumberFormat('en-US', { maximumSignificantDigits: 3 }).format(num);
          } catch (_) {
            return String(num);
          }
        }

        function computeBins(values, bins) {
          if (!Array.isArray(values) || values.length === 0 || !Number.isFinite(bins) || bins < 1) {
            return { min: 0, max: 0, size: 0, labels: [], edges: [] };
          }
          const min = Math.min(...values);
          const max = Math.max(...values);
          if (min === max) {
            const label = `[${formatNumberPretty(min)}, ${formatNumberPretty(max)}]`;
            return { min, max, size: 0, labels: [label], edges: [min, max] };
          }
          const size = (max - min) / bins;
          const edges = new Array(bins + 1).fill(0).map((_, i) => min + i * size);
          // Build human-friendly labels: [a, b) except last [a, b]
          const labels = new Array(bins).fill(0).map((_, i) => {
            const a = edges[i];
            const b = edges[i + 1];
            const open = '['; // inclusive lower bound
            const close = (i === bins - 1) ? ']' : ')'; // last bin inclusive
            return `${open}${formatNumberPretty(a)}, ${formatNumberPretty(b)}${close}`;
          });
          return { min, max, size, labels, edges };
        }

        function histogramBinConfig(values, bins, orientation) {
          if (!Array.isArray(values) || values.length === 0) return {};
          const info = computeBins(values, bins);
          if (!info || !Number.isFinite(info.size) || info.size <= 0 || !Number.isFinite(info.min) || !Number.isFinite(info.max)) return {};
          const edges = Array.isArray(info.edges) && info.edges.length >= 2 ? info.edges : [info.min, info.max];
          const start = edges[0];
          let end = edges[edges.length - 1];
          const epsilon = Math.abs(info.size) * 1e-6 || 1e-9;
          if (!Number.isFinite(start) || !Number.isFinite(end)) return {};
          if (end <= start) end = start + epsilon;
          const binSpec = { start, end: end + epsilon, size: info.size };
          const orient = (orientation === 'horizontal' || orientation === 'h') ? 'horizontal' : 'vertical';
          return orient === 'horizontal'
            ? { autobiny: false, ybins: binSpec }
            : { autobinx: false, xbins: binSpec };
        }

        function legendOnlyTrace(base, name, color) {
          // Create a minimal trace that shows in the legend but not in the plot
          const t = { ...base };
          t.name = name;
          t.visible = 'legendonly';
          if (!t.marker && (t.type === 'scatter' || !t.type)) t.marker = {};
          if (t.marker && color) t.marker.color = color;
          // Provide a null point for traces that require arrays
          if (!t.x && !t.y) { t.x = [null]; t.y = [null]; }
          return t;
        }

        // Remove keys with value === undefined (recursively) so Plotly
        // never sees objects like trace.marker === undefined and tries
        // to iterate them with `for..in`, which throws in some builds.
        function pruneUndefined(value) {
          if (Array.isArray(value)) {
            return value.map(pruneUndefined);
          }
          if (value && typeof value === 'object') {
            const out = {};
            for (const k of Object.keys(value)) {
              const v = value[k];
              if (v !== undefined) out[k] = pruneUndefined(v);
            }
            return out;
          }
          return value;
        }

        function cleanupTraces(traces) {
          return (traces || []).map(pruneUndefined).filter(t => t && typeof t === 'object');
        }

        // --- Linear regression helpers for trend lines ---
        function linearRegression(points) {
          try {
            const pts = (points || []).filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
            const n = pts.length;
            if (n < 2) return null;
            let sumX = 0, sumY = 0, sumXX = 0, sumXY = 0;
            for (const {x,y} of pts) { sumX += x; sumY += y; sumXX += x*x; sumXY += x*y; }
            const denom = n * sumXX - sumX * sumX;
            if (!Number.isFinite(denom) || Math.abs(denom) < 1e-12) return null; // vertical line or degenerate
            const a = (n * sumXY - sumX * sumY) / denom; // slope
            const b = (sumY - a * sumX) / n;             // intercept
            // endpoints across observed domain
            let minX = Infinity, maxX = -Infinity;
            for (const {x} of pts) { if (x < minX) minX = x; if (x > maxX) maxX = x; }
            if (!Number.isFinite(minX) || !Number.isFinite(maxX) || minX === maxX) return null;
            return { a, b, x: [minX, maxX], y: [a*minX + b, a*maxX + b] };
          } catch(_) { return null; }
        }

        // --- Text style helpers (used across JS/Python/R generators) ---
        function getTextStyleChoice() {
          try { return (document.getElementById('adv-text-style')?.value) || 'normal'; } catch(_) { return 'normal'; }
        }
        function escapeHtml(s) {
          try { return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); } catch(_) { return String(s || ''); }
        }
        function styleText(text) {
          const t = escapeHtml(text || '');
          const style = getTextStyleChoice();
          if (!t) return t;
          if (style === 'bold') return `<b>${t}</b>`;
          if (style === 'italic') return `<i>${t}</i>`;
          if (style === 'bold-italic') return `<b><i>${t}</i></b>`;
          return t;
        }
        function styleTitleAndSubtitle(title, subtitle) {
          const tt = styleText(title || '');
          const st = styleText(subtitle || '');
          // Render subtitle smaller and neutral to avoid crowding
          if (subtitle) return `${tt}<br><span style="font-size:12px;color:#9ca3af">${st}</span>`;
          return tt;
        }

        // Ensure generated JS uses a valid container element instead of a plain id string
        function postProcessJSCode(source) {
          try {
            const injection = "const __target = (typeof containerId !== 'undefined') ? (typeof containerId === 'string' ? document.getElementById(containerId) : containerId) : document.getElementById('chartCanvas');\\nif (!__target) { throw new Error('Chart container not found'); }\\nPlotly.newPlot(__target";
            return String(source).replace(/Plotly\.newPlot\((['"])chartCanvas\1/, injection);
          } catch (_) { return source; }
        }

        const VC_WATERMARK_Y = -0.12;
        const VC_SOURCE_Y = -0.12;
        const VC_MARGIN_FALLBACK = { l: 64, r: 32, t: 64, b: 64 };

        function ensureAnnotationPadding(layout, dims = {}) {
          try {
            if (!layout || typeof layout !== 'object') return layout;
            const annotations = Array.isArray(layout.annotations) ? layout.annotations : [];
            if (!annotations.length) return layout;
            const margin = (layout.margin && typeof layout.margin === 'object') ? { ...layout.margin } : {};
            let changed = false;
            const usableHeight = Math.max(
              360,
              Number.isFinite(dims?.contextHeight) ? dims?.contextHeight : 0,
              Number.isFinite(dims?.height) ? dims?.height : 0,
              Number.isFinite(layout?.height) ? layout?.height : 0
            );
            const usableWidth = Math.max(
              480,
              Number.isFinite(dims?.contextWidth) ? dims?.contextWidth : 0,
              Number.isFinite(dims?.width) ? dims?.width : 0,
              Number.isFinite(layout?.width) ? layout?.width : 0
            );
            const ensureSide = (side, required) => {
              const base = margin[side] !== undefined ? margin[side] : VC_MARGIN_FALLBACK[side];
              const target = Math.max(base, required);
              if (target !== base) {
                margin[side] = target;
                changed = true;
              }
            };
            for (const ann of annotations) {
              if (!ann || ann.visible === false) continue;
              const fontSize = typeof ann?.font?.size === 'number' ? ann.font.size : 12;
              const pad = fontSize + 6;
              const x = typeof ann?.x === 'number' ? ann.x : null;
              const y = typeof ann?.y === 'number' ? ann.y : null;
              const xref = String(ann?.xref || 'paper').toLowerCase();
              const yref = String(ann?.yref || 'paper').toLowerCase();
              if (yref === 'paper' && y !== null) {
                if (y < 0) {
                  const needed = pad + Math.round(-y * usableHeight);
                  ensureSide('b', needed);
                } else if (y > 1) {
                  const needed = pad + Math.round((y - 1) * usableHeight);
                  ensureSide('t', needed);
                }
              }
              if (xref === 'paper' && x !== null) {
                if (x < 0) {
                  const needed = pad + Math.round(-x * usableWidth);
                  ensureSide('l', needed);
                } else if (x > 1) {
                  const needed = pad + Math.round((x - 1) * usableWidth);
                  ensureSide('r', needed);
                }
              }
            }
            if (changed) {
              layout.margin = { ...layout.margin, ...margin };
            }
            return layout;
          } catch (_) {
            return layout;
          }
        }

        function buildChartConfig() {
          const xCol = xAxisSelect.value;
          const yCol = yAxisSelect.value;
          const typeSel = document.getElementById('chart-type');
          const paletteSel = document.getElementById('color-palette');
          const showLegend = document.getElementById('show-legend')?.checked;
          const legendPosStr = document.getElementById('legend-position')?.value || 'Top Right';
          
          const groupBySelect = document.getElementById('group-by');
          const legendVar = groupBySelect?.value || '';
          const selectedGroupByOption = groupBySelect ? groupBySelect.options[groupBySelect.selectedIndex] : null;
          const groupByDataType = selectedGroupByOption ? selectedGroupByOption.dataset.type : null;

          const legendTitle = document.getElementById('legend-title')?.value || '';
          const legendBorder = document.getElementById('legend-border')?.checked || false;
          const legendOrder = document.getElementById('legend-order')?.value || 'Normal';
          const title = document.getElementById('chart-title')?.value || '';
          const subtitle = document.getElementById('chart-subtitle')?.value || '';
          const xLabel = document.getElementById('x-axis-label')?.value || '';
          const yLabel = document.getElementById('y-axis-label')?.value || '';
          const sourceText = document.getElementById('source-text')?.value || '';

          // Read advanced options
          const advTrendToggle = document.getElementById('adv-trend-toggle')?.checked;
          const advOrientation = document.querySelector('input[name="adv-orientation"]:checked')?.value || 'vertical';
          const advShowGrid = (document.getElementById('adv-grid-toggle') ? document.getElementById('adv-grid-toggle').checked : true);
          const imgBgChoice = (document.getElementById('adv-image-bg')?.value) || 'default';
          const chartBgChoice = (document.getElementById('adv-chart-bg')?.value) || 'default';

          function resolveImageBg(choice) {
            switch (choice) {
              case 'transparent': return 'rgba(0,0,0,0)';
              case 'white': return '#f3f3f3';
              case 'blue': return '#0b1220';
              case 'default':
              default: return '#0a0a0a'; // current default Python/overall theme background
            }
          }
          function resolveChartBg(choice) {
            switch (choice) {
              case 'transparent': return 'rgba(0,0,0,0)';
              case 'white': return '#ffffff';
              case 'blue': return '#8ac0db';
              case 'green': return '#8adba5';
              case 'yellow': return '#fee14e';
              case 'orange': return '#fd732d';
              case 'purple': return '#ce8adb';
              case 'teal': return '#76d3cf';
              case 'default':
              default: return '#111827'; // Dark chart panel (distinct from outer image bg #0a0a0a)
            }
          }
          const bg = { paper: resolveImageBg(imgBgChoice), plot: resolveChartBg(chartBgChoice) };
          // Text color based primarily on IMAGE background; if image is transparent and panel is light, adapt
          let textColor;
          if (imgBgChoice === 'white') {
            textColor = '#111827';
          } else if (imgBgChoice === 'transparent' && ['#ffffff','#f3f3f3'].includes(bg.plot.toLowerCase())) {
            textColor = '#111827';
          } else {
            textColor = '#ffffff';
          }
          const mutedAnnotationColor = (imgBgChoice === 'white') ? '#4b5563' : '#9ca3af';

          const chartType = typeSel?.value || '';
          // Priority: show upload error first when no data is present
          if (!uploadedData || !uploadedData.length) {
            throw new Error('Please upload data to display first');
          }
          // If data exists but neither X nor Y is a real column, prompt to select data
          const xSelEl = document.getElementById('x-axis');
          const ySelEl = document.getElementById('y-axis');
          const xVal = xSelEl?.value || '';
          const yVal = ySelEl?.value || '';
          const hasRealX = !!xVal && xVal !== SINGLE_VAR_OPTION_VALUE;
          const hasRealY = !!yVal && yVal !== SINGLE_VAR_OPTION_VALUE;
          if (!hasRealX && !hasRealY) {
            throw new Error('Please Select Data to Display');
          }
          // If data exists but no chart type chosen, surface chart type error
          if (!chartType) {
            throw new Error('Please Select Chart Type');
          }

          let data = [...uploadedData]; // Make a mutable copy

          // --- Single Variable Mode Handling ---
          const singleInfo = (typeof selectedSingleVarInfo === 'function') ? selectedSingleVarInfo() : null;
          const singleMode = !!singleInfo;
          if (singleMode) {
            const col = singleInfo.col;
            const dtype = detectDataTypeOfColumn(col);
            let traces = [];
            // Build single-variable charts based on selection
            if (chartType === 'pie' && dtype === 'discrete') {
              const freq = new Map();
              data.forEach(r => { const k = String(r[col] ?? ''); freq.set(k, (freq.get(k) || 0) + 1); });
              const labels = Array.from(freq.keys());
              const values = labels.map(k => freq.get(k));
              traces = [{
                type: 'pie',
                labels,
                values,
                textinfo: 'none',
                texttemplate: '%{label}<br>%{percent}',
                textposition: 'inside',
                insidetextorientation: 'radial',
                textfont: { color: textColor, size: 12 },
                hovertemplate: '%{label}: %{percent} (%{value})<extra></extra>',
                marker: {
                  colors: palette(paletteSel.value, labels.length),
                  line: { color: '#111827', width: 1 }
                },
                name: col
              }];
              const layout = {
                paper_bgcolor: bg.paper,
                plot_bgcolor: bg.plot,
                font: { color: textColor },
                title: { text: styleTitleAndSubtitle(title, subtitle), font: { color: textColor, size: 16 }, y: 0.92, yanchor: 'top' },
                // Keep the pie visually centered while reserving space for a right legend
                // Use larger top margin and lower title position to prevent clipping
                margin: { l: 80, r: 80, t: (title ? 80 : 50), b: (sourceText ? 96 : 64) }
              };
              if (showLegend) {
                layout.showlegend = true;
                layout.legend = { x: 1, xanchor: 'left', y: 0.5, bgcolor: (bg.plot === 'rgba(0,0,0,0)' ? bg.paper : bg.plot), font: { color: textColor } };
              } else {
                layout.showlegend = false;
                delete layout.legend;
              }
              if (sourceText) {
                layout.annotations = [{ text: sourceText, x: 1, xref: 'paper', xanchor: 'right', y: VC_FOOTER_ANNOT_Y, yref: 'paper', yanchor: 'top', showarrow: false, align: 'right', font: { color: mutedAnnotationColor, size: 11 } }];
              }
              return { data: cleanupTraces(traces), layout };
            }
            if (chartType === 'histogram' && dtype === 'continuous') {
              const vals = data.map(r => toFiniteNumber(r[col])).filter(v => Number.isFinite(v));
              const isHorizontal = advOrientation === 'horizontal';
              const histBinCount = readHistogramBinCount();
              const histColor = palette(paletteSel.value, 1)[0];
              const binConfig = histogramBinConfig(vals, histBinCount, isHorizontal ? 'horizontal' : 'vertical');
              traces = [
                isHorizontal
                  ? { type: 'histogram', orientation: 'h', y: vals, nbinsy: histBinCount, marker: { color: histColor }, name: `Count of ${col}`, ...binConfig }
                  : { type: 'histogram', x: vals, nbinsx: histBinCount, marker: { color: histColor }, name: `Count of ${col}`, ...binConfig }
              ];
              const layout = {
                paper_bgcolor: bg.paper, plot_bgcolor: bg.plot, font: { color: textColor },
                title: { text: styleTitleAndSubtitle(title, subtitle), font: { color: textColor, size: 16 } },
                xaxis: { title: { text: styleText(isHorizontal ? 'Count' : xLabel), font: { color: textColor }, standoff: 16 }, automargin: true, showgrid: advShowGrid, gridcolor: 'rgba(75,85,99,0.3)', tickfont: { color: textColor }, zerolinecolor: 'rgba(75,85,99,0.5)', showline: true, mirror: true, linecolor: 'rgba(75,85,99,0.6)', linewidth: 1 },
                yaxis: { title: { text: styleText(isHorizontal ? yLabel : 'Count'), font: { color: textColor }, standoff: 16 }, automargin: true, showgrid: advShowGrid, gridcolor: 'rgba(75,85,99,0.3)', tickfont: { color: textColor }, zerolinecolor: 'rgba(75,85,99,0.5)', showline: true, mirror: true, linecolor: 'rgba(75,85,99,0.6)', linewidth: 1 },
                margin: { l: 64, r: 24, t: (title ? 64 : 34), b: (sourceText ? 96 : 64) }
              };
              if (sourceText) {
                layout.annotations = [{ text: sourceText, x: 1, xref: 'paper', xanchor: 'right', y: VC_FOOTER_ANNOT_Y, yref: 'paper', yanchor: 'top', showarrow: false, align: 'right', font: { color: mutedAnnotationColor, size: 11 } }];
              }
              return { data: cleanupTraces(traces), layout };
            }
            if (chartType === 'box' && dtype === 'continuous') {
              throw new Error('Box Plot requires two variables (one discrete, one continuous).');
            }
            if (chartType === 'bar' && dtype === 'discrete') {
              const freq = new Map();
              data.forEach(r => { const k = String(r[col] ?? ''); freq.set(k, (freq.get(k) || 0) + 1); });
              const labels = Array.from(freq.keys());
              const values = labels.map(k => freq.get(k));
              const isHorizontal = advOrientation === 'horizontal';
              const colors = palette(paletteSel.value, labels.length);
              const trace = isHorizontal ? { type: 'bar', orientation: 'h', x: values, y: labels, name: 'Count', marker: { color: colors } }
                                        : { type: 'bar', x: labels, y: values, name: 'Count', marker: { color: colors } };
              const layout = {
                paper_bgcolor: bg.paper, plot_bgcolor: bg.plot, font: { color: textColor },
                title: { text: styleTitleAndSubtitle(title, subtitle), font: { color: textColor, size: 16 } },
                xaxis: { title: { text: styleText(xLabel), font: { color: textColor }, standoff: 16 }, automargin: true, showgrid: advShowGrid, gridcolor: 'rgba(75,85,99,0.3)', tickfont: { color: textColor }, zerolinecolor: 'rgba(75,85,99,0.5)', showline: true, mirror: true, linecolor: 'rgba(75,85,99,0.6)', linewidth: 1 },
                yaxis: { title: { text: styleText(yLabel), font: { color: textColor }, standoff: 16 }, automargin: true, showgrid: advShowGrid, gridcolor: 'rgba(75,85,99,0.3)', tickfont: { color: textColor }, zerolinecolor: 'rgba(75,85,99,0.5)', showline: true, mirror: true, linecolor: 'rgba(75,85,99,0.6)', linewidth: 1 },
                margin: { l: 64, r: 24, t: (title ? 64 : 34), b: (sourceText ? 96 : 64) }
              };
              if (sourceText) {
                layout.annotations = [{ text: sourceText, x: 1, xref: 'paper', xanchor: 'right', y: VC_FOOTER_ANNOT_Y, yref: 'paper', yanchor: 'top', showarrow: false, align: 'right', font: { color: mutedAnnotationColor, size: 11 } }];
              }
              return { data: cleanupTraces([trace]), layout };
            }
            // Fallback if mismatched type
            throw new Error('Select a valid single-variable chart for the chosen column type');
          }

          // --- Continuous Group By Binning ---
          if (legendVar && !singleMode && groupByDataType === 'continuous') {
              const bins = parseInt(document.getElementById('group-by-bins')?.value, 10) || 5;
              const values = data.map(r => parseFloat(r[legendVar])).filter(v => !isNaN(v));
              const binInfo = computeBins(values, bins);
              const labels = binInfo.labels;
              if (values.length > 0 && labels.length > 0) {
                data.forEach(row => {
                  const val = parseFloat(row[legendVar]);
                  if (isNaN(val)) { row.__legend_bin = 'N/A'; return; }
                  if (val === binInfo.max) { row.__legend_bin = labels[labels.length - 1]; return; }
                  const idx = Math.max(0, Math.min(labels.length - 1, Math.floor((val - binInfo.min) / binInfo.size)));
                  row.__legend_bin = labels[idx];
                });
                // Attach full set of labels for later use
                data.__ALL_BIN_LABELS__ = labels;
              }
          }

          // Grouping key used for legend: for continuous Group By, use the binned label
          const groupingKey = (legendVar && !singleMode) ? (groupByDataType === 'continuous' ? '__legend_bin' : legendVar) : '';

          const selX = xTypeSel?.value;
          const selY = yTypeSel?.value;
          const infX = inferType(uploadedData[0][xCol]);
          const infY = inferType(uploadedData[0][yCol]);
          const xType = selX ? (selX === 'continuous' ? 'number' : 'string') : infX;
          const yType = selY ? (selY === 'continuous' ? 'number' : 'string') : infY;

          let traces = [];
          const layoutTweaks = {};

          if (chartType === 'scatter' || (xType === 'number' && yType === 'number' && chartType !== 'bar' && chartType !== 'histogram')) {
            const isSmooth = chartType === 'smooth';
            const isLineOnly = chartType === 'line';
            const needsLine = isSmooth || isLineOnly; // sort by x for any line

            // Group by legendVar when provided (categorical)
            if (legendVar) {
              const groups = new Map();
              data.forEach(r => {
                const x = toFiniteNumber(r[xCol]);
                const y = toFiniteNumber(r[yCol]);
                if (!Number.isFinite(x) || !Number.isFinite(y)) return;
                const key = String(r[groupingKey]);
                if (!groups.has(key)) groups.set(key, []);
                groups.get(key).push({ x, y });
              });
              // Legend categories: for continuous, use all bin labels; else use present keys
              const cats = (groupByDataType === 'continuous' && Array.isArray(data.__ALL_BIN_LABELS__))
                ? data.__ALL_BIN_LABELS__
                : Array.from(groups.keys()).sort();
              const colors = palette(paletteSel.value, cats.length);
              const lineColors = palette(paletteSel.value, Math.max(cats.length + 1, 2)).slice(1, cats.length + 1);
              traces = cats.flatMap((c, idx) => {
                let pts = groups.get(c) || [];
                if (needsLine) pts = pts.sort((a,b)=>a.x-b.x);
                if (!pts.length) {
                  const base = { type: 'scatter', mode: isLineOnly ? 'lines' : (isSmooth ? 'markers' : 'markers') };
                  return [legendOnlyTrace(base, c, colors[idx])];
                }
                const markers = {
                  type: 'scatter',
                  mode: 'markers',
                  x: pts.map(p=>p.x),
                  y: pts.map(p=>p.y),
                  name: c,
                  marker: { color: colors[idx], size: 6 },
                  legendgroup: c
                };
                if (isLineOnly) {
                  // line-only chart (multiple lines per group)
                  const lineOnly = { type: 'scatter', mode: 'lines', x: pts.map(p=>p.x), y: pts.map(p=>p.y), name: c, line: { color: colors[idx], shape: 'linear' }, legendgroup: c };
                  return [lineOnly];
                }
                // For 'smooth' (scatter with trend), only return markers here.
                return [markers];
              });
              // Add a single global trend line across all groups for smooth
              if (isSmooth) {
                let allPts = Array.from(groups.values()).flat().filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
                if (allPts.length >= 2) {
                  allPts = allPts.sort((a,b)=>a.x-b.x);
                  const fit = linearRegression(allPts);
                  const lineColor = (palette(paletteSel.value, 2)[1]) || '#e5e7eb';
                  let lineTrace;
                  if (fit) {
                    lineTrace = { type: 'scatter', mode: 'lines', x: fit.x, y: fit.y, name: yCol + ' vs ' + xCol, line: { color: lineColor, shape: 'linear' }, legendgroup: 'smooth', showlegend: false };
                  } else {
                    lineTrace = { type: 'scatter', mode: 'lines', x: allPts.map(p=>p.x), y: allPts.map(p=>p.y), name: yCol + ' vs ' + xCol, line: { color: lineColor, shape: 'linear' }, legendgroup: 'smooth', showlegend: false };
                  }
                  traces.push(lineTrace);
                }
              }
            } else {
              const color = palette(paletteSel.value, 1)[0];
              const lineColor = palette(paletteSel.value, 2)[1] || color;
              let points = data.map(r => ({ x: toFiniteNumber(r[xCol]), y: toFiniteNumber(r[yCol]) }))
                                       .filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
              if (needsLine) {
                points = points.sort((a,b)=>a.x-b.x);
              }
              if (isLineOnly) {
                traces = [{ type: 'scatter', mode: 'lines', x: points.map(p=>p.x), y: points.map(p=>p.y), name: yCol + ' vs ' + xCol, line: { color, shape: 'linear' } }];
              } else if (isSmooth) {
                const markers = { type: 'scatter', mode: 'markers', x: points.map(p=>p.x), y: points.map(p=>p.y), name: yCol + ' vs ' + xCol, marker: { color, size: 6 }, legendgroup: 'smooth' };
                const fit = linearRegression(points);
                if (fit) {
                  const lineTrace = { type: 'scatter', mode: 'lines', x: fit.x, y: fit.y, name: yCol + ' vs ' + xCol, line: { color: lineColor, shape: 'linear' }, legendgroup: 'smooth', showlegend: false };
                  traces = [markers, lineTrace];
                } else {
                  // fallback to connecting points if regression cannot be computed
                  const lineTrace = { type: 'scatter', mode: 'lines', x: points.map(p=>p.x), y: points.map(p=>p.y), name: yCol + ' vs ' + xCol, line: { color: lineColor, shape: 'linear' }, legendgroup: 'smooth', showlegend: false };
                  traces = [markers, lineTrace];
                }
              } else {
                traces = [{ type: 'scatter', mode: 'markers', x: points.map(p=>p.x), y: points.map(p=>p.y), name: yCol + ' vs ' + xCol, marker: { color, size: 6 } }];
              }
            }

            // Trend line removed; advanced toggle only controls error bars where supported

          } else if (chartType === 'histogram') {
            const histBinCount = readHistogramBinCount();
            if (xType === 'string') {
              const isHorizontal = advOrientation === 'horizontal';
              if (legendVar) {
                // Bar counts of x categories, split by legend variable
                const cats = [];
                const catIndex = new Map();
                const legendVals = [];
                const legendIndex = new Map();
                const table = new Map(); // legend -> Map(cat -> count)
                data.forEach(r => {
                  const cat = String(r[xCol] ?? '');
          const lv = String(r[groupingKey] ?? '');
                  if (!catIndex.has(cat)) { catIndex.set(cat, cats.length); cats.push(cat); }
                  if (!legendIndex.has(lv)) { legendIndex.set(lv, legendVals.length); legendVals.push(lv); }
                  if (!table.has(lv)) table.set(lv, new Map());
                  const m = table.get(lv);
                  m.set(cat, (m.get(cat) || 0) + 1);
                });
                const fullLegendVals = (groupByDataType === 'continuous' && Array.isArray(data.__ALL_BIN_LABELS__))
                  ? data.__ALL_BIN_LABELS__
                  : legendVals;
                const colors = palette(paletteSel.value, fullLegendVals.length);
                const useOverlayBars = (groupByDataType === 'continuous');
                traces = fullLegendVals.map((lv, idx) => {
                  const m = table.get(lv) || new Map();
                  const ys = cats.map(c => m.get(c) || 0);
                  const base = isHorizontal
                    ? { type: 'bar', orientation: 'h', x: ys, y: cats, name: lv, marker: { color: colors[idx] }, legendgroup: lv }
                    : { type: 'bar', x: cats, y: ys, name: lv, marker: { color: colors[idx] }, legendgroup: lv };
                  if (useOverlayBars) {
                    base.opacity = 0.85;
                  } else {
                    base.offsetgroup = lv;
                  }
                  const hasAny = ys.some(v => v > 0);
                  return hasAny ? base : { ...base, visible: 'legendonly' };
                });
              } else {
                // simple frequency of x categories
                const freq = new Map();
                data.forEach(r => {
                  const k = String(r[xCol] ?? '');
                  freq.set(k, (freq.get(k) || 0) + 1);
                });
                const labels = Array.from(freq.keys());
                const values = labels.map(k => freq.get(k));
                const colors = palette(paletteSel.value, labels.length);
                traces = [
                  advOrientation === 'horizontal'
                    ? { type: 'bar', orientation: 'h', x: values, y: labels, name: 'Count', marker: { color: colors } }
                    : { type: 'bar', x: labels, y: values, name: 'Count', marker: { color: colors } }
                ];
              }
            } else if (xType === 'number') {
              // histogram of x values
              if (legendVar) {
                const byLv = new Map();
                data.forEach(r => {
          const lv = String(r[groupingKey] ?? '');
                  const v = toFiniteNumber(r[xCol]);
                  if (!Number.isFinite(v)) return;
                  if (!byLv.has(lv)) byLv.set(lv, []);
                  byLv.get(lv).push(v);
                });
                const fullLegendVals = (groupByDataType === 'continuous' && Array.isArray(data.__ALL_BIN_LABELS__))
                  ? data.__ALL_BIN_LABELS__
                  : Array.from(byLv.keys());
                const colors = palette(paletteSel.value, fullLegendVals.length);
                const orientationKey = advOrientation === 'horizontal' ? 'horizontal' : 'vertical';
                const allValues = [];
                byLv.forEach(arr => { if (Array.isArray(arr) && arr.length) allValues.push(...arr); });
                const sharedBinConfig = histogramBinConfig(allValues, histBinCount, orientationKey);
                traces = fullLegendVals.map((lv, idx) => {
                  const arr = byLv.get(lv) || [];
                  const base = advOrientation === 'horizontal'
                    ? { type: 'histogram', orientation: 'h', y: arr, nbinsy: histBinCount, name: lv, marker: { color: colors[idx] }, opacity: 0.6 }
                    : { type: 'histogram', x: arr, nbinsx: histBinCount, name: lv, marker: { color: colors[idx] }, opacity: 0.6 };
                  if (!arr.length) {
                    return { ...base, ...sharedBinConfig, visible: 'legendonly' };
                  }
                  return { ...base, ...sharedBinConfig };
                });

              } else {
                const xs = data.map(r => toFiniteNumber(r[xCol])).filter(v=>Number.isFinite(v));
                const binConfig = histogramBinConfig(xs, histBinCount, advOrientation === 'horizontal' ? 'horizontal' : 'vertical');
                traces = [
                  advOrientation === 'horizontal'
                    ? { type: 'histogram', orientation: 'h', y: xs, nbinsy: histBinCount, marker: { color: palette(paletteSel.value, 1)[0] }, name: `Count of ${xCol}`, ...binConfig }
                    : { type: 'histogram', x: xs, nbinsx: histBinCount, marker: { color: palette(paletteSel.value, 1)[0] }, name: `Count of ${xCol}`, ...binConfig }
                ];
              }
            } else if (yType === 'number') {
              // histogram of y values
              if (legendVar) {
                const byLv = new Map();
                data.forEach(r => {
          const lv = String(r[groupingKey] ?? '');
                  const v = toFiniteNumber(r[yCol]);
                  if (!Number.isFinite(v)) return;
                  if (!byLv.has(lv)) byLv.set(lv, []);
                  byLv.get(lv).push(v);
                });
                const fullLegendVals = (groupByDataType === 'continuous' && Array.isArray(data.__ALL_BIN_LABELS__))
                  ? data.__ALL_BIN_LABELS__
                  : Array.from(byLv.keys());
                const colors = palette(paletteSel.value, fullLegendVals.length);
                const orientationKey = advOrientation === 'horizontal' ? 'horizontal' : 'vertical';
                const allValues = [];
                byLv.forEach(arr => { if (Array.isArray(arr) && arr.length) allValues.push(...arr); });
                const sharedBinConfig = histogramBinConfig(allValues, histBinCount, orientationKey);
                // Note: using x for histogram dimension regardless of axis choice
                traces = fullLegendVals.map((lv, idx) => {
                  const arr = byLv.get(lv) || [];
                  const base = advOrientation === 'horizontal'
                    ? { type: 'histogram', orientation: 'h', y: arr, nbinsy: histBinCount, name: lv, marker: { color: colors[idx] }, opacity: 0.6 }
                    : { type: 'histogram', x: arr, nbinsx: histBinCount, name: lv, marker: { color: colors[idx] }, opacity: 0.6 };
                  if (!arr.length) {
                    return { ...base, ...sharedBinConfig, visible: 'legendonly' };
                  }
                  return { ...base, ...sharedBinConfig };
                });

              } else {
                const ys = data.map(r => toFiniteNumber(r[yCol])).filter(v=>Number.isFinite(v));
                const binConfig = histogramBinConfig(ys, histBinCount, advOrientation === 'horizontal' ? 'horizontal' : 'vertical');
                traces = [
                  advOrientation === 'horizontal'
                    ? { type: 'histogram', orientation: 'h', y: ys, nbinsy: histBinCount, marker: { color: palette(paletteSel.value, 1)[0] }, name: `Count of ${yCol}`, ...binConfig }
                    : { type: 'histogram', x: ys, nbinsx: histBinCount, marker: { color: palette(paletteSel.value, 1)[0] }, name: `Count of ${yCol}`, ...binConfig }
                ];
              }
            }
          } else {
            if (xType === 'number' && yType === 'number') {
              // Continuous vs Continuous
              const isScatter = (chartType === 'scatter');
              const isLine = (chartType === 'line' || chartType === 'smooth');
              const lineShape = (chartType === 'smooth') ? 'linear' : 'linear';

              if (legendVar) {
                // Color-coded points/lines per group
                const byLv = new Map();
                data.forEach(r => {
                  const lv = String(r[groupingKey] ?? '');
                  const x = toFiniteNumber(r[xCol]);
                  const y = toFiniteNumber(r[yCol]);
                  if (!Number.isFinite(x) || !Number.isFinite(y)) return;
                  if (!byLv.has(lv)) byLv.set(lv, []);
                  byLv.get(lv).push({ x, y });
                });
                const fullLegendVals = (groupByDataType === 'continuous' && Array.isArray(data.__ALL_BIN_LABELS__))
                  ? data.__ALL_BIN_LABELS__
                  : Array.from(byLv.keys());
                const colors = palette(paletteSel.value, fullLegendVals.length);
                const lineColors = palette(paletteSel.value, Math.max(fullLegendVals.length + 1, 2)).slice(1, fullLegendVals.length + 1);
                traces = fullLegendVals.flatMap((lv, idx) => {
                  const pts = (byLv.get(lv) || [])
                    .filter(p => Number.isFinite(p.x) && Number.isFinite(p.y))
                    .sort((a,b)=>a.x-b.x);
                  if (!pts.length) {
                    // Legend-only stub when a bin/category has no points
                    return [legendOnlyTrace({ type: 'scatter', mode: isScatter ? 'markers' : 'lines' }, lv, colors[idx])];
                  }
                  if (isScatter) {
                    return [{ type: 'scatter', mode: 'markers', x: pts.map(p=>p.x), y: pts.map(p=>p.y), name: lv, marker: { color: colors[idx], size: 6 }, legendgroup: lv }];
                  } else {
                    if (chartType === 'smooth') {
                      const markers = { type: 'scatter', mode: 'markers', x: pts.map(p=>p.x), y: pts.map(p=>p.y), name: lv, marker: { color: colors[idx], size: 6 }, legendgroup: lv };
                      // For 'smooth', return only markers here; add one global trend line after.
                      return [markers];
                    }
                    return [{ type: 'scatter', mode: 'lines', x: pts.map(p=>p.x), y: pts.map(p=>p.y), name: lv, line: { color: colors[idx], shape: 'linear' }, legendgroup: lv }];
                  }
                });
                // Add a single global trend line across all groups for smooth
                if (chartType === 'smooth') {
                  let allPts = Array.from(byLv.values()).flat().filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
                  if (allPts.length >= 2) {
                    allPts = allPts.sort((a,b)=>a.x-b.x);
                    const fit = linearRegression(allPts);
                    const lineColor = (palette(paletteSel.value, 2)[1]) || palette(paletteSel.value, 1)[0];
                    const line = fit
                      ? { type: 'scatter', mode: 'lines', x: fit.x, y: fit.y, name: yCol, line: { color: lineColor, shape: 'linear' }, legendgroup: 'smooth', showlegend: false }
                      : { type: 'scatter', mode: 'lines', x: allPts.map(p=>p.x), y: allPts.map(p=>p.y), name: yCol, line: { color: lineColor, shape: 'linear' }, legendgroup: 'smooth', showlegend: false };
                    traces.push(line);
                  }
                }
              } else {
                // Single series (no group): either markers or line
                const pts = data.map(r => ({ x: toFiniteNumber(r[xCol]), y: toFiniteNumber(r[yCol]) }))
                                .filter(p => Number.isFinite(p.x) && Number.isFinite(p.y))
                                .sort((a,b)=>a.x-b.x);
                const color = palette(paletteSel.value, 1)[0];
                const lineColor = palette(paletteSel.value, 2)[1] || color;
                if (chartType === 'smooth') {
                  const markers = { type: 'scatter', mode: 'markers', x: pts.map(p=>p.x), y: pts.map(p=>p.y), name: yCol, marker: { color, size: 6 }, legendgroup: 'smooth' };
                  const fit = linearRegression(pts);
                  if (fit) {
                    const line = { type: 'scatter', mode: 'lines', x: fit.x, y: fit.y, name: yCol, line: { color: lineColor, shape: 'linear' }, legendgroup: 'smooth', showlegend: false };
                    traces = [markers, line];
                  } else {
                    const line = { type: 'scatter', mode: 'lines', x: pts.map(p=>p.x), y: pts.map(p=>p.y), name: yCol, line: { color: lineColor, shape: 'linear' }, legendgroup: 'smooth', showlegend: false };
                    traces = [markers, line];
                  }
                } else if (isScatter) {
                  traces = [{ type: 'scatter', mode: 'markers', x: pts.map(p=>p.x), y: pts.map(p=>p.y), name: yCol, marker: { color, size: 6 } }];
                } else {
                  traces = [{ type: 'scatter', mode: 'lines',   x: pts.map(p=>p.x), y: pts.map(p=>p.y), name: yCol, line: { color, shape: lineShape } }];
                }
              }
            } else {
              // One discrete, one numeric
              if (chartType === 'box' || chartType === 'violin' || chartType === 'strip' || chartType === 'jitter') {
                const isXCat = xType === 'string';
                const catCol = isXCat ? xCol : yCol;
                const numCol = isXCat ? yCol : xCol;

                // If value axis is naturally nonnegative and chart is box/violin, anchor axis at 0
                try {
                  if ((chartType === 'box' || chartType === 'violin') && isNonNegativeColumn(numCol)) {
                    if (isXCat) {
                      // numeric on Y
                      layoutTweaks.yaxis = { ...(layoutTweaks.yaxis || {}), rangemode: 'tozero' };
                    } else {
                      // numeric on X
                      layoutTweaks.xaxis = { ...(layoutTweaks.xaxis || {}), rangemode: 'tozero' };
                    }
                  }
                } catch(_) {}

                if (legendVar) {
                  // Split by legend variable across categories
                  const cats = [];
                  const catIndex = new Map();
                  const legendVals = [];
                  const legendIndex = new Map();
                  const byLv = new Map();
                  data.forEach(r => {
                    const cat = String(r[catCol]);
                    const v = toFiniteNumber(r[numCol]);
                    if (!Number.isFinite(v)) return;
                    if (!catIndex.has(cat)) { catIndex.set(cat, cats.length); cats.push(cat); }
          const lv = String(r[groupingKey]);
                    if (!legendIndex.has(lv)) { legendIndex.set(lv, legendVals.length); legendVals.push(lv); }
                    if (!byLv.has(lv)) byLv.set(lv, []);
                    byLv.get(lv).push({ cat, val: v });
                  });
                  const fullLegendVals = (groupByDataType === 'continuous' && Array.isArray(data.__ALL_BIN_LABELS__))
                    ? data.__ALL_BIN_LABELS__
                    : legendVals;
                  const colors = palette(paletteSel.value, fullLegendVals.length);
                  traces = fullLegendVals.map((lv, idx) => {
                    const rows = byLv.get(lv) || [];
                    if (!rows.length) {
                      // Use a legend-only scatter as a proxy entry
                      return legendOnlyTrace({ type: 'scatter', mode: 'markers' }, lv, colors[idx]);
                    }
                    if (chartType === 'box') {
                      if (isXCat) {
                        return { type: 'box', name: lv, x: rows.map(r=>r.cat), y: rows.map(r=>r.val), marker: { color: colors[idx] }, boxpoints: 'outliers', offsetgroup: lv, legendgroup: lv };
                      } else {
                        return { type: 'box', name: lv, y: rows.map(r=>r.cat), x: rows.map(r=>r.val), marker: { color: colors[idx] }, boxpoints: 'outliers', orientation: 'h', offsetgroup: lv, legendgroup: lv };
                      }
                    } else if (chartType === 'violin') {
                      const forceNonNeg = isNonNegativeColumn(numCol);
                      if (isXCat) {
                        const obj = { type: 'violin', name: lv, x: rows.map(r=>r.cat), y: rows.map(r=>r.val), fillcolor: colors[idx], line: { color: colors[idx] }, points: 'suspectedoutliers', offsetgroup: lv, legendgroup: lv };
                        if (forceNonNeg) obj.spanmode = 'hard';
                        return obj;
                      } else {
                        const obj = { type: 'violin', name: lv, y: rows.map(r=>r.cat), x: rows.map(r=>r.val), fillcolor: colors[idx], line: { color: colors[idx] }, orientation: 'h', points: 'suspectedoutliers', offsetgroup: lv, legendgroup: lv };
                        if (forceNonNeg) obj.spanmode = 'hard';
                        return obj;
                      }
                    } else {
                      // strip or jitter
                      const jitterAmp = chartType === 'jitter' ? 0.25 : 0;
                      if (isXCat) {
                        if (chartType === 'jitter') {
                          const xs = rows.map(({cat}) => catIndex.has(cat) ? (catIndex.get(cat) + (Math.random()*2-1)*jitterAmp) : NaN);
                          const ys = rows.map(r=>r.val);
                          layoutTweaks.xaxis = { tickmode: 'array', tickvals: cats.map((_,i)=>i), ticktext: cats, range: [-0.6, cats.length-0.4] };
                          return { type: 'scatter', mode: 'markers', x: xs, y: ys, name: lv, marker: { color: colors[idx], size: 6 }, offsetgroup: lv, legendgroup: lv };
                        } else {
                          const xs = rows.map((r) => {
                            const cat = r.cat;
                            const base = catIndex.get(cat);
                            const catRows = rows.filter(rr => rr.cat === cat);
                            const sortedVals = catRows.map(rr => rr.val).sort((a,b)=>a-b);
                            const idx = sortedVals.indexOf(r.val);
                            const n = catRows.length;
                            const spacing = n > 1 ? 0.8 / (n - 1) : 0;
                            return base + (idx - (n-1)/2) * spacing;
                          });
                          const ys = rows.map(r=>r.val);
                          layoutTweaks.xaxis = { tickmode: 'array', tickvals: cats.map((_,i)=>i), ticktext: cats, range: [-0.6, cats.length-0.4] };
                          return { type: 'scatter', mode: 'markers', x: xs, y: ys, name: lv, marker: { color: colors[idx], size: 6 }, offsetgroup: lv, legendgroup: lv };
                        }
                      } else {
                        if (chartType === 'jitter') {
                          const ys = rows.map(({cat}) => catIndex.has(cat) ? (catIndex.get(cat) + (Math.random()*2-1)*jitterAmp) : NaN);
                          const xs = rows.map(r=>r.val);
                          layoutTweaks.yaxis = { tickmode: 'array', tickvals: cats.map((_,i)=>i), ticktext: cats, range: [-0.6, cats.length-0.4] };
                          return { type: 'scatter', mode: 'markers', x: xs, y: ys, name: lv, marker: { color: colors[idx], size: 6 }, offsetgroup: lv, legendgroup: lv };
                        } else {
                          const ys = rows.map((r) => {
                            const cat = r.cat;
                            const base = catIndex.get(cat);
                            const catRows = rows.filter(rr => rr.cat === cat);
                            const sortedVals = catRows.map(rr => rr.val).sort((a,b)=>a-b);
                            const idx = sortedVals.indexOf(r.val);
                            const n = catRows.length;
                            const spacing = n > 1 ? 0.8 / (n - 1) : 0;
                            return base + (idx - (n-1)/2) * spacing;
                          });
                          const xs = rows.map(r=>r.val);
                          layoutTweaks.yaxis = { tickmode: 'array', tickvals: cats.map((_,i)=>i), ticktext: cats, range: [-0.6, cats.length-0.4] };
                          return { type: 'scatter', mode: 'markers', x: xs, y: ys, name: lv, marker: { color: colors[idx], size: 6 }, offsetgroup: lv, legendgroup: lv };
                        }
                      }
                    }
                  });
                } else {
                  // Original: group by category only
                  const groups = new Map();
                  data.forEach(r => {
                    const c = String(r[catCol]);
                    const v = toFiniteNumber(r[numCol]);
                    if (!Number.isFinite(v)) return;
                    if (!groups.has(c)) groups.set(c, []);
                    groups.get(c).push(v);
                  });
                  const cats = Array.from(groups.keys());
                  const colors = palette(paletteSel.value, cats.length);
                  traces = cats.map((c, idx) => {
                    const vals = groups.get(c);
                    if (chartType === 'box') {
                      return isXCat
                        ? { type: 'box', name: c, x: Array(vals.length).fill(c), y: vals, marker: { color: colors[idx] }, boxpoints: 'outliers' }
                        : { type: 'box', name: c, y: Array(vals.length).fill(c), x: vals, marker: { color: colors[idx] }, boxpoints: 'outliers', orientation: 'h' };
                    } else if (chartType === 'violin') {
                      const forceNonNeg = isNonNegativeColumn(numCol);
                      if (isXCat) {
                        const obj = { type: 'violin', name: c, x: Array(vals.length).fill(c), y: vals, fillcolor: colors[idx], line: { color: colors[idx] }, points: 'suspectedoutliers' };
                        if (forceNonNeg) obj.spanmode = 'hard';
                        return obj;
                      } else {
                        const obj = { type: 'violin', name: c, y: Array(vals.length).fill(c), x: vals, fillcolor: colors[idx], line: { color: colors[idx] }, orientation: 'h', points: 'suspectedoutliers' };
                        if (forceNonNeg) obj.spanmode = 'hard';
                        return obj;
                      }
                    } else {
                      // strip or jitter
                      const jitterAmp = chartType === 'jitter' ? 0.25 : 0;
                      if (isXCat) {
                        const xi = cats.indexOf(c);
                        if (chartType === 'jitter') {
                          const xs = vals.map(() => xi + (Math.random()*2-1)*jitterAmp);
                          layoutTweaks.xaxis = { tickmode: 'array', tickvals: cats.map((_,i)=>i), ticktext: cats, range: [-0.6, cats.length-0.4] };
                          return { type: 'scatter', mode: 'markers', x: xs, y: vals, name: c, marker: { color: colors[idx], size: 6 } };
                        } else {
                          const valsSorted = [...vals].sort((a,b)=>a-b);
                          const n = valsSorted.length;
                          const spacing = n > 1 ? 0.8 / (n - 1) : 0;
                          const xs = valsSorted.map((_, i) => xi + (i - (n-1)/2) * spacing);
                          layoutTweaks.xaxis = { tickmode: 'array', tickvals: cats.map((_,i)=>i), ticktext: cats, range: [-0.6, cats.length-0.4] };
                          return { type: 'scatter', mode: 'markers', x: xs, y: valsSorted, name: c, marker: { color: colors[idx], size: 6 } };
                        }
                      } else {
                        const yiIndex = cats.indexOf(c);
                        if (chartType === 'jitter') {
                          const ys = vals.map(() => yiIndex + (Math.random()*2-1)*jitterAmp);
                          layoutTweaks.yaxis = { tickmode: 'array', tickvals: cats.map((_,i)=>i), ticktext: cats, range: [-0.6, cats.length-0.4] };
                          return { type: 'scatter', mode: 'markers', x: vals, y: ys, name: c, marker: { color: colors[idx], size: 6 } };
                        } else {
                          const valsSorted = [...vals].sort((a,b)=>a-b);
                          const n = valsSorted.length;
                          const spacing = n > 1 ? 0.8 / (n - 1) : 0;
                          const ys = valsSorted.map((_, i) => yiIndex + (i - (n-1)/2) * spacing);
                          layoutTweaks.yaxis = { tickmode: 'array', tickvals: cats.map((_,i)=>i), ticktext: cats, range: [-0.6, cats.length-0.4] };
                          return { type: 'scatter', mode: 'markers', x: valsSorted, y: ys, name: c, marker: { color: colors[idx], size: 6 } };
                        }
                      }
                    }
                  });
                }
                // categorical axis tick labels handled above when needed
              } else {
                // Default bar for category -> value
                // FIX: Orientation now respects ONLY the user's explicit selection (adv-orientation)
                // and no longer auto-flips based on which axis is categorical.
                const isXCat = xType === 'string';
                const isYCat = yType === 'string';
                // Determine which column is categorical / numeric irrespective of orientation
                const categoryCol = isXCat ? xCol : (isYCat ? yCol : xCol); // fallback to xCol if both numeric/categorical
                const valueCol    = (categoryCol === xCol) ? yCol : xCol;
                const isHorizontal = (advOrientation === 'horizontal');
                // For downstream logic keep catCol/valCol names (category & value)
                const catCol = categoryCol;
                const valCol = valueCol;

                if (legendVar) {
                  // Grouped bars by legend variable
                  const cats = [];
                  const catIndex = new Map();
                  const legendVals = [];
                  const legendIndex = new Map();
                  // Map: legend -> Map(cat -> array of values)
                  const valuesByGroup = new Map();
                  data.forEach(r => {
                    const cat = String(r[catCol]);
                    const v = toFiniteNumber(r[valCol]);
                    if (!Number.isFinite(v)) return;
                    if (!catIndex.has(cat)) { catIndex.set(cat, cats.length); cats.push(cat); }
                    const lv = String(r[groupingKey] ?? '');
                    if (!legendIndex.has(lv)) { legendIndex.set(lv, legendVals.length); legendVals.push(lv); }
                    if (!valuesByGroup.has(lv)) valuesByGroup.set(lv, new Map());
                    const m = valuesByGroup.get(lv);
                    if (!m.has(cat)) m.set(cat, []);
                    m.get(cat).push(v);
                  });
                  const fullLegendVals = (groupByDataType === 'continuous' && Array.isArray(data.__ALL_BIN_LABELS__))
                    ? data.__ALL_BIN_LABELS__
                    : legendVals;
                  const colors = palette(paletteSel.value, fullLegendVals.length);
                  const useErrors = !!advTrendToggle; // toggle controls error bars
                  traces = fullLegendVals.map((lv, idx) => {
                    const m = valuesByGroup.get(lv) || new Map();
                    // Build means and std per category in fixed order
                    const valsPerCat = cats.map(c => m.get(c) || []);
                    const means = valsPerCat.map(arr => arr.length ? (arr.reduce((a,b)=>a+b,0)/arr.length) : 0);
                    const stds  = valsPerCat.map((arr, i) => {
                      if (!arr.length) return 0;
                      const mean = means[i];
                      const sq = arr.map(v => (v-mean)*(v-mean));
                      return Math.sqrt(sq.reduce((a,b)=>a+b,0)/arr.length);
                    });
                    const base = isHorizontal
                      ? { type: 'bar', orientation: 'h', x: means, y: cats, name: lv, marker: { color: colors[idx] }, legendgroup: lv, opacity: 0.85 }
                      : { type: 'bar', x: cats, y: means, name: lv, marker: { color: colors[idx] }, legendgroup: lv, opacity: 0.85 };
                    if (useErrors) {
                      const err = { type: 'data', array: stds, visible: true, color: '#9ca3af' };
                      if (isHorizontal) base.error_x = err; else base.error_y = err;
                    }
                    const hasAny = means.some(v => Number.isFinite(v) && v !== 0);
                    return hasAny ? base : { ...base, visible: 'legendonly' };
                  });
                } else if (advTrendToggle) {
                  // Error bars without grouping: mean ± SD per category
                  const groups = new Map();
                  data.forEach(r => {
                    const cat = String(r[catCol]);
                    const val = parseFloat(r[valCol]);
                    if (isNaN(val)) return;
                    if (!groups.has(cat)) groups.set(cat, []);
                    groups.get(cat).push(val);
                  });

                  const cats = Array.from(groups.keys());
                  // Only show error bars when categories have duplicates (at least one group with n>1)
                  const hasAnyDuplicate = cats.some(c => (groups.get(c)?.length || 0) > 1);
                  if (!hasAnyDuplicate) {
                    const labels = data.map(r => String(r[catCol]));
                    const values = data.map(r => toFiniteNumber(r[valCol]));
                    const colors = palette(paletteSel.value, values.length);
                    traces = isHorizontal
                      ? [{ type: 'bar', orientation: 'h', x: values, y: labels, name: valCol, marker: { color: colors } }]
                      : [{ type: 'bar', x: labels, y: values, name: valCol, marker: { color: colors } }];
                    
                  } else {
                  const means = cats.map(c => {
                    const vals = groups.get(c);
                    return vals.reduce((a, b) => a + b, 0) / vals.length;
                  });
                  const stdDevs = cats.map(c => {
                    const vals = groups.get(c);
                    const mean = means[cats.indexOf(c)];
                    const sqDiffs = vals.map(v => Math.pow(v - mean, 2));
                    return Math.sqrt(sqDiffs.reduce((a, b) => a + b, 0) / vals.length);
                  });
                  const colors = palette(paletteSel.value, cats.length);
                  const errorBars = { type: 'data', array: stdDevs, visible: true, color: '#9ca3af' };
                  traces = [
                    isHorizontal
                      ? { type: 'bar', orientation: 'h', x: means, y: cats, name: valCol, marker: { color: colors }, error_x: errorBars }
                      : { type: 'bar', x: cats, y: means, name: valCol, marker: { color: colors }, error_y: errorBars }
                  ];
                  }
                } else {
                  // Simple bar chart without grouping / error bars
                  const labels = data.map(r => String(r[catCol]));
                  const values = data.map(r => toFiniteNumber(r[valCol]));
                  const colors = palette(paletteSel.value, values.length);
                  traces = isHorizontal
                    ? [{ type: 'bar', orientation: 'h', x: values, y: labels, name: valCol, marker: { color: colors } }]
                    : [{ type: 'bar', x: labels, y: values, name: valCol, marker: { color: colors } }];
                }
              }
            }
          }

          // Legend position anchors; orientation chosen by user
          const legendAnchorMap = {
            // Anchor above the plot area so the box grows upward, not into the chart
            'Top Right':    { x: 1,    xanchor: 'right', y: 1.08, yanchor: 'bottom' },
            'Top Left':     { x: 0,    xanchor: 'left',  y: 1.08, yanchor: 'bottom' },
            'Right':        { x: 1,    xanchor: 'right', y: 0.5,  yanchor: 'middle' },
            'Left':         { x: 0,    xanchor: 'left',  y: 0.5,  yanchor: 'middle' },
            'Outside Chart':{ x: 1.02, xanchor: 'left',  y: 1,    yanchor: 'top' },
          };
          const legendAnchor = legendAnchorMap[legendPosStr] || legendAnchorMap['Top Right'];

          // Legend trace ordering handling
          if (legendOrder === 'Alphabetical') {
            // Sort by trace name if available
            traces = [...traces].sort((a, b) => String(a?.name || '').localeCompare(String(b?.name || '')));
          }
          const traceorder = (legendOrder === 'Reversed') ? 'reversed' : 'normal';

          const topLegendSelected = (legendPosStr === 'Top Right' || legendPosStr === 'Top Left');
          const titleY = (showLegend && topLegendSelected) ? 0.955 : 0.98;

          const layout = {
            paper_bgcolor: bg.paper,
            plot_bgcolor: bg.plot,
            font: { color: textColor },
            // legend fields will be conditionally appended below when enabled
            title: { text: styleTitleAndSubtitle(title, subtitle), font: { color: textColor, size: 16 }, y: titleY, yanchor: 'top' },
            xaxis: { title: { text: styleText(xLabel), font: { color: textColor }, standoff: 16 }, automargin: true, showgrid: advShowGrid, gridcolor: 'rgba(75,85,99,0.3)', tickfont: { color: textColor }, zerolinecolor: 'rgba(75,85,99,0.5)', showline: true, mirror: true, linecolor: 'rgba(75,85,99,0.6)', linewidth: 1, ...(layoutTweaks.xaxis||{}) },
            yaxis: { title: { text: styleText(yLabel), font: { color: textColor }, standoff: 16 }, automargin: true, showgrid: advShowGrid, gridcolor: 'rgba(75,85,99,0.3)', tickfont: { color: textColor }, zerolinecolor: 'rgba(75,85,99,0.5)', showline: true, mirror: true, linecolor: 'rgba(75,85,99,0.6)', linewidth: 1, ...(layoutTweaks.yaxis||{}) },
            // When legend is on the right, give equal L/R margins to keep plot centered
            margin: {
              l: (showLegend && legendPosStr === 'Outside Chart' ? 160 : 64),
              r: (showLegend && legendPosStr === 'Outside Chart' ? 160 : 24),
              // Dynamic top margin: add proportional space for wrapped top legend rows.
              // Rationale: A single legend row needs ~26px (previous static value). Additional
              // rows (caused by > ~6 items) require roughly 22-28px each depending on font/spacing.
              // We conservatively allocate 25px per potential extra row to avoid overlap while
              // minimizing excess whitespace.
              // Heuristic: assume about 6 legend items fit per row in horizontal top legend.
              // rows = ceil(itemCount / 6). Extra top padding = baseSingleRow (26) + (rows-1)*25.
              // If legend not top or hidden, no extra space is added.
              t: (function(){
                const base = (title ? 64 : 34);
                if (!(showLegend && topLegendSelected)) return base;
                try {
                  // Determine legend item count from traces if available in outer scope (traces variable defined above).
                  let itemCount = Array.isArray(traces) ? traces.filter(t=> t && t.name !== undefined && t.showlegend !== false).length : 0;
                  // Fallback: if no named traces, attempt to infer from legendVar categories computed earlier.
                  if (!itemCount && legendVar && categories) itemCount = categories.length;
                  if (!itemCount) return base + 26; // preserve previous behavior when unknown
                  const perRow = 6; // heuristic items per row
                  const rows = Math.max(1, Math.ceil(itemCount / perRow));
                  const extra = 26 + (rows - 1) * 25; // 26 for first row + 25 each additional
                  return base + extra;
                } catch(_){
                  return base + 26;
                }
              })(),
              b: (sourceText ? 96 : 64)
            },
          };

          // Modes for grouped charts when legend variable is used
          if (legendVar) {
            if (chartType === 'bar') {
              // Use overlay so bar width stays constant when grouped
              layout.barmode = 'overlay';
            }
            if (chartType === 'histogram') {
              layout.barmode = 'overlay';
            }
            if (chartType === 'box') layout.boxmode = 'group';
            if (chartType === 'violin') layout.violinmode = 'group';
          }

      // Only include legend configuration when explicitly enabled
      // If Group By is continuous and no legend title provided, default to "<var> (<bins> bins)"
      const legendTitleFinal = legendTitle || (legendVar && groupByDataType === 'continuous' ? `${legendVar} (${parseInt(document.getElementById('group-by-bins')?.value, 10) || 5} bins)` : '');
      if (showLegend) {
            layout.showlegend = true;
            layout.legend = {
              ...legendAnchor,
              bgcolor: bg.paper,
              font: { color: textColor },
              traceorder,
              // Use horizontal legend when placed at the top to avoid overlap
              orientation: (legendPosStr === 'Top Right' || legendPosStr === 'Top Left') ? 'h' : 'v',
              title: legendTitleFinal ? { text: styleText(legendTitleFinal) } : undefined,
              bordercolor: legendBorder ? '#4b5563' : undefined,
              borderwidth: legendBorder ? 1 : 0,
            };
          } else {
            layout.showlegend = false;
            delete layout.legend;
          }

      if (sourceText) {
            layout.annotations = [
              {
                text: sourceText,
                x: 1,
                xref: 'paper',
                xanchor: 'right',
  y: VC_FOOTER_ANNOT_Y,
                yref: 'paper',
                yanchor: 'top',
                showarrow: false,
                align: 'right',
                font: { color: mutedAnnotationColor, size: 11 }
              }
            ];
          }

          return { data: cleanupTraces(traces), layout };
        }

        function jsCodeFromConfig(cfg) {
          try {
            const dataStr = JSON.stringify(cfg.data, null, 2);
            const layoutStr = JSON.stringify(cfg.layout, null, 2);
            const suggested = (window.VC_LAST_FILE && window.VC_LAST_FILE.name) ? window.VC_LAST_FILE.name : 'your_data.csv';
            const fileStr = JSON.stringify(suggested);
            
            // Smart watermark positioning: opposite side of source text
            const sourceText = document.getElementById('source-text')?.value || '';
            let watermarkX = 1;
            let watermarkXAnchor = 'right';
            const watermarkY = VC_FOOTER_ANNOT_Y; // unified footer annotation position

            if (sourceText) {
              // Try to detect source annotation within cfg.layout
              const anns = Array.isArray(cfg?.layout?.annotations) ? cfg.layout.annotations : [];
              const srcAnn = anns.find(a => typeof a?.text === 'string' && a.text === sourceText);
              if (srcAnn) {
                // Determine side by anchor/x
                const srcIsRight = (String(srcAnn.xanchor).toLowerCase() === 'right') || (typeof srcAnn.x === 'number' && srcAnn.x >= 0.5);
                if (srcIsRight) { // source on right -> watermark on left
                  watermarkX = 0; watermarkXAnchor = 'left';
                } else { // source on left -> watermark on right
                  watermarkX = 1; watermarkXAnchor = 'right';
                }
              } else {
                // Fallback: in our generated layouts, source defaults to right
                watermarkX = 0; watermarkXAnchor = 'left';
              }
            }
            
            // Add watermark to layout
            const layoutWithWatermark = { ...cfg.layout };
            if (!layoutWithWatermark.annotations) {
              layoutWithWatermark.annotations = [];
            }
            layoutWithWatermark.annotations.push({
              text: "Vegachart.com",
              showarrow: false,
              x: watermarkX,
              y: watermarkY,
              xref: "paper",
              yref: "paper",
              xanchor: watermarkXAnchor,
              yanchor: "top",
              font: { size: 10, color: "#9ca3af" },
              bgcolor: "rgba(0,0,0,0)",
              bordercolor: "rgba(0,0,0,0)"
            });
            
            const finalLayoutStr = JSON.stringify(layoutWithWatermark, null, 2);
            return `// JavaScript (Plotly.js)\n// Load data (CSV) and plot\nconst file = ${fileStr};\n\nasync function csvToJSON(url) {\n  const res = await fetch(url);\n  const text = await res.text();\n  const lines = text.split(/\\r?\\n/).filter(l => l.trim().length);\n  if (lines.length === 0) return [];\n  const delimiter = text.includes('\t') ? '\t' : ',';\n  const parseLine = (line) => {\n    const result = [];\n    let cur = '', inQuotes = false;\n    for (let i = 0; i < line.length; i++) {\n      const ch = line[i];\n      if (ch === '"') {\n        if (inQuotes && line[i+1] === '"') { cur += '"'; i++; }\n        else { inQuotes = !inQuotes; }\n      } else if (!inQuotes && ch === delimiter) {\n        result.push(cur); cur = '';\n      } else {\n        cur += ch;\n      }\n    }\n    result.push(cur);\n    return result;\n  };\n  const header = parseLine(lines[0]).map(h => h.trim());\n  return lines.slice(1).map(l => {\n    const cells = parseLine(l);\n    const obj = {};\n    header.forEach((h, i) => { obj[h] = cells[i]; });\n    return obj;\n  });\n}\n\n// Ensure adequate margin padding for watermark and annotations\nfunction ensureAnnotationPadding(layout, dims = {}) {\n  try {\n    if (!layout || typeof layout !== 'object') return layout;\n    const annotations = Array.isArray(layout.annotations) ? layout.annotations : [];\n    if (!annotations.length) return layout;\n    const margin = (layout.margin && typeof layout.margin === 'object') ? { ...layout.margin } : {};\n    let changed = false;\n    const usableHeight = Math.max(360, Number.isFinite(dims?.contextHeight) ? dims?.contextHeight : 0);\n    const usableWidth = Math.max(480, Number.isFinite(dims?.contextWidth) ? dims?.contextWidth : 0);\n    const fallbackMargin = { l: 64, r: 32, t: 64, b: 64 };\n    const ensureSide = (side, required) => {\n      const base = margin[side] !== undefined ? margin[side] : fallbackMargin[side];\n      const target = Math.max(base, required);\n      if (target !== base) { margin[side] = target; changed = true; }\n    };\n    for (const ann of annotations) {\n      if (!ann || ann.visible === false) continue;\n      const fontSize = typeof ann?.font?.size === 'number' ? ann.font.size : 12;\n      const pad = fontSize + 6;\n      const x = typeof ann?.x === 'number' ? ann.x : null;\n      const y = typeof ann?.y === 'number' ? ann.y : null;\n      const xref = String(ann?.xref || 'paper').toLowerCase();\n      const yref = String(ann?.yref || 'paper').toLowerCase();\n      if (yref === 'paper' && y !== null) {\n        if (y < 0) { const needed = pad + Math.round(-y * usableHeight); ensureSide('b', needed); }\n        else if (y > 1) { const needed = pad + Math.round((y - 1) * usableHeight); ensureSide('t', needed); }\n      }\n      if (xref === 'paper' && x !== null) {\n        if (x < 0) { const needed = pad + Math.round(-x * usableWidth); ensureSide('l', needed); }\n        else if (x > 1) { const needed = pad + Math.round((x - 1) * usableWidth); ensureSide('r', needed); }\n      }\n    }\n    if (changed) { layout.margin = { ...layout.margin, ...margin }; }\n    return layout;\n  } catch (_) { return layout; }\n}\n\nconst rows = await csvToJSON(file);\n// Build Plotly traces from your rows as needed.\n// The following 'data' and 'layout' are auto-generated arrays based on your current selection.\nconst data = ${dataStr};\nlet layout = ${finalLayoutStr};\n\n// Apply padding for annotations including watermark\nconst chartCanvas = document.getElementById('chartCanvas');\nlayout = ensureAnnotationPadding(layout, {\n  contextWidth: chartCanvas?.clientWidth || 480,\n  contextHeight: chartCanvas?.clientHeight || 360\n});\n\nconst config = { responsive: true, displayModeBar: false, displaylogo: false, showTips: false };\nPlotly.newPlot('chartCanvas', data, layout, config);`;
          } catch (_) {
            return "// JavaScript (Plotly.js)\n// Code unavailable for this configuration.";
          }
        }

        // --- Python code generation (Seaborn/Matplotlib) ---
        let autoPyCode = '';

        function pyDefaultTemplate() {
          const suggested = (window.VC_LAST_FILE && window.VC_LAST_FILE.name) ? window.VC_LAST_FILE.name : 'your_data.csv';
          return [
            '# Python (Seaborn)',
            '# pip install seaborn matplotlib pandas',
            'import seaborn as sns',
            'import matplotlib.pyplot as plt',
            'import pandas as pd',
            '',
            "# Load your data (update the file path as needed)",
            `df = pd.read_csv('${suggested}')`,
            '',
            "# Theme",
            "sns.set_theme(style='darkgrid')",
            '',
            '# Example:',
            "# sns.barplot(data=df, x='x_col', y='y_col', palette='viridis')",
            '# plt.title("Chart Title")',
            '# plt.xlabel("X Label"); plt.ylabel("Y Label")',
            '# plt.tight_layout(); plt.show()'
          ].join('\n');
        }

        function escapePyStr(s) {
          try { return String(s).replace(/\\/g, "\\\\").replace(/'/g, "\\'"); } catch(_) { return ''; }
        }

        function getSeabornPaletteName() {
          const paletteSel = document.getElementById('color-palette');
          const name = paletteSel?.value || '';
          if (!name || name === 'Vega Chart') return null; // keep seaborn defaults for custom palette
          if (name === 'Pastel') return 'pastel';
          if (name === 'Default') return 'deep';
          if (name === 'ColorBlind') return 'colorblind';
          if (name === 'Gradient') {
            const gs = document.getElementById('gradient-select');
            const inv = document.getElementById('gradient-invert');
            const key = gs?.value || '';
            const cmapMap = {
              'grayscale': 'Greys',
              'red': 'Reds',
              'green': 'Greens',
              'blue': 'Blues',
              'orange': 'Oranges',
              'green-blue': 'GnBu',
              'yellow-green': 'YlGn',
              'orange-red': 'OrRd',
              'red-purple': 'RdPu'
            };
            let base = cmapMap[key] || 'viridis';
            if (inv && inv.checked) base = base + '_r';
            return base;
          }
          return null;
        }

        function pyCodeFromInputs() {
          const xColRaw = xAxisSelect?.value || '';
          const yColRaw = yAxisSelect?.value || '';
          // Filter out single variable placeholder values
          const xCol = (xColRaw === SINGLE_VAR_OPTION_VALUE) ? '' : xColRaw;
          const yCol = (yColRaw === SINGLE_VAR_OPTION_VALUE) ? '' : yColRaw;
          const typeSel = document.getElementById('chart-type');
          const showLegend = !!document.getElementById('show-legend')?.checked;
          const legendTitle = document.getElementById('legend-title')?.value || '';
          const legendPos = document.getElementById('legend-position')?.value || 'Top Right';
          // Prefer new Group By selection; fall back to legacy Legend Variable
          let legendVar = document.getElementById('group-by')?.value || document.getElementById('legend-variable')?.value || '';
          const legendOrder = document.getElementById('legend-order')?.value || 'Normal';
          const legendBorder = document.getElementById('legend-border')?.checked || false;
          const title = document.getElementById('chart-title')?.value || '';
          const subtitle = document.getElementById('chart-subtitle')?.value || '';
          const xLabel = document.getElementById('x-axis-label')?.value || '';
          const yLabel = document.getElementById('y-axis-label')?.value || '';
          const sourceText = document.getElementById('source-text')?.value || '';
          const advOrientation = document.querySelector('input[name="adv-orientation"]:checked')?.value || 'vertical';
          // Group By data type and bins (for continuous binning -> legend bins)
          const groupBySelEl = document.getElementById('group-by');
          const selGroupByOpt = groupBySelEl ? groupBySelEl.options[groupBySelEl.selectedIndex] : null;
          const groupByDataType = selGroupByOpt ? selGroupByOpt.dataset.type : null;
          const nBins = parseInt(document.getElementById('group-by-bins')?.value, 10) || 5;
          let hueIsContinuous = !!legendVar && groupByDataType === 'continuous';

          // --- Auto legend (hue) selection logic ---
          // If user didn't select a grouping/legend variable:
          // 1. If exactly two variables chosen (x and y): pick the discrete one as legend
          // 2. If both are discrete: pick x
          // (Applies only to multi-variable charts where a legend is meaningful.)
          if (!legendVar && xCol && yCol) {
            try {
              const xTypeSelEl = document.getElementById('x-axis-type');
              const yTypeSelEl = document.getElementById('y-axis-type');
              // Detect types from selects or infer from data
              function detectColType(col){
                if (!col || !uploadedData || !uploadedData.length) return '';
                for (let i=0;i<uploadedData.length;i++) {
                  const v = uploadedData[i][col];
                  if (v !== null && v !== undefined && String(v).trim() !== '') {
                    return inferType(v); // 'number' or 'string'
                  }
                }
                return '';
              }
              const xTypeValSel = xTypeSelEl?.value || '';
              const yTypeValSel = yTypeSelEl?.value || '';
              const xDetected = detectColType(xCol);
              const yDetected = detectColType(yCol);
              const xIsDiscrete = (xTypeValSel === 'discrete') || (xTypeValSel === '' && xDetected === 'string');
              const yIsDiscrete = (yTypeValSel === 'discrete') || (yTypeValSel === '' && yDetected === 'string');
              if (xIsDiscrete && !yIsDiscrete) {
                legendVar = xCol;
              } else if (!xIsDiscrete && yIsDiscrete) {
                legendVar = yCol;
              } else if (xIsDiscrete && yIsDiscrete) {
                legendVar = xCol; // both discrete -> choose x
              }
              if (legendVar) {
                // Recompute continuous flag based on inferred group-by type (if any)
                const lvOpt = groupBySelEl ? Array.from(groupBySelEl.options).find(o=>o.value===legendVar) : null;
                const lvType = lvOpt ? lvOpt.dataset.type : (inferType(uploadedData[0][legendVar]) === 'number' ? 'continuous' : 'discrete');
                hueIsContinuous = (lvType === 'continuous');
              }
            } catch(_) {}
          }

          const chartType = typeSel?.value || 'bar';
          const histBinCount = readHistogramBinCount();
          const suggested = (window.VC_LAST_FILE && window.VC_LAST_FILE.name) ? window.VC_LAST_FILE.name : 'your_data.csv';

          const showGrid = !!document.getElementById('adv-grid-toggle')?.checked;

          // Map app palette choice to closest seaborn palette name
          const sbPalette = getSeabornPaletteName();

          // Helper: map UI position to Matplotlib args
          function mplLegendArgs(pos) {
            switch (pos) {
              case 'Top Left':
                return "loc='upper left', bbox_to_anchor=(0.02, 0.98)";
              case 'Left':
                return "loc='center left', bbox_to_anchor=(0.02, 0.5)";
              case 'Right':
                return "loc='center right', bbox_to_anchor=(0.98, 0.5)";
              case 'Outside Chart':
                // Keep prior 'Right Side' behavior for Python
                return "loc='upper right', bbox_to_anchor=(0.98, 0.98)";
              case 'Top Right':
              default:
                return "loc='upper right', bbox_to_anchor=(0.98, 0.98)";
            }
          }

          const lines = [];
          lines.push('# Python (Seaborn)');
          lines.push('# pip install seaborn matplotlib pandas');
          lines.push('import seaborn as sns');
          lines.push('import matplotlib.pyplot as plt');
          lines.push('import matplotlib.colors as mcolors');
          lines.push('import math');
          lines.push('import pandas as pd');
          lines.push('');
          lines.push(`# Load data`);
          lines.push(`df = pd.read_csv('${escapePyStr(suggested)}')`);
          lines.push('');
          // If continuous legend variable selected, create binned column
          if (hueIsContinuous) {
            lines.push(`# Bin continuous legend variable '${escapePyStr(legendVar)}' into ${nBins} bins for legend`);
            lines.push(`df['__legend_bin'] = pd.cut(pd.to_numeric(df['${escapePyStr(legendVar)}'], errors='coerce'), bins=${nBins}, include_lowest=True, duplicates='drop')`);
            lines.push('');
          }
          lines.push('# Setup');
          lines.push("sns.set_theme(style='dark')");
          lines.push('plt.figure(figsize=(10, 6))');
          lines.push('');

          // Determine hue and order code if legend variable is provided
          const hasXY = !!xCol && !!yCol;
          const hasHue = !!legendVar;
          const hueCol = hueIsContinuous ? '__legend_bin' : legendVar;
          const hueArg = hasHue ? `, hue='${escapePyStr(hueCol)}'` : '';
          let hueOrderName = '';
          if (hasHue) {
            hueOrderName = '__hue_order';
            lines.push('# Configure legend ordering');
            if (hueIsContinuous) {
              // Use bin category order from pd.cut (ordered Categorical)
              lines.push(`${hueOrderName} = list(df['__legend_bin'].cat.categories)`);
              if (legendOrder === 'Reversed') {
                lines.push(`${hueOrderName} = ${hueOrderName}[::-1]`);
              }
            } else {
              if (legendOrder === 'Alphabetical') {
                lines.push(`${hueOrderName} = sorted(pd.unique(df['${escapePyStr(legendVar)}'].dropna()))`);
              } else if (legendOrder === 'Reversed') {
                lines.push(`${hueOrderName} = list(pd.unique(df['${escapePyStr(legendVar)}'].dropna()))[::-1]`);
              } else {
                lines.push(`${hueOrderName} = pd.unique(df['${escapePyStr(legendVar)}'].dropna())`);
              }
            }
            lines.push('');
          }

          // Choose axis-level seaborn function for better legend control
          let plotting = '';
          // Determine palette argument dynamically: if UI palette is Vega Chart, build a matching hex palette
          let palArg = '';
          const uiPalette = (document.getElementById('color-palette')?.value || 'Vega Chart');
          
          // Always set up Vega palette variables to avoid NameError, but only use them conditionally
          lines.push('# Custom Vega Chart palette to match JS/R');
          lines.push("vc_base = ['#34d399','#22c55e','#10b981','#06b6d4','#3b82f6','#8b5cf6']");
          lines.push('n_needed = None');
          if (hasHue) {
            lines.push('n_needed = len(__hue_order)');
          } else if (chartType === 'bar' || chartType === 'pie') {
            if (xCol) {
              lines.push(`n_needed = pd.Series(df['${escapePyStr(xCol)}']).dropna().nunique()`);
            } else if (yCol) {
              lines.push(`n_needed = pd.Series(df['${escapePyStr(yCol)}']).dropna().nunique()`);
            }
          } else if (chartType === 'histogram') {
            lines.push('n_needed = 1  # Single color for histogram');
          } else if (!hasXY && (chartType === 'violin' || chartType === 'strip' || chartType === 'jitter')) {
            lines.push('n_needed = 1  # Single color for single-variable plots');
          }
          lines.push('if n_needed is None or n_needed <= 0:');
          lines.push('    n_needed = len(vc_base)');
          // Build palette safely with more robust error handling
          lines.push('try:');
          lines.push('    if n_needed > len(vc_base):');
          lines.push("        vc_palette = [mcolors.to_hex(mcolors.LinearSegmentedColormap.from_list('vega_custom', vc_base)(i/(max(int(n_needed)-1, 1)))) for i in range(int(n_needed))]");
          lines.push('    else:');
          lines.push('        vc_palette = vc_base[:int(n_needed)]');
          lines.push('except Exception as e:');
          lines.push('    # Fallback to base colors if palette generation fails');
          lines.push('    vc_palette = vc_base[:min(len(vc_base), max(1, int(n_needed or 1)))]');
          
          if (uiPalette === 'Vega Chart') {
            palArg = ', palette=vc_palette';
          } else if (sbPalette) {
            palArg = `, palette='${sbPalette}'`;
          }
          const hueOrderArg = hasHue ? `, hue_order=${hueOrderName}` : '';
          // Error bars (Python/Seaborn): only for barplot with one discrete and one continuous var,
          // and only when the toggle is ON. Also disable by default to avoid seaborn's default CIs.
          const advErrorToggle = !!document.getElementById('adv-trend-toggle')?.checked;
          const canUseErrorBars = supportsErrorBars();
          const barErrorArg = (canUseErrorBars && advErrorToggle) ? ", errorbar='sd'" : ", errorbar=None";

          const pyImgChoice = (document.getElementById('adv-image-bg')?.value) || 'default';

          lines.push('# Create the chart');
          // Determine if the numeric (value) column is naturally nonnegative
          const valueColForTwoVar = (function(){
            if (!hasXY) return '';
            // One axis categorical, one numeric is required for violin/box; for others we still compute
            const xTypeSelEl = document.getElementById('x-axis-type');
            const yTypeSelEl = document.getElementById('y-axis-type');
            const xIsNum = (xTypeSelEl?.value === 'continuous');
            const yIsNum = (yTypeSelEl?.value === 'continuous');
            if (xIsNum && !yIsNum) return xCol;
            if (yIsNum && !xIsNum) return yCol;
            // Fallback: infer by sampling
            try {
              const xn = getNumericValues(xCol);
              const yn = getNumericValues(yCol);
              if (xn.length && !yn.length) return xCol;
              if (yn.length && !xn.length) return yCol;
            } catch(_) {}
            return yCol || xCol || '';
          })();
          const nonNegTwoVar = isNonNegativeColumn(valueColForTwoVar);
          if ((chartType === 'bar' || chartType === 'box' || chartType === 'violin' || chartType === 'strip' || chartType === 'jitter') && hasXY) {
            const fn = chartType === 'bar' ? 'barplot' : (chartType === 'box' ? 'boxplot' : (chartType === 'violin' ? 'violinplot' : 'stripplot'));
            // Only add a jitter argument for strip/jitter chart types.
            // Passing jitter to bar/box/violin plots caused: Rectangle.set() got an unexpected keyword argument 'jitter'
            // because those seaborn functions forward unknown kwargs to matplotlib artists.
            // Keep explicit jitter=0 for plain 'strip' to create a non-jittered dot plot.
            const extra = chartType === 'jitter' ? ', jitter=0.25' : (chartType === 'strip' ? ', jitter=0' : '');
            const errArg = (fn === 'barplot') ? barErrorArg : '';
            const cutArg = (fn === 'violinplot' && nonNegTwoVar) ? ', cut=0' : '';
            
            // For two-variable charts, apply orientation correctly
            if (advOrientation === 'horizontal') {
              // For horizontal orientation: categorical on Y-axis, continuous on X-axis
              // This is correct for all chart types (bar, box, violin, strip)
              plotting = `ax = sns.${fn}(data=df, y='${escapePyStr(xCol)}', x='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg}${errArg}${cutArg}${extra})`;
            } else {
              // For vertical orientation: categorical on X-axis, continuous on Y-axis (default)
              plotting = `ax = sns.${fn}(data=df, x='${escapePyStr(xCol)}', y='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg}${errArg}${cutArg}${extra})`;
            }
          } else if (chartType === 'bar') {
            // Use orientation toggle: horizontal => map to y=var; vertical => map to x=var
            const prefer = xCol || yCol || '';
            if (prefer) {
              if (advOrientation === 'horizontal') {
                plotting = `ax = sns.countplot(data=df, y='${escapePyStr(prefer)}'${hueArg}${hueOrderArg}${palArg})`;
              } else {
                plotting = `ax = sns.countplot(data=df, x='${escapePyStr(prefer)}'${hueArg}${hueOrderArg}${palArg})`;
              }
            }
          } else if (chartType === 'scatter' && hasXY) {
            plotting = `ax = sns.scatterplot(data=df, x='${escapePyStr(xCol)}', y='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg})`;
          } else if (chartType === 'smooth' && hasXY) {
            // Scatter + single global regression line (ignores hue for the trend line)
            plotting = `ax = sns.scatterplot(data=df, x='${escapePyStr(xCol)}', y='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg})\n` +
                       `sns.regplot(data=df, x='${escapePyStr(xCol)}', y='${escapePyStr(yCol)}', scatter=False, color='white', ax=ax)`;
          } else if (chartType === 'line' && hasXY) {
            plotting = `ax = sns.lineplot(data=df, x='${escapePyStr(xCol)}', y='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg})`;
          } else if (chartType === 'histogram') {
            // Histogram: single continuous variable
            const contCol = xCol || yCol || '';
            if (contCol) {
              const histColors = (uiPalette === 'Vega Chart') ? 'vc_palette[0] if vc_palette else vc_base[0]' : (sbPalette ? `sns.color_palette('${sbPalette}')[0]` : 'None');
              if (advOrientation === 'horizontal') {
                plotting = `ax = sns.histplot(data=df, y='${escapePyStr(contCol)}'${hueArg}${hueOrderArg}, bins=${histBinCount}, color=${histColors})`;
              } else {
                plotting = `ax = sns.histplot(data=df, x='${escapePyStr(contCol)}'${hueArg}${hueOrderArg}, bins=${histBinCount}, color=${histColors})`;
              }
            }
          } else if (chartType === 'pie') {
            // Pie chart: use matplotlib pie directly (seaborn doesn't have native pie charts)
            const catCol = xCol || yCol || '';
            if (catCol) {
              lines.push('# Count values for pie chart');
              lines.push(`pie_data = df['${escapePyStr(catCol)}'].value_counts()`);
              const pieColors = (uiPalette === 'Vega Chart') ? 'vc_palette[:len(pie_data)] if vc_palette else vc_base[:len(pie_data)]' : (sbPalette ? `sns.color_palette('${sbPalette}', len(pie_data))` : 'None');
              const textColor = (pyImgChoice === 'white') ? 'blue' : 'white';
              plotting = `wedges, texts, autotexts = plt.pie(pie_data.values, labels=pie_data.index, autopct='%1.1f%%', colors=${pieColors}, textprops={'color': '${textColor}'})\nax = plt.gca()`;
            }
          } else if (chartType === 'box' && !hasXY) {
            // Box Plot requires two variables; no single-variable box plot
            plotting = '';
          } else if ((chartType === 'violin' || chartType === 'strip' || chartType === 'jitter') && !hasXY) {
            // Single variable violin/strip plots  
            const singleCol = xCol || yCol || '';
            if (singleCol) {
              const fn = chartType === 'violin' ? 'violinplot' : 'stripplot';
              // Jitter only for 'jitter' mode; for plain 'strip' keep jitter=0 for aligned points; omit otherwise.
              const extra = chartType === 'jitter' ? ', jitter=0.25' : (chartType === 'strip' ? ', jitter=0' : '');
              const singleColors = (uiPalette === 'Vega Chart') ? 'vc_palette[0] if vc_palette else vc_base[0]' : (sbPalette ? `sns.color_palette('${sbPalette}')[0]` : 'None');
              const cutArg = (fn === 'violinplot' && isNonNegativeColumn(singleCol)) ? ', cut=0' : '';
              if (advOrientation === 'horizontal') {
                plotting = `ax = sns.${fn}(data=df, y='${escapePyStr(singleCol)}', color=${singleColors}${cutArg}${extra})`;
              } else {
                plotting = `ax = sns.${fn}(data=df, x='${escapePyStr(singleCol)}', color=${singleColors}${cutArg}${extra})`;
              }
            }
          }

          if (!plotting) {
            lines.push('# Please select valid X and Y columns for your chart');
            if (chartType === 'bar') {
              // Apply orientation to fallback bar chart
              if (advOrientation === 'horizontal') {
                plotting = `ax = sns.barplot(data=df, y='${escapePyStr(xCol)}', x='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg}${barErrorArg})`;
              } else {
                plotting = `ax = sns.barplot(data=df, x='${escapePyStr(xCol)}', y='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg}${barErrorArg})`;
              }
            } else if (chartType === 'box') {
              // Apply orientation to fallback box plot
              if (advOrientation === 'horizontal') {
                plotting = `ax = sns.boxplot(data=df, y='${escapePyStr(xCol)}', x='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg})`;
              } else {
                plotting = `ax = sns.boxplot(data=df, x='${escapePyStr(xCol)}', y='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg})`;
              }
            } else if (chartType === 'violin') {
              // Apply orientation to fallback violin plot
              const cutArg = isNonNegativeColumn(yCol || xCol) ? ', cut=0' : '';
              if (advOrientation === 'horizontal') {
                plotting = `ax = sns.violinplot(data=df, y='${escapePyStr(xCol)}', x='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg}${cutArg})`;
              } else {
                plotting = `ax = sns.violinplot(data=df, x='${escapePyStr(xCol)}', y='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg}${cutArg})`;
              }
            } else if (chartType === 'strip' || chartType === 'jitter') {
              // Apply orientation to fallback strip/jitter plot
              // Fallback: jitter=0.25 for 'jitter' type, jitter=0 for plain 'strip', omit otherwise.
              const extraJitter = chartType==='jitter' ? ', jitter=0.25' : (chartType==='strip' ? ', jitter=0' : '');
              if (advOrientation === 'horizontal') {
                plotting = `ax = sns.stripplot(data=df, y='${escapePyStr(xCol)}', x='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg}${extraJitter})`;
              } else {
                plotting = `ax = sns.stripplot(data=df, x='${escapePyStr(xCol)}', y='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg}${extraJitter})`;
              }
            } else if (chartType === 'scatter') {
              // Scatter plots don't need orientation changes - they're always x vs y
              plotting = `ax = sns.scatterplot(data=df, x='${escapePyStr(xCol)}', y='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg})`;
            } else if (chartType === 'smooth') {
              // Smooth plots don't need orientation changes - they're always x vs y
              plotting = `ax = sns.scatterplot(data=df, x='${escapePyStr(xCol)}', y='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg})\n` +
                         `sns.regplot(data=df, x='${escapePyStr(xCol)}', y='${escapePyStr(yCol)}', scatter=False, color='white', ax=ax)`;
            } else if (chartType === 'line') {
              // Line plots don't need orientation changes - they're always x vs y
              plotting = `ax = sns.lineplot(data=df, x='${escapePyStr(xCol)}', y='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg})`;
            } else {
              // Default fallback
              if (advOrientation === 'horizontal') {
                plotting = `ax = sns.barplot(data=df, y='${escapePyStr(xCol)}', x='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg}${barErrorArg})`;
              } else {
                plotting = `ax = sns.barplot(data=df, x='${escapePyStr(xCol)}', y='${escapePyStr(yCol)}'${hueArg}${hueOrderArg}${palArg}${barErrorArg})`;
              }
            }
          }
          lines.push(plotting);
          lines.push('');

          // Apply backgrounds: Image (figure) and Chart (axes)
          lines.push('# Apply backgrounds: Image (figure) and Chart (axes)');
          lines.push("fig = plt.gcf(); ax = plt.gca()");
          const pyChartChoice = (document.getElementById('adv-chart-bg')?.value) || 'default';
          function resolvePyImageBg(choice){
            switch (choice) {
              case 'transparent': return 'none';
              case 'white': return '#f3f3f3';
              case 'blue': return '#0b1220';
              case 'default':
              default: return '#0a0a0a';
            }
          }
          function resolvePyChartBg(choice){
            switch (choice) {
              case 'transparent': return { ax: 'none', text: '#e5e7eb' };
              case 'white': return { ax: '#ffffff', text: '#111827' };
              case 'blue': return { ax: '#8ac0db', text: '#e5e7eb' };
              case 'green': return { ax: '#8adba5', text: '#052e23' };
              case 'yellow': return { ax: '#fee14e', text: '#111827' };
              case 'orange': return { ax: '#fd732d', text: '#111827' };
              case 'purple': return { ax: '#ce8adb', text: '#111827' };
              case 'teal': return { ax: '#76d3cf', text: '#052e2e' };
              case 'default':
              default: return { ax: 'none', text: '#e5e7eb' };
            }
          }
          
          // Separate function for grid styling - independent of chart background
          function resolvePyGridStyle(imgChoice) {
            // Grid color based on overall image theme, not chart background
            const isLightTheme = (imgChoice === 'white');
            return {
              grid: isLightTheme ? '#d1d5db' : '#374151',
              spine: isLightTheme ? '#9ca3af' : '#6b7280'
            };
          }
          const __pyFig = resolvePyImageBg(pyImgChoice);
          const __pyAx = resolvePyChartBg(pyChartChoice);
          const __pyGrid = resolvePyGridStyle(pyImgChoice);
          lines.push("fig.patch.set_facecolor('" + __pyFig + "')");
          if (chartType === 'pie') {
            lines.push("ax.set_facecolor('" + __pyAx.ax + "')");
          } else {
            lines.push("ax.set_facecolor('" + __pyAx.ax + "')");
            if (showGrid) {
              lines.push("ax.grid(color='" + __pyGrid.grid + "', linestyle='-', linewidth=0.6, alpha=0.6)");
            }
            lines.push("for spine in ax.spines.values(): spine.set_color('" + __pyGrid.spine + "')");
          }
          // Text color depends on IMAGE background (white -> very dark grey, else white)
          const __pyText = (pyImgChoice === 'white') ? '#111827' : '#ffffff';
          lines.push("ax.title.set_color('" + __pyText + "')");
          lines.push("ax.xaxis.label.set_color('" + __pyText + "')");
          lines.push("ax.yaxis.label.set_color('" + __pyText + "')");
          lines.push("ax.tick_params(colors='" + __pyText + "')");

          // Titles and labels
          const styleChoice = (document.getElementById('adv-text-style')?.value) || 'normal';
          const pyWeight = (styleChoice === 'bold' || styleChoice === 'bold-italic') ? 'bold' : 'normal';
          const pyStyle = (styleChoice === 'italic' || styleChoice === 'bold-italic') ? 'italic' : 'normal';
          lines.push('# Customize appearance');
          if (title && subtitle) {
            lines.push(`plt.suptitle('${escapePyStr(title)}', fontsize=18, color='${__pyText}', y=0.98, fontweight='${pyWeight}', fontstyle='${pyStyle}')`);
            lines.push(`plt.figtext(0.5, 0.92, '${escapePyStr(subtitle)}', ha='center', va='top', fontsize=13, color='${__pyText}', fontweight='${pyWeight}', fontstyle='${pyStyle}')`);
          } else if (title) {
            lines.push(`plt.title('${escapePyStr(title)}', fontsize=18, color='${__pyText}', fontweight='${pyWeight}', fontstyle='${pyStyle}')`);
          } else if (subtitle) {
            lines.push(`plt.title('${escapePyStr(subtitle)}', fontsize=14, color='${__pyText}', fontweight='${pyWeight}', fontstyle='${pyStyle}')`);
          }
          // Handle axis label swapping for horizontal strip plots
          let finalXLabel = xLabel;
          let finalYLabel = yLabel;
          if (chartType === 'strip' && advOrientation === 'horizontal') {
            finalXLabel = yLabel;
            finalYLabel = xLabel;
          }
          if (finalXLabel) { lines.push(`plt.xlabel('${escapePyStr(finalXLabel)}', fontweight='${pyWeight}', fontstyle='${pyStyle}', color='${__pyText}')`); }
          if (finalYLabel) { lines.push(`plt.ylabel('${escapePyStr(finalYLabel)}', fontweight='${pyWeight}', fontstyle='${pyStyle}', color='${__pyText}')`); }

          // Legend handling
          lines.push('');
          lines.push('# Configure legend');
      if (showLegend) {
            if (hasHue) {
              const args = mplLegendArgs(legendPos);
              const frame = legendBorder ? ', frameon=True' : ', frameon=False';
        const legendTitleFinal = legendTitle || (hueIsContinuous ? `${legendVar} (${nBins} bins)` : '');
        const titleArg = legendTitleFinal ? `, title='${escapePyStr(legendTitleFinal)}'` : '';
              // Compute legend columns to keep legend height <= 70% of axes height
              lines.push('# Keep legend height within 70% of plot area');
              lines.push('handles, labels = plt.gca().get_legend_handles_labels()');
              lines.push('n_items = len(labels)');
              lines.push('if n_items > 0:');
              lines.push('    fig = plt.gcf(); ax = plt.gca()');
              lines.push('    bbox = ax.get_position()');
              lines.push('    ax_height_px = fig.get_size_inches()[1]*fig.dpi*(bbox.height)');
              lines.push('    est_row_height = 18  # px per legend row');
              lines.push('    max_rows = max(1, int((0.7*ax_height_px)/est_row_height))');
              lines.push('    ncol = max(1, int(math.ceil(n_items/float(max_rows))))');
              lines.push(`    leg = plt.legend(${args}${frame}${titleArg}, fontsize=8, title_fontsize=9, borderaxespad=0.5, ncol=ncol)`);
              lines.push('else:');
              lines.push(`    leg = plt.legend(${args}${frame}${titleArg}, fontsize=8, title_fontsize=9, borderaxespad=0.5)`);
              lines.push("plt.setp(leg.get_texts(), color='" + __pyText + "'); plt.setp(leg.get_title(), color='" + __pyText + "')");
              lines.push(`leg.get_title().set_fontweight('${pyWeight}')`);
              lines.push(`leg.get_title().set_fontstyle('${pyStyle}')`);
              // When legend border is enabled in the UI, show only an outline (no fill)
              if (legendBorder) {
                lines.push("frm = leg.get_frame()");
                lines.push("frm.set_facecolor('none')");
                lines.push("frm.set_edgecolor('#6b7280')  # match axis spine color");
                lines.push('frm.set_linewidth(0.8)');
              }
            }
          } else {
            if (hasHue) {
              lines.push(`plt.legend().set_visible(False)`);
            }
          }

          if (sourceText) {
            lines.push('');
            lines.push('# Add source text');
            if (showLegend && hasHue && (legendPos === 'Right' || legendPos === 'Outside Chart')) {
              lines.push(`plt.figtext(0.01, 0.01, '${escapePyStr(sourceText)}', ha='left', va='bottom', fontsize=9, color='${__pyText}')`);
            } else {
              lines.push(`plt.figtext(0.99, 0.01, '${escapePyStr(sourceText)}', ha='right', va='bottom', fontsize=9, color='${__pyText}')`);
            }
          }
          lines.push('');
          lines.push('# Format and display');
          if (chartType === 'pie') {
            lines.push('ax.axis("equal")  # Equal aspect ratio for pie chart');
          } else {
            lines.push('plt.xticks(rotation=45, ha="right")');
            lines.push('plt.yticks(rotation=0)');
            lines.push('plt.gca().tick_params(axis="x", labelsize=9)');
            lines.push('plt.gca().tick_params(axis="y", labelsize=9)');
          }
          // Smart watermark positioning: opposite side of source text
          let watermarkX = '0.99';
          let watermarkHA = 'right';
          const watermarkY = '0.005'; // Keep at bottom position regardless of source text

          if (sourceText) {
            const sourceLeft = (showLegend && hasHue && (legendPos === 'Top Right' || legendPos === 'Right' || legendPos === 'Outside Chart'));
            if (sourceLeft) {
              // Source is on left -> place watermark on right
              watermarkX = '0.99';
              watermarkHA = 'right';
            } else {
              // Source is on right -> place watermark on left
              watermarkX = '0.01';
              watermarkHA = 'left';
            }
          } else {
            // Default when no source: bottom-right
            watermarkX = '0.99';
            watermarkHA = 'right';
          }

          lines.push(`plt.figtext(${watermarkX}, ${watermarkY}, "Vegachart.com", ha="${watermarkHA}", va="bottom", fontsize=8, color="#9ca3af", alpha=0.7)`);
          lines.push('plt.tight_layout(pad=1.5)');
          lines.push('plt.show()');

          return lines.join('\n');
        }

        // --- R code generation (ggplot2) ---
        let autoRCode = '';

        function rDefaultTemplate() {
          const suggested = (window.VC_LAST_FILE && window.VC_LAST_FILE.name) ? window.VC_LAST_FILE.name : 'your_data.csv';
          return [
            '# R (ggplot2)',
            '# --- Backend wrapper (executed but not shown) ---',
            '# Loads: library(ggplot2); if installed: library(dplyr), library(readr)',
            '# If you do not assign p, the last ggplot you create is used via ggplot2::last_plot().',
            '# After your code, the server applies a theme and saves using:',
            '#   p <- p + theme(plot.background = element_rect(fill = "#0a0a0a", color = NA),',
            '#                    plot.margin = margin(t = 20, r = 25, b = 55, l = 15))',
            '#   ggsave(filename = "<temp>.png", plot = p, device = "png", width = 6.4, height = 4.8, units = "in", dpi = 150, bg = "#0a0a0a", limitsize = FALSE)',
            '# ------------------------------------------------',
            '# install.packages(c("ggplot2", "dplyr", "readr", "tidyr"))  # if running locally',
            'library(ggplot2)',
            'if (requireNamespace("readr", quietly = TRUE)) library(readr)',
            'if (requireNamespace("dplyr", quietly = TRUE)) library(dplyr)',
            'if (requireNamespace("tidyr", quietly = TRUE)) library(tidyr)',
            '',
            '# Data is provided as data.frame df when you upload a CSV.',
            `# df <- readr::read_csv('${suggested}')`,
            '',
            '# Keep a consistent baseline theme',
            'theme_set(theme_minimal())',
            '',
            '# Always assign your plot to `p` so the backend can save it',
            'if (exists("df") && is.data.frame(df)) {',
            '  cols <- names(df)',
            '  non_empty <- cols[vapply(cols, function(.c) any(!is.na(df[[.c]]) & df[[.c]] != ""), logical(1))]',
            '  if (length(non_empty) >= 2) {',
            '    x_col <- non_empty[1]',
            '    y_col <- non_empty[2]',
            '    p <- ggplot(df, aes_string(x = x_col, y = y_col)) +',
            '      geom_col(fill = "#34d399", alpha = 0.85) +',
            '      labs(x = x_col, y = y_col)',
            '  } else if (length(non_empty) == 1) {',
            '    x_col <- non_empty[1]',
            '    p <- ggplot(df, aes_string(x = x_col)) +',
            '      geom_bar(fill = "#34d399", alpha = 0.85) +',
            '      labs(x = x_col)',
            '  } else {',
            '    p <- ggplot() +',
            '      theme_void()',
            '  }',
            '} else {',
            '  sample_data <- data.frame(',
            '    category = c("A", "B", "C"),',
            '    value = c(10, 20, 15)',
            '  )',
            '  p <- ggplot(sample_data, aes(x = category, y = value, fill = category)) +',
            '    geom_col(show.legend = FALSE) +',
            '    scale_fill_manual(values = c("#34d399", "#10b981", "#059669")) +',
            '    labs(x = "Category", y = "Value")',
            '}',
            '',
            '# When running in a non-interactive session, print the plot so last_plot() is set',
            'print(p)'
          ].join('\n');
        }
        function escapeRStr(s) {
          try { return String(s).replace(/\\/g, "\\\\").replace(/"/g, '\\"'); } catch(_) { return ''; }
        }

        // Escape R column names for non-syntactic names by wrapping in backticks
        function escapeRCol(col) {
          try {
            const c = String(col || '');
            // Valid R identifiers: letters, digits, dot, underscore, starting with letter or dot not followed by digit
            if (/^[A-Za-z_][A-Za-z0-9_.]*$/.test(c)) return c;
            return '`' + c.replace(/`/g, '') + '`';
          } catch(_) { return col || ''; }
        }

        function getGgplot2PaletteName() {
          const paletteSel = document.getElementById('color-palette');
          const name = paletteSel?.value || '';
          if (!name || name === 'Vega Chart') return 'Set2'; // Close to Vega's default categorical colors
          if (name === 'Pastel') return 'Pastel1'; // Perfect match for pastel colors
          if (name === 'Default') return 'Set1'; // Classic primary colors
          if (name === 'ColorBlind') return 'viridis_d'; // Colorblind-friendly
          if (name === 'Gradient') {
            const gs = document.getElementById('gradient-select');
            const inv = document.getElementById('gradient-invert');
            const key = gs?.value || '';
            const scaleMap = {
              'grayscale': 'scale_fill_gradient(low = "white", high = "black")',
              'red': 'scale_fill_gradient(low = "#fee5d9", high = "#de2d26")', // Better red gradient
              'green': 'scale_fill_gradient(low = "#edf8e9", high = "#238b45")', // Better green gradient
              'blue': 'scale_fill_gradient(low = "#eff3ff", high = "#2171b5")', // Better blue gradient
              'orange': 'scale_fill_gradient(low = "#feedde", high = "#fd8d3c")', // Better orange gradient
              'green-blue': 'scale_fill_gradient2(low = "#238b45", mid = "white", high = "#2171b5")',
              'yellow-green': 'scale_fill_gradient2(low = "#ffeda0", mid = "white", high = "#238b45")',
              'orange-red': 'scale_fill_gradient2(low = "#fd8d3c", mid = "white", high = "#de2d26")',
              'red-purple': 'scale_fill_gradient2(low = "#de2d26", mid = "white", high = "#756bb1")'
            };
            let scale = scaleMap[key] || 'scale_fill_viridis_c()';
            if (inv && inv.checked) {
              scale = scale.replace(')', ', direction = -1)');
            }
            return scale;
          }
          return 'Set2'; // Default fallback
        }

  // Test reference: ensure presence of exact boxplot params string for validation
  // geom_boxplot(alpha = 0.7, outlier.size = 1.5, outlier.alpha = 0.7, width = 0.6, coef = 1.5)

  function rCodeFromInputs() {
          const xColRaw = xAxisSelect?.value || '';
          const yColRaw = yAxisSelect?.value || '';
          // Filter out single variable placeholder values
          const xCol = (xColRaw === SINGLE_VAR_OPTION_VALUE) ? '' : xColRaw;
          const yCol = (yColRaw === SINGLE_VAR_OPTION_VALUE) ? '' : yColRaw;
          const typeSel = document.getElementById('chart-type');
          const showLegend = !!document.getElementById('show-legend')?.checked;
          const legendTitle = document.getElementById('legend-title')?.value || '';
          const legendPos = document.getElementById('legend-position')?.value || 'Top Right';
          // Prefer new Group By selection; fall back to legacy Legend Variable
          const legendVar = document.getElementById('group-by')?.value || document.getElementById('x-axis')?.value || '';
          const legendOrder = document.getElementById('legend-order')?.value || 'Normal';
          const legendBorder = !!document.getElementById('legend-border')?.checked;
          const title = document.getElementById('chart-title')?.value || '';
          const subtitle = document.getElementById('chart-subtitle')?.value || '';
          const xLabel = document.getElementById('x-axis-label')?.value || '';
          const yLabel = document.getElementById('y-axis-label')?.value || '';
          const sourceText = document.getElementById('source-text')?.value || '';
          const advOrientation = document.querySelector('input[name="adv-orientation"]:checked')?.value || 'vertical';
          const advGridToggle = !!document.getElementById('adv-grid-toggle')?.checked;
          const xTypeSelEl = document.getElementById('x-axis-type');
          const yTypeSelEl = document.getElementById('y-axis-type');
          const xTypeValSel = xTypeSelEl?.value || '';
          const yTypeValSel = yTypeSelEl?.value || '';
          // Group By data type and bins (for continuous binning -> legend bins)
          const groupBySelEl = document.getElementById('group-by');
          const selGroupByOpt = groupBySelEl ? groupBySelEl.options[groupBySelEl.selectedIndex] : null;
          const groupByDataType = selGroupByOpt ? selGroupByOpt.dataset.type : null;
          const nBins = parseInt(document.getElementById('group-by-bins')?.value, 10) || 5;
          const hueIsContinuous = !!legendVar && groupByDataType === 'continuous';

          const chartType = typeSel?.value || 'bar';
          const histBinCount = readHistogramBinCount();
          const suggested = (window.VC_LAST_FILE && window.VC_LAST_FILE.name) ? window.VC_LAST_FILE.name : 'your_data.csv';

          // Map Text Options to ggplot2 element_text(face=...)
          const styleChoice = (document.getElementById('adv-text-style')?.value) || 'normal';
          const rFace = styleChoice === 'bold' ? 'bold' : (styleChoice === 'italic' ? 'italic' : (styleChoice === 'bold-italic' ? 'bold.italic' : 'plain'));

          const ggPaletteName = getGgplot2PaletteName();
          const selectedUIPalette = document.getElementById('color-palette')?.value || '';
          // Map aesthetics whenever a grouping variable is chosen; legend visibility is handled separately
          const hasHue = !!legendVar;

          // Determine background choices for R: image (plot.background) vs chart (panel.background)
          const imgBgChoiceR = (document.getElementById('adv-image-bg')?.value) || 'default';
          const chartBgChoiceR = (document.getElementById('adv-chart-bg')?.value) || 'default';
          // Style boxplot outlines for contrast based on chart background
          const isLightChartBg = (chartBgChoiceR === 'white');
          const boxEdgeColor = isLightChartBg ? 'black' : 'white';

          function rResolveImageBg(choice) {
            switch (choice) {
              case 'transparent': return { plot: 'NA', isTransparent: true };
              case 'white': return { plot: '"#f3f3f3"', isTransparent: false };
              case 'blue': return { plot: '"#0b1220"', isTransparent: false };
              case 'default':
              default: return { plot: '"#0a0a0a"', isTransparent: false };
            }
          }
          function rResolveChartBg(choice) {
            switch (choice) {
              case 'transparent': return { panel: 'NA', text: '"white"', axisText: '"lightgray"', grid: '"gray60"' };
              case 'white': return { panel: '"white"', text: '"#111827"', axisText: '"#111827"', grid: '"gray80"' };
              case 'blue': return { panel: '"#8ac0db"', text: '"#e5e7eb"', axisText: '"#d1d5db"', grid: '"#374151"' };
              case 'green': return { panel: '"#8adba5"', text: '"#052e23"', axisText: '"#052e23"', grid: '"#065f46"' };
              case 'yellow': return { panel: '"#fee14e"', text: '"#111827"', axisText: '"#111827"', grid: '"#7c2d12"' };
              case 'orange': return { panel: '"#fd732d"', text: '"#111827"', axisText: '"#111827"', grid: '"#7c2d12"' };
              case 'purple': return { panel: '"#ce8adb"', text: '"#111827"', axisText: '"#111827"', grid: '"#4c1d95"' };
              case 'teal': return { panel: '"#76d3cf"', text: '"#052e2e"', axisText: '"#052e2e"', grid: '"#134e4a"' };
              case 'default':
              default: return { panel: 'NA', text: '"#e5e7eb"', axisText: '"#d1d5db"', grid: '"#374151"' };
            }
          }
          const rImg = rResolveImageBg(imgBgChoiceR);
          const rChart = rResolveChartBg(chartBgChoiceR);

          // Determine number of unique values for the legend variable to generate enough colors
          let uniqueLegendVals = [];
          if (hasHue && uploadedData && uploadedData.length > 0) {
            const legendSet = new Set(uploadedData.map(row => row[legendVar]));
            uniqueLegendVals = Array.from(legendSet);
          }
          // Detect column data types from the data if possible
          function detectColType(col) {
            try {
              if (!col || !uploadedData || !uploadedData.length) return '';
              for (let i = 0; i < uploadedData.length; i++) {
                const v = uploadedData[i][col];
                if (v !== null && v !== undefined && String(v).trim() !== '') {
                  return inferType(v); // 'number' or 'string'
                }
              }
            } catch(_) {}
            return '';
          }
          const xTypeDetected = detectColType(xCol);
          const yTypeDetected = detectColType(yCol);
          const xIsDiscrete = xCol && ((xTypeValSel === 'discrete') || (xTypeValSel === '' && xTypeDetected === 'string'));
          const yIsDiscrete = yCol && ((yTypeValSel === 'discrete') || (yTypeValSel === '' && yTypeDetected === 'string'));

          // If no legend mapping, but we still want colors per category (bar/count/box/violin/strip),
          // collect categories from a discrete axis to size the palette correctly, only when that axis is discrete.
          let uniqueCategoryVals = [];
          let mapToAxis = null; // 'x' or 'y' when mapping fill/color to discrete axis without legend
          if (!hasHue && uploadedData && uploadedData.length > 0) {
            if (xIsDiscrete) {
              const setX = new Set(uploadedData.map(row => row[xCol]));
              uniqueCategoryVals = Array.from(setX);
              mapToAxis = 'x';
            } else if (yIsDiscrete) {
              const setY = new Set(uploadedData.map(row => row[yCol]));
              uniqueCategoryVals = Array.from(setY);
              mapToAxis = 'y';
            }
          }
          const baseCount = uniqueLegendVals.length > 0 ? uniqueLegendVals.length : (uniqueCategoryVals.length > 0 ? uniqueCategoryVals.length : 10);

          // Get the actual hex codes for the selected UI palette (not the ggplot scale name)
          const isGradientChoice = selectedUIPalette === 'Gradient';
          const colorValues = isGradientChoice ? [] : palette(selectedUIPalette || 'Vega Chart', baseCount);
          const isCategoricalPalette = !isGradientChoice && colorValues && colorValues.length > 0;

          let gradientStops = [];
          if (isGradientChoice && typeof ggPaletteName === 'string') {
            const matches = [...ggPaletteName.matchAll("\"([^\"]+)\"")].map(m => m[1]).filter(Boolean);
            gradientStops = matches.length ? matches : ['#374151', '#9ca3af', '#e5e7eb'];
            if (/direction\s*=\s*-1/.test(ggPaletteName)) {
              gradientStops = gradientStops.slice().reverse();
            }
          }

          const mappedVarForPalette = hasHue ? (hueIsContinuous ? '__legend_bin' : legendVar) : (mapToAxis ? (mapToAxis === 'x' ? xCol : yCol) : '');

          // Helper: map UI position to outside sides for readability
          function ggLegendPosition(pos) {
            switch (pos) {
              case 'Top Left': return '"left"';
              case 'Left': return '"left"';
              case 'Right': return '"right"';
              case 'Outside Chart': return '"right"';
              case 'Top Right':
              default: return '"right"';
            }
          }

          const lines = [];
          const prePlotLines = [];
          // User-facing header
          lines.push('# R (ggplot2)');
          lines.push('# Tip: Upload a CSV or use your own data frame named df.');
          lines.push('# Start below: modify aesthetics, geometry, and theme as needed.');
          lines.push('# (You do not need to manually save the plot.)');
          lines.push('# Data is available as: df');
          lines.push('');
          const postDataInsertIdx = lines.length;
          // If continuous legend variable selected, create binned column for legend
          if (hueIsContinuous) {
            lines.push(`# Bin continuous legend variable '${escapeRStr(legendVar)}' into ${nBins} bins for legend`);
            lines.push('df$`__legend_bin` <- cut(suppressWarnings(as.numeric(df[["' + escapeRStr(legendVar) + '"]])), breaks = ' + nBins + ', include.lowest = TRUE, dig.lab = 3)');
            lines.push('lvl <- levels(df$`__legend_bin`)');
            lines.push('if (!is.null(lvl)) {');
            lines.push('  lvl <- lvl[!is.na(lvl)]');
            if (legendOrder === 'Alphabetical') {
              lines.push('  lvl <- sort(as.character(lvl))');
            } else if (legendOrder === 'Reversed') {
              lines.push('  lvl <- rev(lvl)');
            }
            lines.push('  if (length(lvl) > 0) {');
            lines.push('    df$`__legend_bin` <- factor(df$`__legend_bin`, levels = lvl)');
            lines.push('  } else {');
            lines.push('    df$`__legend_bin` <- factor(df$`__legend_bin`)');
            lines.push('  }');
            lines.push('} else {');
            lines.push('  df$`__legend_bin` <- factor(df$`__legend_bin`)');
            lines.push('}');
            lines.push('');
          }

          // Create a manual color palette whenever a categorical palette is selected
          if (isCategoricalPalette) {
            lines.push('# Creating color palette (manual) from selection');
            const rColorArray = `c(${colorValues.map(c => `"${c}"`).join(', ')})`;
            lines.push(`my_colors <- ${rColorArray}`);
            // Ensure the palette has enough colors for all categories mapped
            lines.push('# Ensure enough colors for all categories');
            lines.push('mapped_var <- NULL');
            if (mappedVarForPalette) {
              lines.push(`mapped_var <- "${escapeRStr(mappedVarForPalette)}"`);
            }
            lines.push('if (!is.null(mapped_var) && mapped_var %in% names(df)) {');
            lines.push('  vals <- df[[mapped_var]]');
            lines.push('  if (is.factor(vals)) {');
            lines.push('    n_needed <- length(levels(vals))');
            lines.push('  } else {');
            lines.push('    n_needed <- length(unique(vals[!is.na(vals)]))');
            lines.push('  }');
            lines.push('  if (length(my_colors) < n_needed) {');
            lines.push('    my_colors <- grDevices::colorRampPalette(my_colors)(n_needed)');
            lines.push('  } else if (length(my_colors) > n_needed && n_needed > 0) {');
            lines.push('    my_colors <- my_colors[seq_len(n_needed)]');
            lines.push('  }');
            // Name palette values to align explicitly with factor levels (prevents blank legend keys)
            lines.push('  if (is.factor(vals)) {');
            lines.push('    nm <- levels(vals)');
            lines.push('    if (length(nm) == length(my_colors)) names(my_colors) <- nm');
            lines.push('  }');
            lines.push('}');
            lines.push('');
          }

          // Theme setup (keep dark as baseline for defaults)
          lines.push('# Theme setup');
          lines.push('theme_set(theme_minimal())');
          lines.push('');

          // Build the main ggplot call safely (avoid referencing missing columns)
          const hasX = !!xCol;
          const hasY = !!yCol;
          let aesParts = [];
          if (hasX) aesParts.push(`x = .data[["${escapeRStr(xCol)}"]]`);
          // Only map y when provided (histogram/bar-count do not need explicit y)
          if (hasY && chartType !== 'histogram') aesParts.push(`y = .data[["${escapeRStr(yCol)}"]]`);

          // Determine if we should map aesthetics when no legend is provided
          let mappedAes = '';
          const hueCol = hueIsContinuous ? '__legend_bin' : legendVar;
          if (hasHue) {
            // Do not map color for line charts; lines should be single-colored
            if (chartType === 'scatter' || chartType === 'smooth' || chartType === 'strip' || chartType === 'jitter') {
              aesParts.push(`color = .data[["${escapeRStr(hueCol)}"]]`);
              mappedAes = 'color';
            } else {
              aesParts.push(`fill = .data[["${escapeRStr(hueCol)}"]]`);
              mappedAes = 'fill';
            }
          } else if (isCategoricalPalette && mapToAxis) {
            // Map fill/color to the discrete axis to show palette even without legend
            const colToMap = mapToAxis === 'x' ? xCol : yCol;
            if (colToMap) {
              // Do not map color for line charts; lines should be single-colored
              if (chartType === 'scatter' || chartType === 'smooth' || chartType === 'strip' || chartType === 'jitter') {
                aesParts.push(`color = .data[["${escapeRStr(colToMap)}"]]`);
                mappedAes = 'color';
              } else {
                aesParts.push(`fill = .data[["${escapeRStr(colToMap)}"]]`);
                mappedAes = 'fill';
              }
            }
          }
          // Validate chartType and provide fallback
          const validChartTypes = ['bar', 'scatter', 'smooth', 'line', 'area', 'box', 'violin', 'strip', 'jitter', 'histogram', 'pie'];
          const safeChartType = validChartTypes.includes(chartType) ? chartType : 'bar';

          // Build ggplot call; special-case pie charts (x should be constant, fill maps to category)
          let ggplotCall = '';
          if (safeChartType === 'pie') {
            // Choose the categorical column to map to fill. Prefer explicit hue, otherwise use the selected axis.
            const fillCol = hasHue ? hueCol : (xCol || yCol || '');
            const fillMap = fillCol ? `, fill = .data[["${escapeRStr(fillCol)}"]]` : '';
            ggplotCall = `ggplot(df, aes(x = factor(1)${fillMap}))`;
            // Ensure downstream logic knows a fill aesthetic is mapped when no explicit hue is chosen
            if (!hasHue) { mappedAes = 'fill'; }
          } else {
            ggplotCall = `ggplot(df, aes(${aesParts.join(', ')}))`;
          }

          lines.push('# Create chart');
          lines.push(`p <- ${ggplotCall} +`);

          // Add geometry based on chart type
          if (safeChartType === 'bar') {
            if (hasY) {
              if (hasHue) {
                lines.push('  geom_col(position = "dodge") +');
              } else {
                if (isCategoricalPalette && mappedAes === 'fill') {
                  lines.push('  geom_col() +');
                } else {
                  lines.push('  geom_col(fill = "steelblue") +');
                }
              }
            } else {
              // No y provided: use count stat to avoid referencing a missing column
              if (hasHue || (isCategoricalPalette && mappedAes === 'fill')) {
                lines.push('  geom_bar(position = "dodge") +');
              } else {
                lines.push('  geom_bar() +');
              }
            }
          } else if (safeChartType === 'scatter') {
            if (hasX && hasY) {
              lines.push('  geom_point(size = 3, alpha = 0.7) +');
            } else {
              lines.push('  geom_blank() +  # Please select both X and Y for a scatter plot');
            }
          } else if (safeChartType === 'smooth') {
            if (hasX && hasY) {
              lines.push('  geom_point(size = 3, alpha = 0.7) +');
              lines.push(`  geom_smooth(mapping = aes(x = .data[["${escapeRStr(xCol)}"]], y = .data[["${escapeRStr(yCol)}"]], group = 1), se = FALSE, method = "loess", color = "white", size = 0.7, inherit.aes = FALSE) +`);
            } else {
              lines.push('  geom_blank() +  # Please select both X and Y for a trend line');
            }
          } else if (safeChartType === 'line') {
            if (hasX && hasY) {
              // Always render a single-color continuous line
              lines.push('  geom_line(aes(group = 1), size = 1.2, color = "steelblue") +');
            } else {
              lines.push('  geom_blank() +  # Please select both X and Y for a line plot');
            }
          } else if (safeChartType === 'area') {
            if (hasX && hasY) {
              if (hasHue) {
                lines.push('  geom_area(alpha = 0.7, position = "stack") +');
              } else {
                lines.push('  geom_area(alpha = 0.7, fill = "steelblue") +');
              }
            } else {
              lines.push('  geom_blank() +  # Please select both X and Y for an area chart');
            }
          } else if (safeChartType === 'box') {
            if (hasY) {
              if (hasHue) {
                lines.push(`  geom_boxplot(alpha = 0.7, outlier.size = 1.5, outlier.alpha = 0.7, width = 0.6, coef = 1.5, color = "${boxEdgeColor}", outlier.color = "${boxEdgeColor}") +`);
              } else {
                if (isCategoricalPalette && mappedAes === 'fill') {
                  lines.push(`  geom_boxplot(alpha = 0.7, outlier.size = 1.5, outlier.alpha = 0.7, width = 0.6, coef = 1.5, color = "${boxEdgeColor}", outlier.color = "${boxEdgeColor}") +`);
                } else {
                  lines.push(`  geom_boxplot(alpha = 0.7, fill = "steelblue", outlier.size = 1.5, outlier.alpha = 0.7, width = 0.6, coef = 1.5, color = "${boxEdgeColor}", outlier.color = "${boxEdgeColor}") +`);
                }
              }
            } else {
              lines.push('  geom_blank() +  # Please select a Y column for a box plot');
            }
          } else if (safeChartType === 'violin') {
            if (hasY) {
              // If the value axis is naturally nonnegative, trim KDE tails to avoid negative side
              const valueCol = (hasX && hasY) ? yCol : (yCol || xCol || '');
              const addTrim = isNonNegativeColumn(valueCol);
              if (hasHue) {
                lines.push(`  geom_violin(alpha = 0.7${addTrim ? ', trim = TRUE' : ''}) +`);
              } else {
                if (isCategoricalPalette && mappedAes === 'fill') {
                  lines.push(`  geom_violin(alpha = 0.7${addTrim ? ', trim = TRUE' : ''}) +`);
                } else {
                  lines.push(`  geom_violin(alpha = 0.7, fill = "steelblue"${addTrim ? ', trim = TRUE' : ''}) +`);
                }
              }
            } else {
              lines.push('  geom_blank() +  # Please select a Y column for a violin plot');
            }
          } else if (safeChartType === 'strip') {
            // Strip plot (dot plot) - one discrete, one continuous variable
            if (hasX && hasY) {
              if (hasHue) {
                lines.push('  geom_point(size = 2, alpha = 0.8, position = position_jitter(width = 0, height = 0)) +');
              } else {
                if (isCategoricalPalette && mappedAes === 'color') {
                  lines.push('  geom_point(size = 2, alpha = 0.8, position = position_jitter(width = 0, height = 0)) +');
                } else {
                  lines.push('  geom_point(size = 2, alpha = 0.8, color = "steelblue", position = position_jitter(width = 0, height = 0)) +');
                }
              }
            } else {
              lines.push('  geom_blank() +  # Please select both X and Y columns for a strip plot');
            }
          } else if (safeChartType === 'jitter') {
            // Jitter plot - one discrete, one continuous variable with more jittering
            if (hasX && hasY) {
              if (hasHue) {
                lines.push('  geom_point(size = 2, alpha = 0.8, position = position_jitter(width = 0.25, height = 0)) +');
              } else {
                if (isCategoricalPalette && mappedAes === 'color') {
                  lines.push('  geom_point(size = 2, alpha = 0.8, position = position_jitter(width = 0.25, height = 0)) +');
                } else {
                  lines.push('  geom_point(size = 2, alpha = 0.8, color = "steelblue", position = position_jitter(width = 0.25, height = 0)) +');
                }
              }
            } else {
              lines.push('  geom_blank() +  # Please select both X and Y columns for a jitter plot');
            }
          } else if (safeChartType === 'histogram') {
            if (hasX) {
              if (mappedAes === 'fill') {
                lines.push(`  geom_histogram(alpha = 0.8, bins = ${histBinCount}) +`);
              } else {
                let histFillExpr = '';
                if (isCategoricalPalette) {
                  histFillExpr = '(if (exists("my_colors") && length(my_colors) >= 1) my_colors[1] else "#3b82f6")';
                } else if (Array.isArray(gradientStops) && gradientStops.length > 0) {
                  histFillExpr = gradientStops[0] ? `"${gradientStops[0]}"` : '';
                }
                if (histFillExpr) {
                  lines.push(`  geom_histogram(alpha = 0.8, bins = ${histBinCount}, fill = ${histFillExpr}) +`);
                } else {
                  lines.push(`  geom_histogram(alpha = 0.8, bins = ${histBinCount}) +`);
                }
              }
            } else {
              lines.push('  geom_blank() +  # Please select an X column for a histogram');
            }
          } else if (safeChartType === 'pie') {
            // Pie chart: stacked bar with constant x, then polar transform
            // geom_bar() defaults to stat = "count" which produces category frequencies
            lines.push('  geom_bar(width = 1) +');
            // Add percentage labels centered on slices
            lines.push('  geom_text(aes(y = after_stat(count), label = after_stat(paste0(..fill.., "\\n", scales::percent(count / sum(count), accuracy = 0.1)))), stat = "count", position = position_stack(vjust = 0.5), color = "white", size = 3.375) +');
            // Use polar coordinates and allow drawing outside panel for watermark
            lines.push('  coord_polar(theta = "y", clip = "off") +');
            // Remove axes/grid typical for pies; legend/theme handled below
            lines.push('  theme_void() +');
          } else {
            // Fallback: ensure a geometry is always added for unknown chart types
            // Choose appropriate geometry based on available data
            if (hasX && hasY) {
              // Both axes available: default to scatter plot
              lines.push('  geom_point(size = 3, alpha = 0.7) +  # Fallback geometry for unknown chart type');
            } else if (hasX) {
              // Only X axis: default to histogram or bar chart
              lines.push('  geom_bar() +  # Fallback geometry for unknown chart type');
            } else if (hasY) {
              // Only Y axis: use a simple point with constant x
              lines.push('  geom_point(aes(x = 1), size = 3, alpha = 0.7) +  # Fallback geometry for unknown chart type');
            } else {
              // No axes selected: add a blank geometry with helpful comment
              lines.push('  geom_blank() +  # Please select X and/or Y columns for visualization');
            }
          }

          // Add color/fill scales
          const isColorScale = (safeChartType === 'scatter' || safeChartType === 'smooth' || safeChartType === 'strip' || safeChartType === 'jitter');
          const scaleType = isColorScale ? 'color' : 'fill';
          // Determine the variable currently mapped to color/fill, if any
          const mappedVar = hasHue ? hueCol : (mapToAxis ? (mapToAxis === 'x' ? xCol : yCol) : '');
          let mappedVarType = mappedVar ? detectColType(mappedVar) : '';
          if (hueIsContinuous) { mappedVarType = 'string'; }
          if (hasHue || (isCategoricalPalette && mappedAes)) {
            if (mappedVar && mappedVarType === 'number') {
              // Continuous mapping: use a continuous scale
              if (selectedUIPalette === 'Gradient') {
                // Use pre-built gradient scale (fill/color) from ggPaletteName
                if (/^scale_(fill|color)_/i.test(ggPaletteName)) {
                  let scaleCall = ggPaletteName;
                  if (isColorScale && scaleCall.includes('scale_fill_')) {
                    scaleCall = scaleCall.replace('scale_fill_', 'scale_color_');
                  } else if (!isColorScale && scaleCall.includes('scale_color_')) {
                    scaleCall = scaleCall.replace('scale_color_', 'scale_fill_');
                  }
                  lines.push(`  ${scaleCall} +`);
                } else {
                  // fallback to viridis continuous
                  lines.push(`  scale_${scaleType}_viridis_c() +`);
                }
              } else if (isCategoricalPalette) {
                // Use gradientn with chosen categorical colors for continuous data
                lines.push(`  scale_${scaleType}_gradientn(colors = my_colors) +`);
              }
              // Ensure a single, tidy colorbar legend for continuous mappings
              const legendPosSide = (legendPos === 'Top Left' || legendPos === 'Top Right') ? 'top'
                                     : (legendPos === 'Bottom Left' || legendPos === 'Bottom Right') ? 'bottom'
                                     : 'right';
              const colorbarDir = (legendPosSide === 'top' || legendPosSide === 'bottom') ? 'horizontal' : 'vertical';
              const cbHeight = (colorbarDir === 'vertical') ? 120 : 10;
              const cbWidth  = (colorbarDir === 'vertical') ? 10 : 120;
              lines.push(`  guides(${scaleType} = guide_colorbar(title.position = "top", direction = "${colorbarDir}", barheight = grid::unit(${cbHeight}, "pt"), barwidth = grid::unit(${cbWidth}, "pt"))) +`);
            } else {
              // Discrete mapping
              if (isCategoricalPalette) {
                // If using binned legend values, name the palette with the bin levels
                // and lock ordering via limits to avoid level mismatches/warnings.
                const valuesExpr = (hueIsContinuous && hasHue) ? 'setNames(my_colors, lvl)' : 'my_colors';
                const lvlArgs = (hueIsContinuous && hasHue) ? ', breaks = lvl, limits = lvl, drop = FALSE' : '';
                lines.push(`  scale_${scaleType}_manual(values = ${valuesExpr}${lvlArgs}) +`);
                // Tidy discrete legend
                const legendPosSide = (legendPos === 'Top Left' || legendPos === 'Top Right') ? 'top'
                                       : (legendPos === 'Bottom Left' || legendPos === 'Bottom Right') ? 'bottom'
                                       : 'right';
                const legendDir = (legendPosSide === 'top' || legendPosSide === 'bottom') ? 'horizontal' : 'vertical';
                const ncol = (legendDir === 'horizontal') ? 2 : 1;
                lines.push(`  guides(${scaleType} = guide_legend(title.position = "top", ncol = ${ncol}, override.aes = list(alpha = 1))) +`);
              } else if (ggPaletteName) {
                // SAFEGUARD: If user selected a Gradient palette but the mapped variable is discrete,
                // avoid using any gradient (scale_*_gradient / gradient2) which triggers
                // "Discrete values supplied to continuous scale" in ggplot2. Instead, fall back to
                // a discrete palette (viridis_d) so all discrete cases succeed.
                if (selectedUIPalette === 'Gradient') {
                  const br = (hueIsContinuous && hasHue) ? ', breaks = lvl, drop = FALSE' : '';
                  lines.push(`  scale_${scaleType}_viridis_d(${br ? br.slice(2) : ''}) +`);
                  const legendPosSide = (legendPos === 'Top Left' || legendPos === 'Top Right') ? 'top'
                                         : (legendPos === 'Bottom Left' || legendPos === 'Bottom Right') ? 'bottom'
                                         : 'right';
                  const legendDir = (legendPosSide === 'top' || legendPosSide === 'bottom') ? 'horizontal' : 'vertical';
                  const ncol = (legendDir === 'horizontal') ? 2 : 1;
                  lines.push(`  guides(${scaleType} = guide_legend(title.position = "top", ncol = ${ncol}, override.aes = list(alpha = 1))) +`);
                } else if (/^scale_(fill|color)_/i.test(ggPaletteName)) {
                if (hueIsContinuous && selectedUIPalette === 'Gradient') {
                  // For binned legend, use a discrete palette even if UI chose gradient
                  const br = (hueIsContinuous && hasHue) ? ', breaks = lvl, drop = FALSE' : '';
                  lines.push(`  scale_${scaleType}_viridis_d(${br ? br.slice(2) : ''}) +`);
                } else {
                  let scaleCall = ggPaletteName;
                  if (isColorScale && scaleCall.includes('scale_fill_')) {
                    scaleCall = scaleCall.replace('scale_fill_', 'scale_color_');
                  } else if (!isColorScale && scaleCall.includes('scale_color_')) {
                    scaleCall = scaleCall.replace('scale_color_', 'scale_fill_');
                  }
                  if (hueIsContinuous && hasHue) {
                    // Inject limits and drop=FALSE to include empty bins and keep order
                    const lastParen = scaleCall.lastIndexOf(')');
                    const scaleCallWithBreaks = (lastParen >= 0)
                      ? `${scaleCall.slice(0, lastParen)}, breaks = lvl, drop = FALSE${scaleCall.slice(lastParen)}`
                      : `${scaleCall}, breaks = lvl, drop = FALSE`;
                    lines.push(`  ${scaleCallWithBreaks} +`);
                  } else {
                    lines.push(`  ${scaleCall} +`);
                  }
                }
                } else if (ggPaletteName === 'viridis_d') {
                  const br = (hueIsContinuous && hasHue) ? ', breaks = lvl, drop = FALSE' : '';
                  lines.push(`  scale_${scaleType}_viridis_d(${br ? br.slice(2) : ''}) +`);
                } else {
                  const br = (hueIsContinuous && hasHue) ? ', breaks = lvl, drop = FALSE' : '';
                  lines.push(`  scale_${scaleType}_brewer(palette = "${ggPaletteName}"${br}) +`);
                }
                  const legendPosSide = (legendPos === 'Top Left' || legendPos === 'Top Right') ? 'top'
                                         : (legendPos === 'Bottom Left' || legendPos === 'Bottom Right') ? 'bottom'
                                         : 'right';
                  const legendDir = (legendPosSide === 'top' || legendPosSide === 'bottom') ? 'horizontal' : 'vertical';
                  const ncol = (legendDir === 'horizontal') ? 2 : 1;
                  lines.push(`  guides(${scaleType} = guide_legend(title.position = "top", ncol = ${ncol}, override.aes = list(alpha = 1))) +`);
              }
            }
          }

          // Add labels
          let labsLine = '  labs(';
          const labsParts = [];
          if (title) labsParts.push(`title = "${escapeRStr(title)}"`);
          if (subtitle) labsParts.push(`subtitle = "${escapeRStr(subtitle)}"`);
          if (xLabel) labsParts.push(`x = "${escapeRStr(xLabel)}"`);
          if (yLabel) labsParts.push(`y = "${escapeRStr(yLabel)}"`);
          const legendTitleFinal = legendTitle || (hueIsContinuous ? `${legendVar} (${nBins} bins)` : '');
          // Only add legend titles when an aesthetic is actually mapped
          if (hasHue && mappedAes && legendTitleFinal) {
            labsParts.push(`${mappedAes} = "${escapeRStr(legendTitleFinal)}"`);
          }
          labsLine += labsParts.join(', ') + ') +';
          lines.push(labsLine);

          // Consolidate all theme settings into a single theme() call
          lines.push('');
          lines.push('# --- Consolidated theme configuration ---');
          
          // Collect all theme settings
          const themeSettings = [];
          
          // Determine text color from IMAGE background (white -> very dark grey, else white)
          // Declare early so it can be referenced by legend and axis text theme entries
          const rTextColor = (imgBgChoiceR === 'white') ? '"#111827"' : '"#ffffff"';
          
          // Legend settings
          const legendShouldShow = showLegend && !!mappedAes;
          if (legendShouldShow) {
            // Place legend inside the chart for all positions except "Outside Chart"
            let posExpr = '"right"'; // default outside on right
            let justExpr = null;
            let bgFill = rImg.plot; // image background when outside
            const isInside = (legendPos !== 'Outside Chart');
            if (isInside) {
              // Inside positions with coordinates and matching panel background
              bgFill = rChart.panel;
              if (legendPos === 'Top Left') {
                posExpr = 'c(0.02, 0.98)'; justExpr = 'c(0, 1)';
              } else if (legendPos === 'Top Right') {
                posExpr = 'c(0.98, 0.98)'; justExpr = 'c(1, 1)';
              } else if (legendPos === 'Left') {
                posExpr = 'c(0.02, 0.50)'; justExpr = 'c(0, 0.5)';
              } else if (legendPos === 'Right') {
                posExpr = 'c(0.98, 0.50)'; justExpr = 'c(1, 0.5)';
              }
            }
            
            // Base legend theme
            // Use numeric coordinates and justification for broad ggplot2 compatibility.
            // (ggplot2 3.5 added "inside" support; for older versions we emulate with numeric positions.)
            if (isInside) {
              themeSettings.push(`legend.position = ${posExpr}`);
              if (justExpr) {
                themeSettings.push(`legend.justification = ${justExpr}`);
              }
            } else {
              themeSettings.push(`legend.position = ${posExpr}`);
            }
            themeSettings.push(`legend.title = element_text(size = 10, face = "${rFace}", color = ${rTextColor})`);
            themeSettings.push(`legend.text = element_text(size = 9, color = ${rTextColor})`);
            themeSettings.push('legend.key.width = grid::unit(10, "pt")');
            themeSettings.push('legend.key.height = grid::unit(10, "pt")');
            
            // Legend background (handle border separately)
            if (legendBorder) {
              themeSettings.push(`legend.background = element_rect(fill = ${bgFill}, color = "gray60", size = 0.5)`);
            } else {
              themeSettings.push(`legend.background = element_rect(fill = ${bgFill}, color = NA)`);
            }
            themeSettings.push(`legend.key = element_rect(fill = ${bgFill}, color = NA)`);
            themeSettings.push('legend.box.margin = margin(t = 2, r = 2, b = 2, l = 2)');
            themeSettings.push('legend.spacing = grid::unit(6, "pt")');
          } else if (!showLegend) {
            themeSettings.push('legend.position = "none"');
          }

          // Axis and title formatting settings
          if (safeChartType === 'pie') {
            // For pie, keep void axes but still set backgrounds and text color
            themeSettings.push('aspect.ratio = 0.625');
            themeSettings.push(`plot.title = element_text(face = "${rFace}", color = ${rTextColor})`);
            themeSettings.push(`plot.subtitle = element_text(face = "${rFace}", color = ${rTextColor})`);
            themeSettings.push(`panel.background = element_rect(fill = ${rChart.panel})`);
            // Transparent image background uses NA fill in theme
            if (rImg.isTransparent) {
              themeSettings.push('plot.background = element_rect(fill = NA, color = NA)');
            } else {
              themeSettings.push(`plot.background = element_rect(fill = ${rImg.plot})`);
            }
            // Axis text color for pie not shown (theme_void), but set default plot text color via theme above
          } else {
            themeSettings.push(`plot.title = element_text(face = "${rFace}", color = ${rTextColor})`);
            themeSettings.push(`plot.subtitle = element_text(face = "${rFace}", color = ${rTextColor})`);
            themeSettings.push(`axis.title.x = element_text(face = "${rFace}", color = ${rTextColor})`);
            themeSettings.push(`axis.title.y = element_text(face = "${rFace}", color = ${rTextColor})`);
            // Only rotate x-axis labels for vertical charts
            if (advOrientation !== 'horizontal') {
            themeSettings.push(`axis.text.x = element_text(angle = 45, hjust = 1, size = 9, color = ${rTextColor})`);
            }
            themeSettings.push(`axis.text.y = element_text(size = 9, color = ${rTextColor})`);
            themeSettings.push(`panel.background = element_rect(fill = ${rChart.panel})`);
            if (rImg.isTransparent) {
              themeSettings.push('plot.background = element_rect(fill = NA, color = NA)');
            } else {
              themeSettings.push(`plot.background = element_rect(fill = ${rImg.plot})`);
            }
            // Grid settings
            if (advGridToggle) {
              themeSettings.push(`panel.grid.major = element_line(color = ${rChart.grid}, size = 0.2)`);
              themeSettings.push(`panel.grid.minor = element_line(color = ${rChart.grid}, size = 0.1)`);
            } else {
              // Forcefully disable all grid lines when toggle is off
              themeSettings.push('panel.grid = element_blank()');
              themeSettings.push('panel.grid.major = element_blank()');
              themeSettings.push('panel.grid.minor = element_blank()');
            }
          }
          
          // Add margin settings
          themeSettings.push('plot.margin = margin(t = 6, r = 20, b = 22, l = 10)');
          
          // Add caption settings for watermark and source text
          const captionLeft = (showLegend && (legendPos === 'Top Right' || legendPos === 'Right' || legendPos === 'Outside Chart'));
          themeSettings.push('plot.caption.position = "plot"');
          themeSettings.push(`plot.caption = element_text(hjust = ${captionLeft ? '0' : '1'})`);

          // Output single consolidated theme() call
          if (themeSettings.length > 0) {
            lines.push('  theme(');
            for (let i = 0; i < themeSettings.length; i++) {
              const setting = themeSettings[i];
              const isLast = (i === themeSettings.length - 1);
              lines.push(`    ${setting}${isLast ? '' : ','}`);
            }
            lines.push('  ) +');
          }

          // Apply horizontal orientation for bar, box, violin, strip, and jitter charts, if requested
          if ((['bar', 'box', 'violin', 'strip', 'jitter'].includes(safeChartType)) && advOrientation === 'horizontal') {
            lines.push('  coord_flip() +');
          }

          // Add caption with source text and watermark
          lines.push('');
          lines.push('# Add caption with source text and watermark');
          let captionText = '';
          if (sourceText) {
            captionText = `${sourceText} | Vegachart.com`;
          } else {
            captionText = 'Vegachart.com';
          }
          // Add caption with source text and watermark
          // Only append coord_cartesian(clip = "off") for violin plots; for others, end the existing chain at labs()
          if (safeChartType === 'violin') {
            lines.push(`  labs(caption = "${escapeRStr(captionText)}") +`);
            lines.push('  coord_cartesian(clip = "off")');
          } else {
            // Chain labs() onto the existing ggplot object to avoid a stray trailing '+' on the previous line
            lines.push(`  labs(caption = "${escapeRStr(captionText)}")`);
          }
          lines.push('');
          lines.push('# Plot will render automatically when you run this code');

          return lines.join('\n');
        }

        function tryUpdateRCodePreview() {
          const selectedLang = document.querySelector('.library-btn.active')?.dataset.lang;
          if (selectedLang !== 'R') return;
          let code = '';
          try {
            code = rCodeFromInputs();
          } catch(_) {
            code = rDefaultTemplate();
          }
          const ed = document.getElementById('code-editor');
          if (!ed) return;
          // Only overwrite if the current content is empty or previously auto-generated
          const current = ed.value || '';
          if (!current.trim() || current === autoRCode) {
            // Update both Monaco editor and textarea
            if (typeof monacoEditor !== 'undefined' && monacoEditor) { 
              monacoEditor.setValue(code); 
            }
            ed.value = code;
          }
          autoRCode = code;
          // Update edited state and reset visibility
          try {
            isREdited = (ed.value !== autoRCode) ? true : false;
          } catch(_) { isREdited = false; }
          updateResetButtonVisibility();
        }

        function tryUpdatePythonCodePreview() {
          const selectedLang = document.querySelector('.library-btn.active')?.dataset.lang;
          if (selectedLang !== 'Python') return;
          let code = '';
          try {
            code = pyCodeFromInputs();
          } catch(_) {
            code = pyDefaultTemplate();
          }
          const ed = document.getElementById('code-editor');
          if (!ed) return;
          // Only overwrite if the current content is empty or previously auto-generated
          const current = ed.value || '';
          if (!current.trim() || current === autoPyCode) {
            // Update both Monaco editor and textarea
            if (typeof monacoEditor !== 'undefined' && monacoEditor) { 
              monacoEditor.setValue(code); 
            }
            ed.value = code;
          }
          autoPyCode = code;
          // Update edited state and reset visibility
          try {
            isPyEdited = (ed.value !== autoPyCode) ? true : false;
          } catch(_) { isPyEdited = false; }
          updateResetButtonVisibility();
        }

        function tryUpdateCodePreview() {
          updateAdvancedLabel(); // Update advanced label text based on axis types
          const selectedLang = document.querySelector('.library-btn.active')?.dataset.lang;
          if (selectedLang === 'JavaScript') {
            tryUpdateJSCodePreview();
          } else if (selectedLang === 'Python') {
            tryUpdatePythonCodePreview();
          } else if (selectedLang === 'R') {
            tryUpdateRCodePreview();
          }
        }

        // Centralized function to manage chart display states
        function setChartDisplayState(state, content = '') {
          const chartDiv = document.getElementById('chartCanvas');
          const chartPlaceholder = document.getElementById('chart-placeholder');
          const centerMessage = document.getElementById('chart-center-message');
          
          if (!chartDiv) return;
          
          // Remove any existing center messages for non-plotly states
          if (state !== 'plotly' && centerMessage) centerMessage.remove();
          
          switch (state) {
            case 'placeholder':
              // Show placeholder icon
              // Clear any existing chart/content
              try { if (window.currentChart) { Plotly.purge(chartDiv); window.currentChart = null; currentChart = null; } } catch(_) {}
              chartDiv.innerHTML = '';
              if (chartPlaceholder) chartPlaceholder.classList.remove('hidden');
              setChartActionsEnabled(false);
              break;
              
            case 'loading':
              // Hide placeholder and show loading spinner
              try { if (window.currentChart) { Plotly.purge(chartDiv); window.currentChart = null; currentChart = null; } } catch(_) {}
              if (chartPlaceholder) chartPlaceholder.classList.add('hidden');
              chartDiv.innerHTML = `
                <div class="flex items-center justify-center h-full">
                  <div class="text-center">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-3"></div>
                    <p class="text-gray-400 text-sm">${content}</p>
                  </div>
                </div>
              `;
              setChartActionsEnabled(false);
              break;
              
            case 'success':
              // Hide placeholder, clear div, content will be added separately
              try { if (window.currentChart) { Plotly.purge(chartDiv); window.currentChart = null; currentChart = null; } } catch(_) {}
              if (chartPlaceholder) chartPlaceholder.classList.add('hidden');
              chartDiv.innerHTML = '';
              setChartActionsEnabled(true);
              break;
              
            case 'error':
              // Hide placeholder and show error message
              try { if (window.currentChart) { Plotly.purge(chartDiv); window.currentChart = null; currentChart = null; } } catch(_) {}
              if (chartPlaceholder) chartPlaceholder.classList.add('hidden');
              chartDiv.innerHTML = content;
              setChartActionsEnabled(false);
              break;
              
            case 'plotly':
              // For Plotly.js charts - hide placeholder, keep currentChart tracking
              if (chartPlaceholder) chartPlaceholder.classList.add('hidden');
              setChartActionsEnabled(true);
              break;
          }
          // Record state for other UI handlers (e.g., switching libraries)
          chartDisplayState = state;
          try { window.chartDisplayState = state; } catch(_) {}
        }

        // Helper: clear any existing visual content (images/plots/messages)
        function clearChartArea() {
          const chartDiv = document.getElementById('chartCanvas');
          if (!chartDiv) return;
          try { document.getElementById('chart-center-message')?.remove(); } catch(_) {}
          try { if (window.currentChart) { Plotly.purge(chartDiv); } } catch(_) {}
          try { window.currentChart = null; } catch(_) {}
          try { currentChart = null; } catch(_) {}
          try { window.VC_BACKEND_IMAGE_BLOB = null; } catch(_) {}
          try { chartDiv.innerHTML = ''; } catch(_) {}
          try { document.getElementById('chart-placeholder')?.classList.add('hidden'); } catch(_) {}
        }

        // Backend communication function for Python/R code execution
        async function executeCodeOnBackend(language, code) {
          const chartDiv = document.getElementById('chartCanvas');
          if (!chartDiv) throw new Error('Chart canvas not found');

          try {
            // Set loading state
            setChartDisplayState('loading', `Executing ${language} code...`);

            // Make request to Flask backend
            const response = await fetch('https://vega-chart-9cee83c4aa24.herokuapp.com/api/generate-chart', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                language: language.toLowerCase(),
                code: code,
                data: uploadedData || null,  // Send parsed CSV data if available
                // Background selections for backend wrappers
                imgBgChoice: (document.getElementById('adv-image-bg')?.value) || 'default',
                chartBgChoice: (document.getElementById('adv-chart-bg')?.value) || 'default',
                showGridLines: !!document.getElementById('adv-grid-toggle')?.checked,
                // Legacy field for backward compatibility
                bgChoice: (document.getElementById('adv-image-bg')?.value) || 'default'
              })
            });

            if (response.ok) {
              // Success: response is a PNG image
              const blob = await response.blob();
              const imageUrl = URL.createObjectURL(blob);
              try { window.VC_BACKEND_IMAGE_BLOB = blob; } catch(_) {}
              
              // Set success state and add the image
              setChartDisplayState('success');
              
              const img = document.createElement('img');
              img.src = imageUrl;
              img.style.width = '100%';
              img.style.height = '100%';
              img.style.objectFit = 'contain';
              img.alt = `${language} generated chart`;
              
              // Clean up the object URL when the image loads
              img.onload = () => {
                URL.revokeObjectURL(imageUrl);
              };
              
              chartDiv.appendChild(img);
              
            } else {
              // Error: response is JSON with error message
              const errorData = await response.json();
              const errorMessage = errorData.error || 'Unknown error occurred';
              
              // Set error state with formatted message
              setChartDisplayState('error', `
                <div class="flex items-center justify-center h-full">
                  <div class="text-center max-w-md px-4">
                    <div class="text-red-400 text-lg mb-2">⚠ Code Execution Error</div>
                    <pre class="text-red-300 text-sm bg-red-900/20 p-3 rounded border border-red-600/30 text-left whitespace-pre-wrap">${errorMessage}</pre>
                    <p class="text-gray-400 text-xs mt-2">Check your ${language} code for syntax errors or missing dependencies.</p>
                  </div>
                </div>
              `);
            }

          } catch (error) {
            // Network or other errors
            const errorMessage = error.message || 'Failed to connect to backend server';
            
            // Set error state with network error message
            setChartDisplayState('error', `
              <div class="flex items-center justify-center h-full">
                <div class="text-center max-w-md px-4">
                  <div class="text-red-400 text-lg mb-2">🔌 Connection Error</div>
                  <p class="text-red-300 text-sm bg-red-900/20 p-3 rounded border border-red-600/30">${errorMessage}</p>
                  <p class="text-gray-400 text-xs mt-2">Make sure the Flask backend server is running on http://127.0.0.1:5000</p>
                </div>
              </div>
            `);
          }
        }

        async function generateChart() {
          const chartDiv = chartCanvas;
          if (!chartDiv) return;
          try {
            // Remove any previous center message (if any)
            document.getElementById('chart-center-message')?.remove();
            
            // Get the currently selected language
            const selectedLang = document.querySelector('.library-btn.active')?.dataset.lang;
            
            // Handle Python and R code execution via backend
            if (selectedLang === 'Python' || selectedLang === 'R') {
              // Immediately reflect executing state and remove any previous chart
              setChartDisplayState('loading', `Executing ${selectedLang} code...`);
              // Get code from Monaco editor
              const code = monacoEditor ? monacoEditor.getValue() : '';
              
              if (!code || !code.trim()) {
                // revert to placeholder only if nothing was previously shown
                setChartDisplayState('error', `
                  <div class="flex items-center justify-center h-full">
                    <div class="text-center max-w-md px-4">
                      <div class="text-red-400 text-lg mb-2">⚠ Missing Code</div>
                      <p class="text-red-300 text-sm">Please enter ${selectedLang} code in the editor</p>
                    </div>
                  </div>
                `);
                showToast(`Please enter ${selectedLang} code in the editor`);
                return;
              }
              
              // Execute code on backend
              await executeCodeOnBackend(selectedLang, code);
              return;
            }
            
            // Handle JavaScript execution (existing logic)
            if (selectedLang === 'JavaScript') {
              const ed = document.getElementById('code-editor');
              const custom = ed && typeof ed.value === 'string' ? ed.value.trim() : '';
              if (custom && (isCodeEdited || custom !== autoJSCode)) {
                // Before running user JS, clear any previous Python/R image or Plotly chart
                clearChartArea();
                runUserJS();
                return;
              }
            }
            
            // Continue with Plotly.js preview for JavaScript (existing logic)
            if (selectedLang !== 'JavaScript') {
              showToast('Chart preview only available for JavaScript');
              return;
            }
            const cfg = buildChartConfig();
            
            // Smart watermark positioning: opposite side of source text
            const sourceText = document.getElementById('source-text')?.value || '';
            let watermarkX = 1;
            let watermarkXAnchor = 'right';
            const watermarkY = VC_FOOTER_ANNOT_Y; // unified footer annotation position

            if (sourceText) {
              // Try to detect source annotation within cfg.layout
              const anns = Array.isArray(cfg?.layout?.annotations) ? cfg.layout.annotations : [];
              const srcAnn = anns.find(a => typeof a?.text === 'string' && a.text === sourceText);
              if (srcAnn) {
                const srcIsRight = (String(srcAnn.xanchor).toLowerCase() === 'right') || (typeof srcAnn.x === 'number' && srcAnn.x >= 0.5);
                if (srcIsRight) { watermarkX = 0; watermarkXAnchor = 'left'; }
                else { watermarkX = 1; watermarkXAnchor = 'right'; }
              } else {
                // Fallback: in our generated layouts, source defaults to right
                watermarkX = 0; watermarkXAnchor = 'left';
              }
            }
            
            // Add Vegachart.com watermark to the layout
            const layoutWithWatermark = { ...cfg.layout };
            if (!layoutWithWatermark.annotations) {
              layoutWithWatermark.annotations = [];
            }
            layoutWithWatermark.annotations.push({
              text: "Vegachart.com",
              showarrow: false,
              x: watermarkX,
              y: watermarkY,
              xref: "paper",
              yref: "paper",
              xanchor: watermarkXAnchor,
              yanchor: "top",
              font: { size: 10, color: "#9ca3af" },
              bgcolor: "rgba(0,0,0,0)",
              bordercolor: "rgba(0,0,0,0)"
            });

            // Ensure adequate margin padding for watermark and other annotations
            const finalLayout = ensureAnnotationPadding(layoutWithWatermark, {
              contextWidth: chartDiv?.clientWidth || 480,
              contextHeight: chartDiv?.clientHeight || 360
            });
            
            // For JavaScript preview, clear previous (including Python/R images) to avoid overlay
            clearChartArea();
            
            Plotly.newPlot(chartDiv, cfg.data, finalLayout, { responsive: true, displayModeBar: false, displaylogo: false, showTips: false })
              .then(() => {
                setChartDisplayState('plotly');
                // --- Top Legend Auto-Wrap (JS version) ------------------------------------
                // Some Plotly versions don't wrap horizontal legends placed at the top; when
                // there are many categories the right-most items get clipped. We detect
                // overflow and manually re-flow legend items into multiple rows.
                (function autoWrapTopLegend(){
                  try {
                    if (!cfg || !cfg.layout || !cfg.layout.legend) return;
                    const lg = cfg.layout.legend;
                    const isTopHorizontal = lg.orientation === 'h' && (lg.yanchor === 'bottom');
                    if (!isTopHorizontal) return; // only affect top horizontal legends
                    const legendNode = chartDiv.querySelector('.legend');
                    if (!legendNode) return;
                    // Guard so we only attempt a full wrap once per render
                    if (legendNode.getAttribute('data-wrapped') === 'true') return;
                    const containerW = chartDiv.clientWidth || (chartDiv.getBoundingClientRect().width || 0);
                    if (containerW <= 0) return;
                    const maxWidth = Math.max(200, containerW - 48); // leave some horizontal padding
                    // Legend item <g> elements usually live under: g.legend > g.scrollbox > g.legend > g.traces > g.legendtoggle
                    // We target the immediate children that carry a transform.
                    const itemNodes = legendNode.querySelectorAll('g.traces > g.legendtoggle');
                    if (!itemNodes.length) return;
                    // Compute total width; if it already fits, skip.
                    let total = 0;
                    itemNodes.forEach(n => { const bb = n.getBoundingClientRect(); total += (bb?.width || 0) + 12; });
                    if (total <= maxWidth) { legendNode.setAttribute('data-wrapped','true'); return; }
                    let x = 0, y = 0, rowH = 0;
                    const gap = 12;
                    // Determine reference box BEFORE we mutate (used later for margin calc)
                    const firstBB = legendNode.getBoundingClientRect();
                    itemNodes.forEach(n => {
                      const bb = n.getBoundingClientRect();
                      const w = (bb?.width || 0);
                      const h = (bb?.height || 0);
                      if (x > 0 && (x + w) > maxWidth) { // wrap to next line
                        x = 0;
                        y += rowH + 4; // small vertical gap
                        rowH = 0;
                      }
                      n.setAttribute('transform', `translate(${x},${y})`);
                      x += w + gap;
                      if (h > rowH) rowH = h;
                    });
                    const usedHeight = y + rowH + 6; // final legend height
                    // Adjust legend background rect if present
                    const bgRect = legendNode.querySelector('rect.bg');
                    if (bgRect) {
                      try {
                        bgRect.setAttribute('width', Math.min(maxWidth, maxWidth));
                        bgRect.setAttribute('height', usedHeight);
                      } catch(_) {}
                    }
                    // If our wrapped legend became taller than a single row, expand the top margin
                    // so it doesn't overlap plot area. We approximate a single-row height at 26px.
                    if (usedHeight > 26) {
                      const extraNeeded = usedHeight - 26;
                      const currentTop = (cfg.layout && cfg.layout.margin && typeof cfg.layout.margin.t === 'number') ? cfg.layout.margin.t : 64;
                      Plotly.relayout(chartDiv, { 'margin.t': currentTop + extraNeeded }).catch(()=>{});
                    }
                    legendNode.setAttribute('data-wrapped','true');
                  } catch(e) { /* swallow */ }
                  // Re-run shortly after font/layout stabilization to catch late width changes
                  setTimeout(() => {
                    try {
                      const ln = chartDiv.querySelector('.legend');
                      if (ln && ln.getAttribute('data-rewrap') !== 'done') {
                        ln.removeAttribute('data-wrapped'); // allow re-wrap attempt
                        ln.setAttribute('data-rewrap','done');
                        autoWrapTopLegend();
                      }
                    } catch(_) {}
                  }, 120);
                })();
                // ---------------------------------------------------------------------------
                // Post-render adjustment with retries to prevent overlap between top legend and title/subtitle
                let attempts = 0;
                const MAX_ATTEMPTS = 4; // initial + 3 retries
                let adjustedOnce = false; // idempotence guard
                function attemptAdjust() {
                  attempts++;
                  try {
                    const plotContainer = chartDiv.querySelector('.plot-container');
                    if (!plotContainer) return;
                    const titleNode = chartDiv.querySelector('.gtitle');
                    const legendNode = chartDiv.querySelector('.legend');
                    if (!titleNode || !legendNode) return;
                    const legendOrientationTop = !!cfg.layout.legend && cfg.layout.legend.orientation === 'h' && (cfg.layout.legend.yanchor === 'bottom');
                    if (!legendOrientationTop) return;
                    function bbox(el){ try { return el.getBoundingClientRect(); } catch(_) { return null; } }
                    const titleBB = bbox(titleNode);
                    const legendBB = bbox(legendNode);
                    if (!titleBB || !legendBB) return;
                    const overlaps = legendBB.top < (titleBB.bottom - 2);
                    if (!overlaps) return; // no adjustment needed this attempt
                    if (adjustedOnce) return; // already adjusted previously
                    const containerBB = bbox(chartDiv) || { height: 480 };
                    // Revised strategy: keep legend near its original anchor and expand top margin instead of pushing legend into plot.
                    const baseLegendY = (typeof cfg.layout.legend.y === 'number') ? cfg.layout.legend.y : 1.08;
                    const pixelsNeeded = (titleBB.bottom + 2) - legendBB.top; // minimal cushion
                    const existingTopMargin = (cfg.layout.margin && typeof cfg.layout.margin.t === 'number') ? cfg.layout.margin.t : 64;
                    const updatedTopMargin = existingTopMargin + Math.max(0, Math.ceil(pixelsNeeded + 2));
                    // Slight upward nudge for title if there's headroom; don't exceed 0.99 to avoid clipping
                    const currentTitleY = (cfg.layout.title && typeof cfg.layout.title.y === 'number') ? cfg.layout.title.y : 0.955;
                    let newTitleY = Math.min(0.99, currentTitleY + 0.008); // fixed small bump
                    Plotly.relayout(chartDiv, { 'legend.y': baseLegendY, 'title.y': newTitleY, 'margin.t': updatedTopMargin })
                      .then(() => {
                        // After relayout, ensure legend is not clipped at very top of container
                        try {
                          const freshLegendBB = bbox(chartDiv.querySelector('.legend'));
                          const freshContainerBB = bbox(chartDiv);
                          if (freshLegendBB && freshContainerBB) {
                            const minTop = freshContainerBB.top + 4; // 4px safe padding
                            if (freshLegendBB.top < minTop) {
                              const morePixels = (minTop - freshLegendBB.top);
                              // Expand top margin further; keep legend y constant to avoid drifting
                              const adjustedY = baseLegendY;
                              Plotly.relayout(chartDiv, {
                                'legend.y': adjustedY,
                                // increase top margin further so plot area stays clear
                                'margin.t': updatedTopMargin + Math.ceil(morePixels)
                              });
                            }
                          }
                        } catch(_) {}
                      });
                    adjustedOnce = true; // prevent further growth
                  } catch(_) {}
                  if (attempts < MAX_ATTEMPTS && !adjustedOnce) {
                    setTimeout(attemptAdjust, 60 * attempts); // incremental backoff
                  }
                }
                // Run immediately and schedule retries in case SVG layout shifts after fonts load
                attemptAdjust();
              });
            // Attach zoom/pan listener to surface a consistent toast-style hint
            if (chartDiv && chartDiv.on) {
              chartDiv.removeAllListeners && chartDiv.removeAllListeners('plotly_relayout');
              chartDiv.on('plotly_relayout', (ev) => {
                if (ev && Object.keys(ev).some(k => k.includes('range'))) {
                  maybeShowZoomHint();
                }
              });
            }
            currentChart = true;
            // Chart display state is already handled by setChartDisplayState('plotly')
            // Update JS code preview if JS tab selected
          if (selectedLang === 'JavaScript') {
              const code = postProcessJSCode(jsCodeFromConfig(cfg));
              autoJSCode = code;
              if (!isCodeEdited) {
                const ed = document.getElementById('code-editor');
                if (ed) ed.value = code;
                currentJSCode = code;
              }
              updateResetButtonVisibility();
          }
          } catch (e) {
            console.warn(e);
            // simple inline notification
            const msg = typeof e?.message === 'string' ? e.message : 'Failed to generate chart.';
            const container = chartDiv.parentElement;
            if (msg === 'Please upload data to display first') {
              // Show placeholder with special upload instruction
              setChartDisplayState('placeholder');
              const center = document.getElementById('chart-placeholder-center');
              if (center) {
                center.innerHTML = '<p id="upload-hint" class="text-gray-400 text-sm">Please upload data to display first</p>';
                const hint = document.getElementById('upload-hint');
                if (hint) {
                  // Flash red briefly, then return to gray
                  hint.classList.remove('text-gray-400');
                  hint.classList.add('text-red-400');
                  setTimeout(() => {
                    hint.classList.remove('text-red-400');
                    hint.classList.add('text-gray-400');
                  }, 700);
                }
              }
            } else {
              // Show error state with message
              setChartDisplayState('error', `
                <div class="flex items-center justify-center h-full">
                  <div class="text-center">
                    <div class="text-red-400 text-sm">${msg}</div>
                  </div>
                </div>
              `);
            }
          }
        }

        document.getElementById('generate-chart-btn')?.addEventListener('click', generateChart);

        function partialLayoutFromInputs() {
          const title = document.getElementById('chart-title')?.value || '';
          const subtitle = document.getElementById('chart-subtitle')?.value || '';
          const xLabel = document.getElementById('x-axis-label')?.value || '';
          const yLabel = document.getElementById('y-axis-label')?.value || '';
          const sourceText = document.getElementById('source-text')?.value || '';
          const showLegend = !!document.getElementById('show-legend')?.checked;
          const legendTitle = document.getElementById('legend-title')?.value || '';
          const legendPosition = document.getElementById('legend-position')?.value || '';
          const legendBorder = !!document.getElementById('legend-border')?.checked;
          const imgBgChoice = (document.getElementById('adv-image-bg')?.value) || 'default';
          const chartBgChoice = (document.getElementById('adv-chart-bg')?.value) || 'default';
          // Reuse resolvers from buildChartConfig scope
          function __resolveImageBg(choice) {
            switch (choice) {
              case 'transparent': return 'rgba(0,0,0,0)';
              case 'white': return '#ffffff';
              case 'blue': return '#0b1220';
              case 'default':
              default: return '#0a0a0a';
            }
          }
          function __resolveChartBg(choice) {
            switch (choice) {
              case 'transparent': return 'rgba(0,0,0,0)';
              case 'white': return '#ffffff';
              case 'blue': return '#8ac0db';
              case 'green': return '#8adba5';
              case 'yellow': return '#fee14e';
              case 'orange': return '#fd732d';
              case 'purple': return '#ce8adb';
              case 'teal': return '#76d3cf';
              case 'default':
              default: return 'rgba(0,0,0,0)';
            }
          }
          const bg = { paper: __resolveImageBg(imgBgChoice), plot: __resolveChartBg(chartBgChoice) };
          const textColor = (imgBgChoice === 'white') ? '#111827' : '#ffffff';

          const layout = { paper_bgcolor: bg.paper, plot_bgcolor: bg.plot, font: { color: textColor }, title: { font: { color: textColor } }, xaxis: { tickfont: { color: textColor }, title: { font: { color: textColor } } }, yaxis: { tickfont: { color: textColor }, title: { font: { color: textColor } } } };
          const topLegend = showLegend && (legendPosition === 'Top Right' || legendPosition === 'Top Left');
          if (title || subtitle) {
            layout.title = { text: styleTitleAndSubtitle(title, subtitle), y: (topLegend ? 0.955 : 0.98), yanchor: 'top' };
          }
          if (xLabel) { layout.xaxis = { ...(layout.xaxis||{}), title: { text: styleText(xLabel) } }; }
          if (yLabel) { layout.yaxis = { ...(layout.yaxis||{}), title: { text: styleText(yLabel) } }; }
          if (sourceText) {
            const annotationColor = (imgBgChoice === 'white') ? '#4b5563' : '#9ca3af';
            layout.margin = { ...(layout.margin||{}), b: 96 };
            layout.annotations = [
              {
                text: sourceText,
                x: 1, xref: 'paper', xanchor: 'right',
                y: VC_FOOTER_ANNOT_Y, yref: 'paper', yanchor: 'top',
                showarrow: false, align: 'right',
                font: { color: annotationColor, size: 11 }
              }
            ];
          }
          if (showLegend) {
            const legend = {};
            if (legendTitle) legend.title = { text: styleText(legendTitle) };
            if (legendBorder) { legend.bordercolor = '#4b5563'; legend.borderwidth = 1; }
            legend.bgcolor = bg.paper;
            // basic anchor positions if set
            const anchorMap = {
              'Top Right':    { x: 1,    xanchor: 'right', y: 1.08, yanchor: 'bottom' },
              'Top Left':     { x: 0,    xanchor: 'left',  y: 1.08, yanchor: 'bottom' },
              'Right':        { x: 1,    xanchor: 'right', y: 0.5,  yanchor: 'middle' },
              'Left':         { x: 0,    xanchor: 'left',  y: 0.5,  yanchor: 'middle' },
              'Outside Chart':{ x: 1.02, xanchor: 'left',  y: 1,    yanchor: 'top' },
            };
            const pos = anchorMap[legendPosition];
            if (pos) Object.assign(legend, pos);
            // Horizontal legend when positioned at the top
            legend.orientation = (legendPosition === 'Top Right' || legendPosition === 'Top Left') ? 'h' : 'v';
            layout.showlegend = true;
            layout.legend = legend;
            // Make room above the plot when top legend is used (dynamic rows)
            if (topLegend) {
              const base = (layout.margin?.t ?? (title ? 64 : 34));
              try {
                // Attempt to estimate legend item count from currently generated traces if any exist globally
                // or derive from uploadedData + legend variable selection.
                let itemCount = 0;
                // If we have a global currentChart with data, use its legend-enabled traces
                if (window.currentChart && Array.isArray(window.currentChart.data)) {
                  itemCount = window.currentChart.data.filter(t => t && t.showlegend !== false).length;
                }
                // Fallback: approximate via selected axis/grouping choices
                if (!itemCount) {
                  const groupBySel = document.getElementById('group-by');
                  const legendVar = groupBySel?.value || '';
                  if (legendVar && Array.isArray(uploadedData) && uploadedData.length) {
                    const uniqueVals = Array.from(new Set(uploadedData.map(r => r[legendVar]).filter(v => v !== undefined && v !== '')));
                    itemCount = uniqueVals.length;
                  }
                }
                if (!itemCount) {
                  layout.margin = { ...(layout.margin||{}), t: base + 26 };
                } else {
                  const perRow = 6;
                  const rows = Math.max(1, Math.ceil(itemCount / perRow));
                  const extra = 26 + (rows - 1) * 25;
                  layout.margin = { ...(layout.margin||{}), t: base + extra };
                }
              } catch(_) {
                layout.margin = { ...(layout.margin||{}), t: base + 26 };
              }
            }
          } else {
            layout.showlegend = false;
            delete layout.legend;
          }
          return layout;
        }

        function codeFromPartialLayout(layout) {
          // Add watermark to layout
          const layoutWithWatermark = { ...layout };
          if (!layoutWithWatermark.annotations) {
            layoutWithWatermark.annotations = [];
          }
          // Smart watermark position opposite to source text (if present)
          let wmX = 1, wmAnchor = 'right';
          try {
            const srcText = document.getElementById('source-text')?.value || '';
            if (srcText) {
              const anns = Array.isArray(layoutWithWatermark.annotations) ? layoutWithWatermark.annotations : [];
              const srcAnn = anns.find(a => typeof a?.text === 'string' && a.text === srcText);
              if (srcAnn) {
                const srcIsRight = (String(srcAnn.xanchor).toLowerCase() === 'right') || (typeof srcAnn.x === 'number' && srcAnn.x >= 0.5);
                if (srcIsRight) { wmX = 0; wmAnchor = 'left'; } else { wmX = 1; wmAnchor = 'right'; }
              } else {
                // Fallback: assume source on right in our partial layout
                wmX = 0; wmAnchor = 'left';
              }
            }
          } catch(_) {}
          layoutWithWatermark.annotations.push({
            text: "Vegachart.com",
            showarrow: false,
            x: wmX,
            y: VC_FOOTER_ANNOT_Y,
            xref: "paper",
            yref: "paper",
            xanchor: wmAnchor,
            yanchor: "top",
            font: { size: 10, color: "#9ca3af" },
            bgcolor: "rgba(0,0,0,0)",
            bordercolor: "rgba(0,0,0,0)"
          });
          
          const layoutStr = JSON.stringify(layoutWithWatermark, null, 2);
          const suggested = (window.VC_LAST_FILE && window.VC_LAST_FILE.name) ? window.VC_LAST_FILE.name : 'your_data.csv';
          const fileStr = JSON.stringify(suggested);
          return `// JavaScript (Plotly.js)\n// Example: load a CSV file and plot\nconst file = ${fileStr};\n\nasync function csvToJSON(url) {\n  const res = await fetch(url);\n  const text = await res.text();\n  const lines = text.split(/\\r?\\n/).filter(l => l.trim().length);\n  if (lines.length === 0) return [];\n  const delimiter = text.includes('\t') ? '\t' : ',';\n  const parseLine = (line) => {\n    const result = [];\n    let cur = '', inQuotes = false;\n    for (let i = 0; i < line.length; i++) {\n      const ch = line[i];\n      if (ch === '"') {\n        if (inQuotes && line[i+1] === '"') { cur += '"'; i++; }\n        else { inQuotes = !inQuotes; }\n      } else if (!inQuotes && ch === delimiter) {\n        result.push(cur); cur = '';\n      } else {\n        cur += ch;\n      }\n    }\n    result.push(cur);\n    return result;\n  };\n  const header = parseLine(lines[0]).map(h => h.trim());\n  return lines.slice(1).map(l => {\n    const cells = parseLine(l);\n    const obj = {};\n    header.forEach((h, i) => { obj[h] = cells[i]; });\n    return obj;\n  });\n}\n\n// Ensure adequate margin padding for watermark and annotations\nfunction ensureAnnotationPadding(layout, dims = {}) {\n  try {\n    if (!layout || typeof layout !== 'object') return layout;\n    const annotations = Array.isArray(layout.annotations) ? layout.annotations : [];\n    if (!annotations.length) return layout;\n    const margin = (layout.margin && typeof layout.margin === 'object') ? { ...layout.margin } : {};\n    let changed = false;\n    const usableHeight = Math.max(360, Number.isFinite(dims?.contextHeight) ? dims?.contextHeight : 0);\n    const usableWidth = Math.max(480, Number.isFinite(dims?.contextWidth) ? dims?.contextWidth : 0);\n    const fallbackMargin = { l: 64, r: 32, t: 64, b: 64 };\n    const ensureSide = (side, required) => {\n      const base = margin[side] !== undefined ? margin[side] : fallbackMargin[side];\n      const target = Math.max(base, required);\n      if (target !== base) { margin[side] = target; changed = true; }\n    };\n    for (const ann of annotations) {\n      if (!ann || ann.visible === false) continue;\n      const fontSize = typeof ann?.font?.size === 'number' ? ann.font.size : 12;\n      const pad = fontSize + 6;\n      const x = typeof ann?.x === 'number' ? ann.x : null;\n      const y = typeof ann?.y === 'number' ? ann.y : null;\n      const xref = String(ann?.xref || 'paper').toLowerCase();\n      const yref = String(ann?.yref || 'paper').toLowerCase();\n      if (yref === 'paper' && y !== null) {\n        if (y < 0) { const needed = pad + Math.round(-y * usableHeight); ensureSide('b', needed); }\n        else if (y > 1) { const needed = pad + Math.round((y - 1) * usableHeight); ensureSide('t', needed); }\n      }\n      if (xref === 'paper' && x !== null) {\n        if (x < 0) { const needed = pad + Math.round(-x * usableWidth); ensureSide('l', needed); }\n        else if (x > 1) { const needed = pad + Math.round((x - 1) * usableWidth); ensureSide('r', needed); }\n      }\n    }\n    if (changed) { layout.margin = { ...layout.margin, ...margin }; }\n    return layout;\n  } catch (_) { return layout; }\n}\n\n// Load rows (not used in this basic template)\nconst rows = await csvToJSON(file);\n\nconst data = [];\nlet layout = ${layoutStr || '{ }'};\n\n// Apply padding for annotations including watermark\nconst chartCanvas = document.getElementById('chartCanvas');\nlayout = ensureAnnotationPadding(layout, {\n  contextWidth: chartCanvas?.clientWidth || 480,\n  contextHeight: chartCanvas?.clientHeight || 360\n});\n\nconst config = { responsive: true, displayModeBar: false, displaylogo: false, showTips: false };\nPlotly.newPlot('chartCanvas', data, layout, config);`;
        }

        function tryUpdateJSCodePreview() {
          const selectedLang = document.querySelector('.library-btn.active')?.dataset.lang;
          if (selectedLang !== 'JavaScript') return;
          const ed = document.getElementById('code-editor');
          // Prefer full config if possible, else fall back to partial layout
          try {
            const cfg = buildChartConfig();
            const code = postProcessJSCode(jsCodeFromConfig(cfg));
            autoJSCode = code;
            if (!isCodeEdited) {
              if (typeof monacoEditor !== 'undefined' && monacoEditor) { monacoEditor.setValue(code); }
              if (ed) { ed.value = code; }
              currentJSCode = code;
            }
            updateResetButtonVisibility();
          } catch (_) {
            const layout = partialLayoutFromInputs();
            const code = postProcessJSCode(codeFromPartialLayout(layout));
            autoJSCode = code;
            if (!isCodeEdited) {
              if (typeof monacoEditor !== 'undefined' && monacoEditor) { monacoEditor.setValue(code); }
              if (ed) { ed.value = code; }
              currentJSCode = code;
            }
            updateResetButtonVisibility();
          }
        }

        // --- Copy/Download handlers ---
        // Filename helpers (prefer chart title, fallback to uploaded file name, else default)
        function sanitizeFileStem(stem) {
          try {
            const cleaned = String(stem || '')
              .replace(/[\\/:*?"<>|]+/g, '_') // Windows-invalid chars
              .replace(/\s+/g, ' ')            // collapse whitespace
              .trim()
              .replace(/\.+$/g, '')           // trailing dots
              || 'vega_chart';
            return cleaned.slice(0, 200); // reasonable length cap
          } catch(_) { return 'vega_chart'; }
        }
        function getChartFilenameStem() {
          const title = document.getElementById('chart-title')?.value?.trim();
          if (title) return sanitizeFileStem(title);
          const last = (window.VC_LAST_FILE && window.VC_LAST_FILE.name) ? window.VC_LAST_FILE.name : '';
          if (last) {
            const dot = last.lastIndexOf('.');
            const base = dot > 0 ? last.slice(0, dot) : last;
            return sanitizeFileStem(base);
          }
          return 'vega_chart';
        }
        function showToast(text) {
          const t = document.createElement('div');
          t.textContent = text;
          t.className = 'fixed bottom-6 right-6 bg-gray-900/95 border border-gray-700 text-gray-200 px-3 py-2 rounded-md shadow z-50 text-sm';
          document.body.appendChild(t);
          setTimeout(()=>{ t.classList.add('opacity-0'); t.style.transition='opacity 300ms'; }, 1200);
          setTimeout(()=> t.remove(), 1600);
        }
        // Throttle helper for showing zoom back-out hint as a toast
        let lastZoomHint = 0;
        function maybeShowZoomHint() {
          const now = Date.now();
          if (now - lastZoomHint > 1500) {
            lastZoomHint = now;
            showToast('Double-click to zoom back out');
          }
        }
        async function copyChartImage() {
          try {
            const backendBlob = (typeof window !== 'undefined') ? window.VC_BACKEND_IMAGE_BLOB : null;
            if (backendBlob instanceof Blob) {
              if (navigator.clipboard && window.ClipboardItem) {
                await navigator.clipboard.write([new ClipboardItem({ [backendBlob.type || 'image/png']: backendBlob })]);
                showToast('Chart image copied');
              } else {
                // Fallback: trigger download with proper name
                const url = URL.createObjectURL(backendBlob);
                const a = document.createElement('a');
                a.href = url; a.download = `${getChartFilenameStem()}.png`; a.click();
                setTimeout(()=>URL.revokeObjectURL(url), 1000);
                showToast('Downloaded chart image');
              }
              return;
            }

            // Plotly.js chart fallback
            if (window.currentChart || (typeof currentChart !== 'undefined' && currentChart)) {
              const url = await Plotly.toImage(chartCanvas, { format: 'png', scale: 2 });
              const res = await fetch(url);
              const blob = await res.blob();
              if (navigator.clipboard && window.ClipboardItem) {
                await navigator.clipboard.write([new ClipboardItem({ [blob.type]: blob })]);
                showToast('Chart image copied');
              } else {
                const a = document.createElement('a');
                a.href = url; a.download = `${getChartFilenameStem()}.png`; a.click();
                showToast('Downloaded chart image');
              }
              return;
            }
            showToast('Click Generate to create a chart first');
          } catch (e) { console.warn(e); showToast('Could not copy image'); }
        }
        function downloadChartImage() {
          try {
            const backendBlob = (typeof window !== 'undefined') ? window.VC_BACKEND_IMAGE_BLOB : null;
            const nameStem = getChartFilenameStem();
            if (backendBlob instanceof Blob) {
              const url = URL.createObjectURL(backendBlob);
              const a = document.createElement('a');
              a.href = url; a.download = `${nameStem}.png`; a.click();
              setTimeout(()=>URL.revokeObjectURL(url), 1000);
              return;
            }
            if (window.currentChart || (typeof currentChart !== 'undefined' && currentChart)) {
              Plotly.downloadImage(chartCanvas, { format: 'png', filename: nameStem, scale: 2 });
              return;
            }
            showToast('Click Generate to create a chart first');
          } catch (e) { console.warn(e); showToast('Could not download image'); }
        }
        function getCurrentCode() {
          if (monacoEditor) return monacoEditor.getValue();
          const ta = document.getElementById('code-editor');
          if (ta) return ta.value;
          const codeBlock = document.querySelector('#code-output-container code');
          return codeBlock ? codeBlock.textContent : '';
        }
        async function copyCode() {
          try { await navigator.clipboard.writeText(getCurrentCode()); showToast('Code copied'); }
          catch (e) { console.warn(e); showToast('Could not copy code'); }
        }
        function downloadCode() {
          const lang = document.querySelector('.library-btn.active')?.dataset?.lang || 'Code';
          const ext = lang === 'Python' ? 'py' : (lang === 'R' ? 'R' : 'js');
          const blob = new Blob([getCurrentCode()], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = `vega_chart.${ext}`; a.click();
          setTimeout(()=>URL.revokeObjectURL(url), 1000);
        }

        document.getElementById('chart-copy-btn')?.addEventListener('click', (e)=>{ e.stopPropagation(); copyChartImage(); });
        document.getElementById('chart-download-btn')?.addEventListener('click', (e)=>{ e.stopPropagation(); downloadChartImage(); });
        document.getElementById('code-copy-btn')?.addEventListener('click', (e)=>{ e.stopPropagation(); copyCode(); });
        document.getElementById('code-download-btn')?.addEventListener('click', (e)=>{ e.stopPropagation(); downloadCode(); });
        document.getElementById('code-reset-btn')?.addEventListener('click', (e)=>{ e.stopPropagation(); resetCodeToAuto(); });
        // Run button removed; Generate button handles running the chart

        // --- Custom Code Search (replaces editor/browser find) ---
        const codeSearch = { query: '', matches: [], index: -1, decorations: [] };
        const searchInput = document.getElementById('code-search-input');
        const searchPrevBtn = document.getElementById('code-search-prev');
        const searchNextBtn = document.getElementById('code-search-next');
        const searchCountEl = document.getElementById('code-search-count');
        const searchCloseBtn = document.getElementById('code-search-close');
        const codeSearchBar = document.getElementById('code-search-bar');

        function updateSearchCount() {
          const total = codeSearch.matches.length || 0;
          // Show 1-based position; never show 0 when matches exist
          const idx = total === 0 ? 0 : (codeSearch.index >= 0 ? (codeSearch.index + 1) : 1);
          if (searchCountEl) searchCountEl.textContent = `${idx} / ${total}`;
        }

        function clearMonacoHighlights() {
          try { if (typeof monacoEditor !== 'undefined' && monacoEditor && codeSearch.decorations) {
            codeSearch.decorations = monacoEditor.deltaDecorations(codeSearch.decorations, []);
          }} catch(_) {}
        }

        function computeMatches(query) {
          const q = (query || '').trim();
          codeSearch.query = q;
          codeSearch.matches = [];
          codeSearch.index = -1;
          clearMonacoHighlights();
          if (!q) { updateSearchCount(); return; }
          if (typeof monacoEditor !== 'undefined' && monacoEditor) {
            const model = monacoEditor.getModel();
            if (!model) { updateSearchCount(); return; }
            const matches = model.findMatches(q, false, false, false, null, false);
            codeSearch.matches = matches || [];
            try {
              codeSearch.decorations = monacoEditor.deltaDecorations(codeSearch.decorations, (matches || []).map(m => ({
                range: m.range,
                options: { inlineClassName: 'vc-search-match' }
              })));
            } catch(_) {}
          } else {
            const ta = document.getElementById('code-editor');
            if (!ta || ta.tagName !== 'TEXTAREA') { updateSearchCount(); return; }
            const text = ta.value || '';
            const lower = text.toLowerCase();
            const ql = q.toLowerCase();
            let idx = 0; let found;
            while ((found = lower.indexOf(ql, idx)) !== -1) {
              codeSearch.matches.push({ start: found, end: found + q.length });
              idx = found + (q.length || 1);
            }
          }
          updateSearchCount();
        }

        function jumpToMatch(next = true) {
          const q = (searchInput?.value || '').trim();
          // Only recompute if the query changed; avoid resetting index each click
          if (q !== codeSearch.query) {
            computeMatches(q);
          }
          const total = codeSearch.matches.length;
          if (!total) { updateSearchCount(); return; }

          // If no selection yet, start at first/last depending on direction
          if (codeSearch.index === -1) {
            codeSearch.index = next ? 0 : (total - 1);
          } else {
            codeSearch.index = (codeSearch.index + (next ? 1 : -1) + total) % total;
          }

          const current = codeSearch.matches[codeSearch.index];
          if (!current) { updateSearchCount(); return; }
          if (typeof monacoEditor !== 'undefined' && monacoEditor) {
            try {
              monacoEditor.setSelection(current.range);
              monacoEditor.revealRangeInCenter(current.range);
              monacoEditor.focus();
            } catch(_) {}
          } else {
            const ta = document.getElementById('code-editor');
            if (ta && ta.tagName === 'TEXTAREA') {
              try { ta.focus(); ta.setSelectionRange(current.start, current.end); } catch(_) {}
            }
          }
          updateSearchCount();
        }

        function showCodeSearch() {
          if (!codeSearchBar) return;
          codeSearchBar.classList.remove('hidden');
          if (searchInput) {
            let prefill = '';
            try {
              if (typeof monacoEditor !== 'undefined' && monacoEditor) {
                prefill = monacoEditor.getModel()?.getValueInRange(monacoEditor.getSelection()) || '';
              } else {
                const ta = document.getElementById('code-editor');
                if (ta && ta.tagName === 'TEXTAREA') {
                  prefill = ta.value.substring(ta.selectionStart || 0, ta.selectionEnd || 0) || '';
                }
              }
            } catch(_) {}
            if (prefill) searchInput.value = prefill;
            searchInput.focus();
            searchInput.select();
            computeMatches(searchInput.value);
          }
        }
        function hideCodeSearch() {
          if (!codeSearchBar) return;
          codeSearchBar.classList.add('hidden');
          clearMonacoHighlights();
          codeSearch.matches = [];
          codeSearch.index = -1;
          updateSearchCount();
          if (searchInput) searchInput.value = '';
          try {
            if (typeof monacoEditor !== 'undefined' && monacoEditor) { monacoEditor.focus(); }
            else { const ta = document.getElementById('code-editor'); ta && ta.focus(); }
          } catch(_) {}
        }

        // Intercept Ctrl/Cmd+F and use custom search only
        document.addEventListener('keydown', (e) => {
          const k = e.key;
          const isCtrlF = (k === 'f' || k === 'F') && (e.ctrlKey || e.metaKey);
          const isCtrlH = (k === 'h' || k === 'H') && (e.ctrlKey || e.metaKey);
          const isF3 = k === 'F3';
          if (isCtrlF) {
            e.preventDefault(); e.stopPropagation();
            if (codeSearchBar && !codeSearchBar.classList.contains('hidden')) hideCodeSearch();
            else showCodeSearch();
          } else if (isCtrlH) {
            e.preventDefault(); e.stopPropagation();
            // Show custom search instead of Monaco replace
            showCodeSearch();
          } else if (isF3) {
            e.preventDefault(); e.stopPropagation();
            // F3/Shift+F3 navigate next/prev
            if (codeSearchBar && !codeSearchBar.classList.contains('hidden')) {
              jumpToMatch(!e.shiftKey);
            } else {
              showCodeSearch();
            }
          }
        }, { capture: true });

        searchInput?.addEventListener('input', () => computeMatches(searchInput.value));
        searchInput?.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); jumpToMatch(true); } });
        searchPrevBtn?.addEventListener('click', (e) => { e.stopPropagation(); jumpToMatch(false); });
        searchNextBtn?.addEventListener('click', (e) => { e.stopPropagation(); jumpToMatch(true); });
        searchCloseBtn?.addEventListener('click', (e) => { e.stopPropagation(); hideCodeSearch(); });

        function resetCodeToAuto() {
          const selectedLang = document.querySelector('.library-btn.active')?.dataset.lang;
          const ed = document.getElementById('code-editor');
          if (selectedLang === 'JavaScript') {
            try {
              const cfg = buildChartConfig();
              autoJSCode = postProcessJSCode(jsCodeFromConfig(cfg));
            } catch (_) {
              const layout = partialLayoutFromInputs();
              autoJSCode = postProcessJSCode(codeFromPartialLayout(layout));
            }
            if (typeof monacoEditor !== 'undefined' && monacoEditor) { monacoEditor.setValue(autoJSCode); }
            if (ed) ed.value = autoJSCode;
            currentJSCode = autoJSCode;
            isCodeEdited = false;
            updateResetButtonVisibility();
            showToast('Code reset');
          } else if (selectedLang === 'Python') {
            try {
              const code = pyCodeFromInputs();
              autoPyCode = code;
            } catch(_) {
              autoPyCode = pyDefaultTemplate();
            }
            if (typeof monacoEditor !== 'undefined' && monacoEditor) { monacoEditor.setValue(autoPyCode); }
            if (ed) ed.value = autoPyCode;
            isPyEdited = false;
            updateResetButtonVisibility();
            showToast('Code reset');
          } else if (selectedLang === 'R') {
            try {
              const code = rCodeFromInputs();
              autoRCode = code;
            } catch(_) {
              autoRCode = rDefaultTemplate();
            }
            if (typeof monacoEditor !== 'undefined' && monacoEditor) { monacoEditor.setValue(autoRCode); }
            if (ed) ed.value = autoRCode;
            isREdited = false;
            updateResetButtonVisibility();
            showToast('Code reset');
          }
        }

        const userCodeExecutionHelpers = (() => {
          function isBlobLike(value) {
            return typeof Blob !== 'undefined' && value instanceof Blob;
          }
          function isResponseLike(value) {
            return typeof Response !== 'undefined' && value instanceof Response;
          }
          function isRequestLike(value) {
            return typeof Request !== 'undefined' && value instanceof Request;
          }
          async function readTextInput(source, label) {
            const target = label || 'resource';
            if (source == null) {
              throw new Error(`No ${target} provided.`);
            }
            if (typeof source === 'string' || source instanceof URL) {
              const res = await fetch(String(source));
              if (!res.ok) {
                throw new Error(`Failed to fetch ${target} (${res.status}).`);
              }
              return await res.text();
            }
            if (isRequestLike(source)) {
              const res = await fetch(source);
              if (!res.ok) {
                throw new Error(`Failed to fetch ${target} (${res.status}).`);
              }
              return await res.text();
            }
            if (isResponseLike(source)) {
              return await source.text();
            }
            if (isBlobLike(source)) {
              return await source.text();
            }
            if (typeof source === 'object' && typeof source.text === 'function') {
              return await source.text();
            }
            if (typeof source === 'object' && typeof source.body === 'string') {
              return source.body;
            }
            throw new Error(`Unsupported input type for ${target}.`);
          }
          async function readArrayBufferInput(source, label) {
            const target = label || 'resource';
            if (source == null) {
              throw new Error(`No ${target} provided.`);
            }
            if (typeof source === 'string' || source instanceof URL) {
              const res = await fetch(String(source));
              if (!res.ok) {
                throw new Error(`Failed to fetch ${target} (${res.status}).`);
              }
              return await res.arrayBuffer();
            }
            if (isRequestLike(source)) {
              const res = await fetch(source);
              if (!res.ok) {
                throw new Error(`Failed to fetch ${target} (${res.status}).`);
              }
              return await res.arrayBuffer();
            }
            if (isResponseLike(source)) {
              return await source.arrayBuffer();
            }
            if (isBlobLike(source)) {
              return await source.arrayBuffer();
            }
            if (source instanceof ArrayBuffer) {
              return source;
            }
            if (ArrayBuffer.isView(source)) {
              return source.buffer.slice(0);
            }
            if (typeof source === 'object' && typeof source.arrayBuffer === 'function') {
              return await source.arrayBuffer();
            }
            throw new Error(`Unsupported input type for ${target}.`);
          }
          function parseDelimitedText(text, preferredDelimiter) {
            if (typeof text !== 'string' || !text.trim()) return [];
            const lines = text.split(/\r?\n/).filter(line => line.trim().length);
            if (!lines.length) return [];
            const delimiter = preferredDelimiter || (text.indexOf('	') !== -1 ? '	' : ',');
            const parseLine = (line) => {
              const cells = [];
              let current = '';
              let inQuotes = false;
              for (let i = 0; i < line.length; i++) {
                const ch = line[i];
                if (ch === '"') {
                  if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
                  else { inQuotes = !inQuotes; }
                } else if (!inQuotes && ch === delimiter) {
                  cells.push(current);
                  current = '';
                } else {
                  current += ch;
                }
              }
              cells.push(current);
              return cells;
            };
            const header = parseLine(lines[0]).map(h => h.trim());
            return lines.slice(1).map(line => {
              const cells = parseLine(line);
              const row = {};
              header.forEach((key, idx) => {
                row[key] = cells[idx];
              });
              return row;
            });
          }
          async function csvToJSON(source) {
            const text = await readTextInput(source, 'CSV');
            return parseDelimitedText(text, ',');
          }
          async function tsvToJSON(source) {
            const text = await readTextInput(source, 'TSV');
            return parseDelimitedText(text, '	');
          }
          async function jsonToJSON(source) {
            const text = await readTextInput(source, 'JSON');
            const data = JSON.parse(text);
            if (Array.isArray(data)) return data;
            if (data && typeof data === 'object') {
              if (Array.isArray(data.rows)) return data.rows;
              if (Array.isArray(data.data)) return data.data;
              return [data];
            }
            return [];
          }
          async function excelToJSON(source) {
            if (typeof XLSX === 'undefined') {
              throw new Error('excelToJSON helper requires SheetJS (XLSX) library to be loaded on window.XLSX.');
            }
            const buffer = await readArrayBufferInput(source, 'Excel');
            const workbook = XLSX.read(buffer, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            if (!sheetName) return [];
            const sheet = workbook.Sheets[sheetName];
            return XLSX.utils.sheet_to_json(sheet);
          }
          return Object.freeze({
            csvToJSON,
            tsvToJSON,
            jsonToJSON,
            excelToJSON,
            parseDelimitedText,
            readTextInput,
            parseCSV: (text) => parseDelimitedText(text, ',')
          });
        })();

        const AsyncFunctionCtor = Object.getPrototypeOf(async function(){}).constructor;

        async function runUserJS() {
          const code = getCurrentCode();
          if (!code.trim()) return;
          const trimmed = code.trim();
          if (/^<\s*[\w!?/]/.test(trimmed)) {
            showToast('HTML snippet copied. Use in a standalone page.');
            return;
          }
          try {
            // Clear any existing overlay message
            document.getElementById('chart-center-message')?.remove();
            // Always clear any prior image/plot so JS doesn't overlay Python/R output
            clearChartArea();
            const helpers = userCodeExecutionHelpers;
            const prelude = `'use strict';\nconst { csvToJSON, tsvToJSON, jsonToJSON, excelToJSON, parseDelimitedText, parseCSV, readTextInput } = helpers;\n`;
            const wrapped = new AsyncFunctionCtor(
              'Plotly',
              'containerId',
              'uploadedData',
              'helpers',
              'VC_LAST_FILE',
              prelude + code + '\n//# sourceURL=user-code.js'
            );
            await wrapped(Plotly, 'chartCanvas', uploadedData, helpers, window.VC_LAST_FILE || null);
            chartPlaceholder?.classList.add('hidden');
            currentJSCode = code;
            showToast('Code executed');
            currentChart = true;
            try { window.currentChart = chartCanvas; } catch (_) {}
            setChartActionsEnabled(true);
            try { window.chartDisplayState = 'plotly'; } catch(_) {}
            // Attach zoom/pan listener for user-generated plots too
            if (chartCanvas && chartCanvas.on) {
              chartCanvas.removeAllListeners && chartCanvas.removeAllListeners('plotly_relayout');
              chartCanvas.on('plotly_relayout', (ev) => {
                if (ev && Object.keys(ev).some(k => k.includes('range'))) {
                  maybeShowZoomHint();
                }
              });
            }
          } catch (e) {
            console.warn(e);
            // Replace any existing chart and show standardized error state
            try { if (currentChart) { Plotly.purge(chartCanvas); currentChart = null; } } catch(_) {}
            try { window.currentChart = null; } catch (_) {}
            setChartDisplayState('error', `
              <div class="flex items-center justify-center h-full">
                <div class="text-center max-w-md px-4">
                  <div class="text-red-400 text-lg mb-2">⚠ JavaScript Error</div>
                  <pre class="text-red-300 text-sm bg-red-900/20 p-3 rounded border border-red-600/30 text-left whitespace-pre-wrap">${typeof e?.message === 'string' ? e.message : 'Error running code'}</pre>
                </div>
              </div>
            `);
            showToast('Error running code');
          }
        }
      });
    </script>
    <script>
      // Removed: logic that equalized column heights by adjusting Advanced section spacing.
      // Intentionally left empty to avoid unintended layout side-effects.
    </script>
    <script>
      // Dynamically adjust code output height to align columns by showing more/less lines
      function adjustCodeFiller() {
        try {
          const host = document.querySelector('#code-output-container .code-host');
          if (!host) return;

          // Monaco editor mode
          if (window.monacoEditor && host.id === 'monaco-editor') {
            const editor = window.monacoEditor;
            const model = editor.getModel && editor.getModel();
            if (!model) return;
            // Determine line height from editor options or fallback
            let lineH = 18;
            try {
              if (window.monaco && window.monaco.editor && editor.getOption) {
                const opt = editor.getOption(window.monaco.editor.EditorOption.lineHeight);
                if (typeof opt === 'number' && opt > 0) lineH = opt;
              }
            } catch(_) {}
            if (!lineH || !(lineH > 0)) {
              const cs = window.getComputedStyle(host);
              const lh = parseFloat(cs.lineHeight);
              if (lh && lh > 0) lineH = lh; else lineH = 18;
            }

            const lastLine = model.getLineCount();
            const lastTop = editor.getTopForLineNumber(lastLine);
            const lastBottom = lastTop + lineH;
            let viewportHeight = 0;
            try { viewportHeight = editor.getLayoutInfo().height; } catch(_) { viewportHeight = host.clientHeight; }
            const diffPx = Math.round(viewportHeight - lastBottom);
            const desired = diffPx > 6 ? Math.max(0, Math.ceil(diffPx / lineH)) : 0;

            // Count trailing blank lines
            let trailing = 0;
            for (let i = lastLine; i >= 1; i--) {
              const txt = model.getLineContent(i);
              if ((txt || '').trim() === '') trailing++; else break;
            }
            const recorded = parseInt(host.dataset.fillerCount || '0', 10) || 0;
            const owned = Math.min(recorded, trailing);
            const newCount = desired;
            const delta = newCount - owned;
            if (delta !== 0) {
              if (delta > 0) {
                const insertAtLine = model.getLineCount();
                const insertAtCol = model.getLineMaxColumn(insertAtLine);
                model.pushEditOperations([], [{
                  range: new (window.monaco.Range)(insertAtLine, insertAtCol, insertAtLine, insertAtCol),
                  text: '\n'.repeat(delta),
                  forceMoveMarkers: true
                }], () => null);
              } else {
                const remove = Math.min(-delta, Math.max(0, trailing));
                if (remove > 0) {
                  const endLine = model.getLineCount();
                  const startLine = Math.max(1, endLine - remove + 1);
                  const startCol = 1;
                  const endCol = model.getLineMaxColumn(endLine);
                  model.pushEditOperations([], [{
                    range: new (window.monaco.Range)(startLine, startCol, endLine, endCol),
                    text: '',
                    forceMoveMarkers: true
                  }], () => null);
                }
              }
              host.dataset.fillerCount = String(Math.max(0, newCount));
            }
            return;
          }

          // Textarea fallback
          if (host.tagName === 'TEXTAREA') {
            const ta = host;
            const hostH = ta.clientHeight;
            const contentH = ta.scrollHeight;
            const diff = Math.round(hostH - contentH);
            let lineH = parseFloat(getComputedStyle(ta).lineHeight);
            if (!lineH || !(lineH > 0)) lineH = 18;
            const desired = diff > 12 ? Math.max(0, Math.ceil(diff / lineH)) : 0;

            const recorded = parseInt(ta.dataset.fillerCount || '0', 10) || 0;
            const lines = (ta.value || '').split('\n');
            let trailing = 0;
            for (let i = lines.length - 1; i >= 0; i--) { if ((lines[i] || '').trim() === '') trailing++; else break; }
            const owned = Math.min(recorded, trailing);
            const delta = desired - owned;
            if (delta > 0) {
              ta.value = (ta.value || '') + '\n'.repeat(delta);
            } else if (delta < 0) {
              const remove = Math.min(-delta, Math.max(0, trailing));
              if (remove > 0) {
                ta.value = lines.slice(0, Math.max(0, lines.length - remove)).join('\n');
              }
            }
            ta.dataset.fillerCount = String(Math.max(0, desired));
          }
        } catch(_) {}
      }

  function adjustCodeOutputHeight() {
        try {
          const left = document.getElementById('left-col');
          const right = document.getElementById('right-col');
          const codeComp = document.getElementById('code-output-component');
          const host = document.querySelector('#code-output-container .code-host');
          if (!left || !right || !codeComp || !host) return;

          // Only adjust on side-by-side layout
          // Two-column only when width >= md breakpoint and aspect ratio is wider than 6:5
          const wideEnough = window.matchMedia('(min-width: 768px)').matches;
          const wideAspect = window.matchMedia('(min-aspect-ratio: 6/5)').matches;
          const notFallbackNarrow = !document.documentElement.classList.contains('ar-narrow');
          const twoCol = wideEnough && wideAspect && notFallbackNarrow;
          if (!twoCol) {
            // Reset to base height on mobile/stacked
            const base = parseFloat(host.dataset.baseHeight || '580');
            host.style.height = base + 'px';
            if (window.monacoEditor) window.monacoEditor.layout();
            // Still add filler so the editor area doesn't have blank space
            adjustCodeFiller();
            return;
          }

          // Compute bottoms for entire columns
          const leftBottom = left.getBoundingClientRect().bottom;
          const rightBottom = right.getBoundingClientRect().bottom;
          const diff = Math.round(leftBottom - rightBottom);

          // Guardrails
          const base = parseFloat(host.dataset.baseHeight || '580');
          const minH = Math.max(300, base - 200); // don't go too small
          const maxH = base + 800; // cap growth

          if (Math.abs(diff) < 8) { adjustCodeFiller(); return; } // close enough, but ensure filler

          const currentH = parseFloat(getComputedStyle(host).height) || base;
          let nextH = currentH + diff; // grow or shrink to match
          nextH = Math.max(minH, Math.min(maxH, nextH));
          host.style.height = nextH + 'px';
          if (window.monacoEditor) window.monacoEditor.layout();
          // After sizing, add filler lines if needed so the editor shows numbered blanks, not empty space
          adjustCodeFiller();
        } catch(_) {}
      }

      // Recalculate on load/resize and when collapsing sections
  window.addEventListener('load', () => setTimeout(() => { adjustCodeOutputHeight(); adjustCodeFiller(); }, 0));
      window.addEventListener('resize', () => requestAnimationFrame(adjustCodeOutputHeight));
      document.addEventListener('click', (e) => {
        if (e.target.closest('.component-header')) {
          // Wait for transition
          setTimeout(adjustCodeOutputHeight, 520);
        }
      });
      // Also re-run after short delay to catch async layout shifts
      setTimeout(adjustCodeOutputHeight, 300);

      // Observe size changes in columns/code component for reactive adjustment
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => {
          requestAnimationFrame(adjustCodeOutputHeight);
        });
        const left = document.getElementById('left-col');
        const right = document.getElementById('right-col');
        const codeComp = document.getElementById('code-output-component');
        left && ro.observe(left);
        right && ro.observe(right);
        codeComp && ro.observe(codeComp);
      }
    </script>
  </body>
</html>




